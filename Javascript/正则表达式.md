## 1.现有一字符串:
String str = "aaa[bbb[ccc,ddd[eee,fff]],ggg[hhh,iii]]";

要求,取出所有类似 xxx[xxx,xxx] 结构的字符串 ,

当然,这个最后的结果应该是 
aaa[bbb[ccc,ddd[eee,fff]],ggg[hhh,iii]]
bbb[ccc,ddd[eee,fff]]
ddd[eee,fff]
ggg[hhh,iii]

## 基本语法介绍
首先如何实例化一个正则表达式对象
```
// 使用字面量的方式
var reg = /\d/g;
// 使用构造函数的方式
var reg = new RegExp('\\b','g');
```
- 一种就是把要写的正则放在两个//之间，其中//后面的是修饰符
- 第二种，是通过new一个RegExp，接受两个参数，第一个是正则的内容。在\b前面加上了一个\是对\b中的\进行转义，记住这个是必须的，有特殊的字符都需要转义。第二个参数是修饰符

## 元字符：
> 元字符的概念：元字符是在正则表达式中有特殊含义的非字母字符
```
\f 换页符 
\n 换行符 
\r 回车 
\t 制表符 
\v 垂直制表符 
\/ 一个 / 直接量 
\\ 一个 \ 直接量 
\. 一个 . 直接量 
\* 一个 * 直接量 
\ 一个 + 直接量 
\? 一个 ? 直接量 
\| 一个 | 直接量 
\( 一个 ( 直接量 
\) 一个 ) 直接量 
\[ 一个 [ 直接量 
\] 一个 ] 直接量 
\{ 一个 { 直接量 
\} 一个 } 直接量 
```

## 字符类和范围类：
> 我们可以通过[]来表示一个类，匹配的时候匹配到[]其中一个即可。
例如[0-9]表示数字0到9，[a-zA-Z]表示匹配所有的大小写字母。
同时我们可以在[]中加入^表示一个反向类，例如[^9]表示除了9之外的所有字符

## 预定义类：
```
. 表示除了回车符和换行符之外的所有字符，等同于 [^\r\n]
\d 表示数字字符，等同于[0-9]
\D 表示非数字字符，等同于[^0-9]
\s 表示空白符，等同于[\t\n\x\f\r]
\S 表示非空白符，等同于[^\t\n\x\f\r]
\w 表示单词字符(字母数字下划线)，等同于[a-zA-Z_0-9]
\W 表示非单词字符，等同于[^a-zA-Z_0-9]
```
## 边界匹配字符：

```
^ 表示以XXX开始
$ 表示以XXX结束
\b 单词边界
\B 非单词边界
```

## 量词：

```
? 出现零次或一次（最多出现一次）
+ 出现一次或多次（至少出现一次）
* 出现零次或多次（任意次）
{n} 出现n次
{n,m} 出现n到m次
{n,} 至少出现n次
```

## 贪婪和非贪婪模式：

1. 正则表达式默认是贪婪模式，也就是说，正则匹配是会尽可能按照量词的上线多匹配
2. 想要关闭正则表达式的贪婪模式，只需要这么写/\d{1,8}?/加上一个?即可。

## 分组：
可以用()进行分组，可以Byr(on|Ca)sper进行或，或者是(/d/w12){9}进行转化
分组的内容从前到后，分别分组为$1,$2,$3...

忽略分组：
(?:Byron).(ok)只要在分组内加上?:就可以忽略分组

## 前瞻：
js正则表达式中只有前瞻没有后顾。
前瞻就是正则表达式匹配到规则的时候，向前检查是否符合断言

exp(?=assert) 正向前瞻，看一下正则后面的内容是否可以匹配上
exp(?!assert) 负向前瞻，看一下正则后面的内容是否可以不匹配上
## 对象属性：
- global:是否进行全局搜索，默认不进行，例子：/\d/g
- ignore case:是否忽略大小写，默认是不忽略，例子：/\d/i
- multiline:多行搜索，默认不开启多行搜索
- lastIndex:是当前表达式匹配内容的最后一个字符的下一个位置
- source:正则表达式的文本字符串

## 正则表达式的两个方法：
- test() // 接受一个参数，判断传入的字符串是否匹配正则表达式。
特别注意：如果正则中有g，会出现奇怪的结果，原因是lastIndex在作怪

- exec()  // 接受一个参数

## 字符串和正则有关的方法：

- search() // 接受一个参数，传入要搜索的正则表达式，如果匹配成功就返回第一个匹配结果的index，否则就返回-1
- match() // 和正则表达式exec很像
- spilt() // 将字符串分割为数组
- replace() // 支持两个参数，第一个是寻找和正则匹配的，下一个是替换的内容 
## 例题
1.用正则匹配手机号码
```
function (tele) {
    if (tele.search(/^1[34578]\d{9}$/) > -1) {
        return true
    } else {
        return false
    }
}
```
还有一种方法：
```
function (tele) {
    return /^1[34578]\d{9}$/.test(tele);
}
```
2.用正则从url中截取信息
```
var url = 'http://www.baidu.com/?dsp=ipad&sid=20510&name=wangbin';
var reg = /[?&](\w+)=(\w+)/g;
var obj = {};
while(ret = reg.exec(url)) {
    obj[ret[1]] = ret[2];
}
console.log(obj);
```