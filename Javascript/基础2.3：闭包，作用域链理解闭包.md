---
title: 基础2.3：闭包,作用域链理解闭包
categories: "基础2.3：作用域链，作用域链理解闭包"
tags:
  - JavaScript
  - 基础
---
**定义**
红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，
MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。

>简洁版：保护一个可重用的局部变量的词法结构

## 闭包的特性
- 函数嵌套函数
- 函数内部可以引用外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

## 闭包的优点
- 使一个变量长期驻扎在内存中
- 避免全局变量的污染
- 作为私有成员的存在

## 闭包的缺点
闭包的缺点，更多地是在内存性能的方面。

>由于变量长期驻扎在内存中，在复杂程序中可能会出现内存不足，但这也不算非常严重，我们需要在内存使用与开发方式上做好取舍。在不需要的时候清理掉变量

在某些时候（对象与DOM存在互相引用，GC使用引用计数法）会造成内存泄漏，要记得在退出函数前清理变量

```
window.onload = function() {
     var elem = document.querySelector('.txt');
     
     // elem的onclick指向了匿名函数，匿名函数的闭包也引用着elem
     elem.onclick = function() {
          console.log(this.innerHTML);
     };

     // 清理
     elem = null;
};    
```

除此之外，由于闭包中的变量可以在函数外部进行修改（通过暴露出去的接口方法），所有不经意间也内部的变量会被修改，所以也要注意

>只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。

1.函数作为返回值

![img](https://upload-images.jianshu.io/upload_images/17535584-f02cec66238c67ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2.函数作为参数传递

![img](https://upload-images.jianshu.io/upload_images/17535584-dbfd556beb6953d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。

>自由变量跨作用域取值时，曾经强调过：**要去创建这个函数的作用域取值**，而不是“父作用域”。理解了这一点

当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。

**核心内容**
函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。

![img](https://upload-images.jianshu.io/upload_images/17535584-014442d6a66666b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。

![img](https://upload-images.jianshu.io/upload_images/17535584-97313c67c08f239f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。

![img](https://upload-images.jianshu.io/upload_images/17535584-258c6ce3ada4a3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。

因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。

——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：

![img](https://upload-images.jianshu.io/upload_images/17535584-20daced13d1fbb6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。

![img](https://upload-images.jianshu.io/upload_images/17535584-e03bb49932d95f0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。

这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。

使用闭包会增加内容开销！



第五步，执行完20行就是上下文环境的销毁过程。
