## [精度丢失问题](https://www.cnblogs.com/snandy/p/4943138.html)
### 1. 两个简单的浮点数相加
```
0.1 + 0.2 != 0.3
// 0.30000000000000004
```
### 2. 大整数运算
```
var x = 9007199254740992
x + 1 == x // ？
// 9007199254740992
```
>JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992,大于 9007199254740992 的可能会丢失精度
### 3. toFixed 不会四舍五入（Chrome）
```
1.335.toFixed(2) // 1.33
```
```
// toFixed 修复
function toFixed(num, s) {
    var times = Math.pow(10, s)
    var des = num * times + 0.5
    des = parseInt(des, 10) / times
    return des + ''
}
```
### 解决方案
- 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。如果是id和后台商量好用String

- 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）
```
// 0.1 + 0.2
(0.1*10 + 0.2*10) / 10 == 0.3 // true
```