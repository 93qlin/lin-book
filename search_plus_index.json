{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 22:49:23 "},"CssAndHtml/":{"url":"CssAndHtml/","title":"Html和Css","keywords":"","body":"Html和Css相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 19:41:12 "},"CssAndHtml/Interview/":{"url":"CssAndHtml/Interview/","title":"面试必问 ✘","keywords":"","body":"Html和Css面试相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 19:41:23 "},"CssAndHtml/Interview/Html.html":{"url":"CssAndHtml/Interview/Html.html","title":"Html ✘","keywords":"","body":"面试知识点 - HTML HTML 属于结构层，负责描绘出内容的结构。 CSS 属于表示层，负责如何显示有关内容。 JavaScript 属于行为层，负责内容应如何对事件做出反应。 HTML学习推荐 《前端工程师手册》 《HTML 教程- (HTML5 标准) - 菜鸟教程》 HTML语义化 语义化的含义就是用正确的标签做正确的事情，HTML 语义化就是让页面的内容结构化，它有如下优点： 便于对浏览器、搜索引擎解析； 便于盲人浏览网页； 便于阅读源代码的人对网站进行分开，维护和理解； 简单来说，能用 、 等 H5 新标签的就不用 ，不要使用 来存放段落等…… HTML5 新标签 HTML5 中新增标签大致有：、、、、、、等等。 常见浏览器及其内核 Chrome Firefox Safari IE Opera 排版引擎 Blink Gecko Webkit Trident Blink JS 引擎 V8 SpiderMonkey Nitro Chakra V8 国内一些浏览器使用较多的是 Webkit 内核。 针对不同浏览器内核，HTML 辨别： IE 内核浏览器识别： 非 IE 内核浏览器识别： 针对不同浏览器内核，CSS 辨别： /* 设置文字不可选取 */ * { -moz-user-select: none; /* 火狐 浏览器 */ -webkit-user-select: none; /* Webkit 浏览器 */ -o-user-select: none; /* Opera 浏览器 */ -ms-user-select: none; /* IE10 浏览器 */ -khtml-user-select: none; /* 早期浏览器 */ user-select: none; /* 默认 */ } cookies、session、sessionStorage、localStorage cookies：存储于浏览器端的数据。可以设置 cookies 的到期时间，如果不设置时间，则在浏览器关闭窗口的时候会消失。 session：存储于服务器端的数据。session 存储特定用户会话所需的属性和配置信息。 cookies 和 session 的区别在于： cookies 数据存放在客户的浏览器上，session 数据存放在服务器上。 前端都是裸君子，没有安全可言，cookies 可能会被黑客利用作数据欺骗。所以重要信息记得存 session。 session 如果在生效期内量过大，会占用服务器性能。 单个 cookies 保存的数据不能超过 4 K，很多浏览器限制一个站点保存最多 20 个 cookies。 sessionStorage：生命周期存在于标签页或窗口，用于本地存储一个会话（session）中的数据，这些数据会随着窗口或者标签页的关闭而被清空。 localStorage：生命周期是永久的，除非用户主动清除浏览器上存储的 localStorage 信息，否则它将会永久存在。 sessionStorage 和 localStorage 操作方法：setItem、getItem 以及 removeItem。 以 localStorage 为例： localStorage.getItem('name'); // 获取 name 的值 localStorage.setItem('name', 'jsliang'); // 设置 name 的值为 jsliang localStorage.removeItem('name'); // 删除 name 的值 参考 1：《前端分享之cookie的使用及单点登录》参考 2：《Cookie、session和localStorage、以及sessionStorage之间的区别》 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:45:10 "},"CssAndHtml/Interview/Css.html":{"url":"CssAndHtml/Interview/Css.html","title":"Css ✘","keywords":"","body":"面试知识点 - css CSS CSS 属于表示层，负责如何显示有关内容。 CSS 学习推荐 《前端工程师手册》 《CSS 权威指南》 《CSS 揭秘》 《CSS 世界》 4.2 CSS reset 返回目录 在工作的过程中，会发现各式各样的浏览器对某个标签有自己独特的样式。 但是在前端开发中，如果不采用统一标准，那么会产生千奇百怪的 bug。所以为了减少后期 bug 的出现，前端开发人员会重置一遍 CSS 样式，尽可能地使开发的网页在各个浏览器相差不大。 CSS 盒模型 在工作的过程中，也许小伙伴需要 div 块的总宽度为 100px，然后发现总是被 margin 撑高，这是因为盒模型定义的问题： CSS 中有个属性叫 box-sizing。 box-sizing: border-box box-sizing: content-box border-box 中，整个 div 的宽、高，包括 margin、padding、border。 content-box 中，整个 div 的宽、高，则不包括上面元素。 如上图，如果一个 div ，你的代码如下： div { box-sizing: border-box; margin: 10px; width: 100px; height: 100px; padding: 10px; } 那么，你的整个宽高还是 100px。 但是，如果你的代码如下： div { box-sizing: content-box; margin: 10px; width: 100px; height: 100px; padding: 10px; } 那么，你的整个盒子宽高是 120px。 如果你在设计页面中，发现内容区被撑爆了，那么，请检查下现在的 border-box 是什么，最好在引用 reset.css 的时候，就对 border-box 进行统一设置，方便管理。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:45:55 "},"UseInJob/":{"url":"UseInJob/","title":"工作常用代码","keywords":"","body":"工作中常用到的代码 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-08 10:26:29 "},"UseInJob/Js.html":{"url":"UseInJob/Js.html","title":"Js ✘","keywords":"","body":"/* * 2018年7月25日10:38:23 * 移动端rem适配，px:rem = 100:1 * 该适配兼容UC竖屏转横屏出现的BUG * 自定义设计稿的宽度：designWidth * 最大宽度:maxWidth * 这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(1000, 1000); Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-08 10:33:00 "},"HttpAndBrowerAndSafe/":{"url":"HttpAndBrowerAndSafe/","title":"Http和浏览器以及安全","keywords":"","body":"http和浏览器相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:31:38 "},"HttpAndBrowerAndSafe/Interview/":{"url":"HttpAndBrowerAndSafe/Interview/","title":"面试必问 ✘","keywords":"","body":"常见面试题 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:31:53 "},"HttpAndBrowerAndSafe/Interview/HttpAndBrower.html":{"url":"HttpAndBrowerAndSafe/Interview/HttpAndBrower.html","title":"Http和浏览器相关 ✘","keywords":"","body":"面试知识点 - Http和浏览器 本文涉及知识点： 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:47:22 "},"HttpAndBrowerAndSafe/Interview/Safe.html":{"url":"HttpAndBrowerAndSafe/Interview/Safe.html","title":"网络安全相关 ✘","keywords":"","body":"面试知识点 - JS 防抖与节流 Create by jsliang on 2019-2-23 20:55:34Recently revised in 2019-05-24 11:08:58 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 本文涉及知识点： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 在本文中，jsliang 会讲解通过自我探索后关于上述知识点的个人理解，如有纰漏、疏忽或者误解，欢迎各位小伙伴留言指出。 如果小伙伴对文章存有疑问，想快速得到回复。或者小伙伴对 jsliang 个人的前端文档库感兴趣，也想将自己的前端知识整理出来。欢迎加 QQ 群一起探讨：798961601。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 防抖与节流  3.1 防抖  3.2 节流 四 重绘与回流 五 浏览器解析 URL 六 DNS 域名解析 七 TCP 三次握手与四次挥手 八 浏览器渲染页面 九 总结 十 参考文献 二 前言 返回目录 在工作中，我们可能碰到这样的问题： 用户在搜索的时候，在不停敲字，如果每敲一个字我们就要调一次接口，接口调用太频繁，给卡住了。 用户在阅读文章的时候，我们需要监听用户滚动到了哪个标题，但是每滚动一下就监听，那样会太过频繁从而占内存，如果再加上其他的业务代码，就卡住了。 所以，这时候，我们就要用到 防抖与节流 了。 那么，讲到 防抖与节流，我们可以顺带探秘下 重绘与回流。 说起 重绘与回流，我们就顺带把 浏览器输入 URL 后发生的事情 也关注一下，从而引出 DNS、TCP 等知识点，最终串起来构成本文的轮廓，方便 jsliang 和小伙伴们对这块知识的整理与记忆。 三 防抖与节流 返回目录 通过代码去了解某样事物，往往是了解某个知识点最快的形式。 3.1 防抖 返回目录 下面我们有段防抖小案例代码。 如果小伙伴们手头有电脑，并感兴趣想先自己思考下什么是防抖。可以将代码复制到浏览器，尝试点击按钮，并关注下控制台，看看 Console 是如何打印的。 如果小伙伴们手头没有电脑，那么咱一起先瞅瞅代码实现，再看看下面 GIF 演示。（这样效果没有自己敲的直白有效） 防抖 点我防抖！ window.onload = function() { // 1、获取这个按钮，并绑定事件 var myDebounce = document.getElementById(\"debounce\"); myDebounce.addEventListener(\"click\", debounce(sayDebounce)); } // 2、防抖功能函数，接受传参 function debounce(fn) { // 4、创建一个标记用来存放定时器的返回值 let timeout = null; return function() { // 5、每次当用户点击/输入的时候，把前一个定时器清除 clearTimeout(timeout); // 6、然后创建一个新的 setTimeout， // 这样就能保证点击按钮后的 interval 间隔内 // 如果用户还点击了的话，就不会执行 fn 函数 timeout = setTimeout(() => { fn.call(this, arguments); }, 1000); }; } // 3、需要进行防抖的事件处理 function sayDebounce() { // ... 有些需要防抖的工作，在这里执行 console.log(\"防抖成功！\"); } 很好，相信小伙伴们已经看完了代码，下面我们看看它的演示： 这时候，我们可以抛出防抖的概念了： 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！ 空讲无益，show you 场景： 有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。 小伙伴们可以尝试看着上面的案例，先自己实现一遍这个场景的解决，如果感觉不行，那就看：《防抖和节流的应用场景和实现》 知识点补充：何为 arguments？首先，后端转前端的同学，可以将 arguments 理解为能实现重载函数功能的工具。然后，我们举个例子：在 function test() 这个方法中，由于我们不确定变量有多少，比如 test(\"jsliang\", 24)，又或者 test(\"LiangJunrong\", \"jsliang\", \"24\")，这时候只需要在函数 test 中用 arguments 接收就行了。最后，在 function test() { let arr1 = argument[0] } 中，arr1 就可以获取到传进来的第一个变量。所以，fn.call(this, arguments) 其实是将不确定变量替换到函数中了。 参考资料 1：《闲聊 JS 中的 apply 和 call》参考资料 2：《js 中 arguments 的用法》 3.2 节流 返回目录 说完防抖，下面我们讲讲节流，规矩就不说了，先上代码： 节流 点我节流！ window.onload = function() { // 1、获取按钮，绑定点击事件 var myThrottle = document.getElementById(\"throttle\"); myThrottle.addEventListener(\"click\", throttle(sayThrottle)); } // 2、节流函数体 function throttle(fn) { // 4、通过闭包保存一个标记 let canRun = true; return function() { // 5、在函数开头判断标志是否为 true，不为 true 则中断函数 if(!canRun) { return; } // 6、将 canRun 设置为 false，防止执行之前再被执行 canRun = false; // 7、定时器 setTimeout( () => { fn.call(this, arguments); // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true canRun = true; }, 1000); }; } // 3、需要节流的事件 function sayThrottle() { console.log(\"节流成功！\"); } 很好，看完代码的小伙伴应该大致清楚是怎么回事了，下面我们看 GIF 实现： 看完代码和 GIF 实现，我们可以明白，节流即是： 节流：指定时间间隔内只会执行一次任务。 那么，节流在工作中的应用？ 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。 这样，在某些特定的工作场景，我们就可以使用防抖与节流来减少不必要的损耗。 那么问题来了，假设面试官听到你这句话，是不是会接着问一句：“为什么说上面的场景不节制会造成过多损耗呢？” OK，这就涉及到浏览器渲染页面的机制了…… 四 重绘与回流 返回目录 在说浏览器渲染页面之前，我们需要先了解两个点，一个叫 浏览器解析 URL，另一个就是本章节将涉及的 重绘与回流： 重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。 常见的重绘操作有： 改变元素颜色 改变元素背景色 more …… 回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 常见的回流操作有： 页面初次渲染 浏览器窗口大小改变 元素尺寸/位置/内容发生改变 元素字体大小变化 添加或者删除可见的 DOM 元素 激活 CSS 伪类（:hover……） more …… 重点：回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高。 看到这里，小伙伴们可能有点懵逼，你刚刚还跟我讲着 防抖与节流 ，怎么一下子跳到 重绘与回流 了？ OK，卖个关子，先看下面场景： 界面上有个 div 框，用户可以在 input 框中输入 div 框的一些信息，例如宽、高等，输入完毕立即改变属性。但是，因为改变之后还要随时存储到数据库中，所以需要调用接口。如果不加限制…… 看到这里，小伙伴们可以将一些字眼结合起来了：为什么需要 节流，因为有些事情会造成浏览器的 回流，而 回流 会使浏览器开销增大，所以我们通过 节流 来防止这种增大浏览器开销的事情。 形象地用图来说明： 这样，我们就可以形象的将 防抖与节流 与 重绘与回流 结合起来记忆起来。 那么，在工作中我们要如何避免大量使用重绘与回流呢？： 避免频繁操作样式，可汇总后统一一次修改 尽量使用 class 进行样式修改，而不是直接操作样式 减少 DOM 的操作，可使用字符串一次性插入 OK，至此我们就讲完两个部分了，那么问题又来了：“浏览器渲染过程中，是不是也有重绘与回流？”“从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？” 我们，继续深入探索…… 五 浏览器解析 URL 返回目录 为了能让我们的知识层面看起来更有深度，我们应该考虑下面两个问题了： 从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？ 浏览器渲染过程中，发生了什么，是不是也有重绘与回流？ OK，兴致来了，我们就先从 浏览器解析 URL 看起，先来看看当用户输入 URL，到浏览器呈现给用户页面，经历了以下过程： 版本 A： 用户输入 URL 地址。 对 URL 地址进行 DNS 域名解析。 建立 TCP 连接（三次握手）。 浏览器发起 HTTP 请求报文。 服务器返回 HTTP 响应报文。 关闭 TCP 连接（四次挥手）。 浏览器解析文档资源并渲染页面。 讲到这里，突然想起一个对话： 学生：“老师，这门课的考试重点是什么？” 老师：“全都是重点！” enm...老师会不会被打我不知道，但是 jsliang 这样写会被怼我就清楚，所以，咱还是结合上面的图，进一步勾勒我们的结构： 很好，jsliang 感觉自己的画图技术又进了一步~ ①：虽然很感激网上有那么多的文章可以参考，但是在我查了二十来篇文章后，jsliang 觉得这部分十有八九有问题撒，问了些小伙伴，它们有的说对，有的说错。不过，不妨碍小伙伴们继续往下看哈。②：为了避免出篓子，下面贴出另外一个版本，小伙伴们可以在评论区说出你支持哪个版本哈： 版本 B 用户输入 URL 地址。 对 URL 地址进行 DNS 域名解析。 进行 TCP 连接。 进行 HTTP 报文的请求与响应。 浏览器解析文档资源并渲染页面。 在这里我们可以清晰的了解到从 用户输入 URL，到浏览器呈现给用户页面，经历了哪些过程。 那么剩下的就简单了： 什么是 DNS 解析，它是怎么个流程？ 什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？ 浏览器解析文档资源并渲染页面是个怎样的流程？ Let's go~ 逐步完成下面三个知识点！ 参考文献 1：《网页解析的全过程(输入url到展示页面)》参考文献 2：《浏览器渲染页面过程剖析》 六 DNS 域名解析 返回目录 首先，我们解决第一个问题： 什么是 DNS 解析，它是怎么个流程？ DNS（Domain Name System）是 域名系统 的英文缩写，提供的服务是用于将主机名和域名转换为 IP 地址的工作： 域名：http://jsliang.top DNS IPV4：119.147.15.13 IPV4 是造假的，仅用来说明 DNS 解析后能返回 IP 地址 所以，当用户在浏览器输入 http://jsliang.top 时，DNS 经历了以下步骤： 浏览器根据地址，在自身缓存中查找 DNS（域名服务器） 中的解析记录。如果存在，则直接返回 IP 地址；如果不存在，则查找操作系统中的 hosts 文件是否有该域名的 DNS 解析记录，如果有就返回。 在条件 1 中的浏览器缓存或者操作系统的 hosts 文件中都没有这个域名的 DNS 解析记录，或者已经过期，则向域名服务器发起请求解析这个域名。 先向本地域名服务器中请求，让它解析这个域名，如果解析不了，则向根域名服务器请求解析。 根服务器给本地域名服务器返回一个主域名服务器。 本地域名服务器向主域名服务器发起解析请求。 主域名服务器接收到解析请求后，查找并返回域名对应的域名服务器的地址。 域名服务器会查询存储的域名和 IP 的映射关系表，返回目标 IP 记录以及一个 TTL（Time To Live）值。 本地域名服务器接收到 IP 和 TTL 值，进行缓存，缓存的时间由 TTL 值控制。 将解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。 看文字总是难以理解的，跟着 jsliang 画张图过一遍，就感觉清晰了： 七 TCP 三次握手与四次挥手 返回目录 然后，我们解决第二个问题： 什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？ 什么是 TCP 呢？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 简单来说，它的作用就是将数据流从一台主机可靠地传输到另一台主机。 至于具体的工作原理，这里暂时涉及不到，我们目前只想知道两个点：三次握手与四次挥手。 三次握手： 第一次握手：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 seq = x，并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认。 第二次握手：Server 收到数据包后由标志位 SYN = 1 得知 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack = x + 1，随机产生一个值 seq = y，并将该数据包发送给Client以确认连接请求，Server 进入 SYN-RCVD 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量。 第三次握手：Client 收到确认后，检查 seq 是否为 x + 1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack = y + 1，并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 y + 1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 established 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据。 文字太乱，show you picture： 四次挥手： 第一次挥手：Client 的应用进程先向其 TCP 发出连接释放报文段（FIN = 1，序号 seq = u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 Server 的确认。 第二次挥手：Server 收到连接释放报文段后即发出确认报文段，（ACK = 1，确认号 ack = u + 1，序号 seq = v），Server 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，Client 到 Server 的连接释放。 注：Client 收到 Server 的确认后，进入 FIN-WAIT-2（终止等待2）状态，等待 Server 发出的连接释放报文段。 第三次挥手：Server 已经没有要向 Client 发出的数据了，Server 发出连接释放报文段（FIN = 1，ACK = 1，序号 seq = w，确认号 ack = u + 1），Server 进入 LAST-ACK（最后确认）状态，等待 Client 的确认。 第四次挥手：Client 收到 Server 的连接释放报文段后，对此发出确认报文段（ACK = 1，seq = u + 1，ack = w + 1），Client 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，Client 才进入 CLOSED 状态。 文字太乱，show you picture： OK，至此我们就理解了 TCP 及其三次握手和四次挥手过程，为了方便小伙伴们形象记忆，jsliang 搞了个小故事，希望小伙伴们能加深印象： 三次握手 + 四次挥手形象记忆： jsliang：（对妹子发起微信好友申请）“你好，我可以加你好友吗？” —— 第一次握手 妹子：（通过审核）“你好，很高兴认识你~” —— 第二次握手 jsliang：“你好，我叫梁峻荣，前端折腾小能手……” —— 第三次握手 ……（聊天内容） …………（聊天内容） ………………（聊天内容） …………（聊天内容） ……（聊天内容） jsliang：（感冒拍了张纸篓都是纸巾的图）“啊，好难受今天。” —— 第一次挥手 妹子：“卧槽，你好恶心！” —— 第二次挥手 妹子：“咱还是当不认识吧，互删了，谢谢！” —— 第三次挥手 jsliang：（呆）“不是，你听我说！” —— 第四次挥手 妹子：（果断删除好友） —— CLOSED jsliang：（！“我今天感冒了。” 妹子开启了好友验证，你还不是她好友。请先发送好友验证请求，对方验证通过后，才能聊天。） ——— CLOSED OK，成功出糗，相信小伙伴们有了个很好的了解了。 那么，我们继续前行探索。 参考文献 1：《TCP三次握手和四次挥手过程》参考文献 2：《TCP的三次握手与四次挥手（详解+动图）》 八 浏览器渲染页面 返回目录 最后，我们解决第三个问题： 浏览器解析文档资源并渲染页面是个怎样的流程？ 话不多说，一起来看： 浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。 浏览器通过 CSSParser 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。 浏览器将 JavaScript 通过 DOM API 或者 CSSOM API 将 JS 代码解析并应用到布局中，按要求呈现响应的结果。 根据 DOM 树和 CSSOM 树来构造 render Tree。 layout：重排（也可以叫回流），当 render tree 中任一节点的几何尺寸发生改变，render tree 就会重新布局，重新来计算所有节点在屏幕的位置。 repaint：重绘，当 render tree 中任一元素样式属性（几何尺寸没改变）发生改变时，render tree 都会重新画，比如字体颜色，背景等变化。 paint：遍历 render tree，并调动硬件图形 API 来绘制每个节点。 文字讲解肯定还是不够清晰的，但是 jsliang 画了几张图也累了，所以咱们 盗 来了一张图： 这样，我们就对 浏览器渲染页面过程 一清二楚啦~ 参考文献：《一篇文章搞定前端面试》 九 总结 返回目录 至此，我们回顾下自己做了什么？ 我们在工作中碰到一些问题，这些问题会卡住页面，于是我们查资料，知道想要减少浏览器的开销，我们就需要使用 防抖与节流。 使用 防抖与节流 解决完问题后，我们好奇为什么会有这样的操作，于是我们深入了解了下 重绘与回流。 重绘与回流 只告诉了我们浏览器在 CSS 上的渲染，我们需要进一步了解 浏览器渲染页面 的详细过程，但洋葱还是要一层一层剥开的，所以我们需要从 浏览器解析 URL 开始了解。 在 浏览器解析 URL 中，我们顺带了解下 DNS 域名解析、TCP 三次握手与四次挥手 这两个知识点。 最后，我们终于知道了 浏览器渲染页面 是怎么一回事。 综上，如果我们仅仅是需要关注面试的一个点，我们很可能因为不知头尾，而被面试官问得哑口无言。 但是，如果我们知道一个知识点，并对其进行思路发散，深入学习，相信面试官问起来的时候，小伙伴们就可以侃侃而谈，而不会被问地体无完肤了！ 最后祝小伙伴们找到合适的满意的工作~ 十 参考文献 返回目录 《函数防抖和节流》 《节流 & 防抖》 《JS奇淫巧技：防抖函数与节流函数》 《闲聊 JS 中的 apply 和 call》 《js 中 arguments 的用法》 《防抖和节流的应用场景和实现》 《网页解析的全过程(输入url到展示页面)》 《浏览器渲染页面过程剖析》 《一篇文章搞定前端面试》 不折腾的前端，和咸鱼有什么区别！ jsliang 会每天在公众号发表一篇文章，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构等等。 扫描上方二维码，关注 jsliang 的公众号，让我们一起折腾！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:40:31 "},"HttpAndBrowerAndPerformanceSafety/":{"url":"HttpAndBrowerAndPerformanceSafety/","title":"Http和浏览器以及安全","keywords":"","body":"http和浏览器相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:31:38 "},"HttpAndBrowerAndPerformanceSafety/Interview/":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/","title":"面试必问 ✘","keywords":"","body":"常见面试题 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:31:53 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower.html","title":"Http和浏览器相关 ✘","keywords":"","body":"面试知识点 - Http和浏览器 本文涉及知识点： 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:47:22 "},"HttpAndBrowerAndPerformanceSafety/Interview/Safe.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/Safe.html","title":"网络安全相关 ✘","keywords":"","body":"面试知识点 - JS 防抖与节流 Create by jsliang on 2019-2-23 20:55:34Recently revised in 2019-05-24 11:08:58 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 本文涉及知识点： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 在本文中，jsliang 会讲解通过自我探索后关于上述知识点的个人理解，如有纰漏、疏忽或者误解，欢迎各位小伙伴留言指出。 如果小伙伴对文章存有疑问，想快速得到回复。或者小伙伴对 jsliang 个人的前端文档库感兴趣，也想将自己的前端知识整理出来。欢迎加 QQ 群一起探讨：798961601。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 防抖与节流  3.1 防抖  3.2 节流 四 重绘与回流 五 浏览器解析 URL 六 DNS 域名解析 七 TCP 三次握手与四次挥手 八 浏览器渲染页面 九 总结 十 参考文献 二 前言 返回目录 在工作中，我们可能碰到这样的问题： 用户在搜索的时候，在不停敲字，如果每敲一个字我们就要调一次接口，接口调用太频繁，给卡住了。 用户在阅读文章的时候，我们需要监听用户滚动到了哪个标题，但是每滚动一下就监听，那样会太过频繁从而占内存，如果再加上其他的业务代码，就卡住了。 所以，这时候，我们就要用到 防抖与节流 了。 那么，讲到 防抖与节流，我们可以顺带探秘下 重绘与回流。 说起 重绘与回流，我们就顺带把 浏览器输入 URL 后发生的事情 也关注一下，从而引出 DNS、TCP 等知识点，最终串起来构成本文的轮廓，方便 jsliang 和小伙伴们对这块知识的整理与记忆。 三 防抖与节流 返回目录 通过代码去了解某样事物，往往是了解某个知识点最快的形式。 3.1 防抖 返回目录 下面我们有段防抖小案例代码。 如果小伙伴们手头有电脑，并感兴趣想先自己思考下什么是防抖。可以将代码复制到浏览器，尝试点击按钮，并关注下控制台，看看 Console 是如何打印的。 如果小伙伴们手头没有电脑，那么咱一起先瞅瞅代码实现，再看看下面 GIF 演示。（这样效果没有自己敲的直白有效） 防抖 点我防抖！ window.onload = function() { // 1、获取这个按钮，并绑定事件 var myDebounce = document.getElementById(\"debounce\"); myDebounce.addEventListener(\"click\", debounce(sayDebounce)); } // 2、防抖功能函数，接受传参 function debounce(fn) { // 4、创建一个标记用来存放定时器的返回值 let timeout = null; return function() { // 5、每次当用户点击/输入的时候，把前一个定时器清除 clearTimeout(timeout); // 6、然后创建一个新的 setTimeout， // 这样就能保证点击按钮后的 interval 间隔内 // 如果用户还点击了的话，就不会执行 fn 函数 timeout = setTimeout(() => { fn.call(this, arguments); }, 1000); }; } // 3、需要进行防抖的事件处理 function sayDebounce() { // ... 有些需要防抖的工作，在这里执行 console.log(\"防抖成功！\"); } 很好，相信小伙伴们已经看完了代码，下面我们看看它的演示： 这时候，我们可以抛出防抖的概念了： 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！ 空讲无益，show you 场景： 有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。 小伙伴们可以尝试看着上面的案例，先自己实现一遍这个场景的解决，如果感觉不行，那就看：《防抖和节流的应用场景和实现》 知识点补充：何为 arguments？首先，后端转前端的同学，可以将 arguments 理解为能实现重载函数功能的工具。然后，我们举个例子：在 function test() 这个方法中，由于我们不确定变量有多少，比如 test(\"jsliang\", 24)，又或者 test(\"LiangJunrong\", \"jsliang\", \"24\")，这时候只需要在函数 test 中用 arguments 接收就行了。最后，在 function test() { let arr1 = argument[0] } 中，arr1 就可以获取到传进来的第一个变量。所以，fn.call(this, arguments) 其实是将不确定变量替换到函数中了。 参考资料 1：《闲聊 JS 中的 apply 和 call》参考资料 2：《js 中 arguments 的用法》 3.2 节流 返回目录 说完防抖，下面我们讲讲节流，规矩就不说了，先上代码： 节流 点我节流！ window.onload = function() { // 1、获取按钮，绑定点击事件 var myThrottle = document.getElementById(\"throttle\"); myThrottle.addEventListener(\"click\", throttle(sayThrottle)); } // 2、节流函数体 function throttle(fn) { // 4、通过闭包保存一个标记 let canRun = true; return function() { // 5、在函数开头判断标志是否为 true，不为 true 则中断函数 if(!canRun) { return; } // 6、将 canRun 设置为 false，防止执行之前再被执行 canRun = false; // 7、定时器 setTimeout( () => { fn.call(this, arguments); // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true canRun = true; }, 1000); }; } // 3、需要节流的事件 function sayThrottle() { console.log(\"节流成功！\"); } 很好，看完代码的小伙伴应该大致清楚是怎么回事了，下面我们看 GIF 实现： 看完代码和 GIF 实现，我们可以明白，节流即是： 节流：指定时间间隔内只会执行一次任务。 那么，节流在工作中的应用？ 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。 这样，在某些特定的工作场景，我们就可以使用防抖与节流来减少不必要的损耗。 那么问题来了，假设面试官听到你这句话，是不是会接着问一句：“为什么说上面的场景不节制会造成过多损耗呢？” OK，这就涉及到浏览器渲染页面的机制了…… 四 重绘与回流 返回目录 在说浏览器渲染页面之前，我们需要先了解两个点，一个叫 浏览器解析 URL，另一个就是本章节将涉及的 重绘与回流： 重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。 常见的重绘操作有： 改变元素颜色 改变元素背景色 more …… 回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 常见的回流操作有： 页面初次渲染 浏览器窗口大小改变 元素尺寸/位置/内容发生改变 元素字体大小变化 添加或者删除可见的 DOM 元素 激活 CSS 伪类（:hover……） more …… 重点：回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高。 看到这里，小伙伴们可能有点懵逼，你刚刚还跟我讲着 防抖与节流 ，怎么一下子跳到 重绘与回流 了？ OK，卖个关子，先看下面场景： 界面上有个 div 框，用户可以在 input 框中输入 div 框的一些信息，例如宽、高等，输入完毕立即改变属性。但是，因为改变之后还要随时存储到数据库中，所以需要调用接口。如果不加限制…… 看到这里，小伙伴们可以将一些字眼结合起来了：为什么需要 节流，因为有些事情会造成浏览器的 回流，而 回流 会使浏览器开销增大，所以我们通过 节流 来防止这种增大浏览器开销的事情。 形象地用图来说明： 这样，我们就可以形象的将 防抖与节流 与 重绘与回流 结合起来记忆起来。 那么，在工作中我们要如何避免大量使用重绘与回流呢？： 避免频繁操作样式，可汇总后统一一次修改 尽量使用 class 进行样式修改，而不是直接操作样式 减少 DOM 的操作，可使用字符串一次性插入 OK，至此我们就讲完两个部分了，那么问题又来了：“浏览器渲染过程中，是不是也有重绘与回流？”“从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？” 我们，继续深入探索…… 五 浏览器解析 URL 返回目录 为了能让我们的知识层面看起来更有深度，我们应该考虑下面两个问题了： 从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？ 浏览器渲染过程中，发生了什么，是不是也有重绘与回流？ OK，兴致来了，我们就先从 浏览器解析 URL 看起，先来看看当用户输入 URL，到浏览器呈现给用户页面，经历了以下过程： 版本 A： 用户输入 URL 地址。 对 URL 地址进行 DNS 域名解析。 建立 TCP 连接（三次握手）。 浏览器发起 HTTP 请求报文。 服务器返回 HTTP 响应报文。 关闭 TCP 连接（四次挥手）。 浏览器解析文档资源并渲染页面。 讲到这里，突然想起一个对话： 学生：“老师，这门课的考试重点是什么？” 老师：“全都是重点！” enm...老师会不会被打我不知道，但是 jsliang 这样写会被怼我就清楚，所以，咱还是结合上面的图，进一步勾勒我们的结构： 很好，jsliang 感觉自己的画图技术又进了一步~ ①：虽然很感激网上有那么多的文章可以参考，但是在我查了二十来篇文章后，jsliang 觉得这部分十有八九有问题撒，问了些小伙伴，它们有的说对，有的说错。不过，不妨碍小伙伴们继续往下看哈。②：为了避免出篓子，下面贴出另外一个版本，小伙伴们可以在评论区说出你支持哪个版本哈： 版本 B 用户输入 URL 地址。 对 URL 地址进行 DNS 域名解析。 进行 TCP 连接。 进行 HTTP 报文的请求与响应。 浏览器解析文档资源并渲染页面。 在这里我们可以清晰的了解到从 用户输入 URL，到浏览器呈现给用户页面，经历了哪些过程。 那么剩下的就简单了： 什么是 DNS 解析，它是怎么个流程？ 什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？ 浏览器解析文档资源并渲染页面是个怎样的流程？ Let's go~ 逐步完成下面三个知识点！ 参考文献 1：《网页解析的全过程(输入url到展示页面)》参考文献 2：《浏览器渲染页面过程剖析》 六 DNS 域名解析 返回目录 首先，我们解决第一个问题： 什么是 DNS 解析，它是怎么个流程？ DNS（Domain Name System）是 域名系统 的英文缩写，提供的服务是用于将主机名和域名转换为 IP 地址的工作： 域名：http://jsliang.top DNS IPV4：119.147.15.13 IPV4 是造假的，仅用来说明 DNS 解析后能返回 IP 地址 所以，当用户在浏览器输入 http://jsliang.top 时，DNS 经历了以下步骤： 浏览器根据地址，在自身缓存中查找 DNS（域名服务器） 中的解析记录。如果存在，则直接返回 IP 地址；如果不存在，则查找操作系统中的 hosts 文件是否有该域名的 DNS 解析记录，如果有就返回。 在条件 1 中的浏览器缓存或者操作系统的 hosts 文件中都没有这个域名的 DNS 解析记录，或者已经过期，则向域名服务器发起请求解析这个域名。 先向本地域名服务器中请求，让它解析这个域名，如果解析不了，则向根域名服务器请求解析。 根服务器给本地域名服务器返回一个主域名服务器。 本地域名服务器向主域名服务器发起解析请求。 主域名服务器接收到解析请求后，查找并返回域名对应的域名服务器的地址。 域名服务器会查询存储的域名和 IP 的映射关系表，返回目标 IP 记录以及一个 TTL（Time To Live）值。 本地域名服务器接收到 IP 和 TTL 值，进行缓存，缓存的时间由 TTL 值控制。 将解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。 看文字总是难以理解的，跟着 jsliang 画张图过一遍，就感觉清晰了： 七 TCP 三次握手与四次挥手 返回目录 然后，我们解决第二个问题： 什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？ 什么是 TCP 呢？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 简单来说，它的作用就是将数据流从一台主机可靠地传输到另一台主机。 至于具体的工作原理，这里暂时涉及不到，我们目前只想知道两个点：三次握手与四次挥手。 三次握手： 第一次握手：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 seq = x，并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认。 第二次握手：Server 收到数据包后由标志位 SYN = 1 得知 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack = x + 1，随机产生一个值 seq = y，并将该数据包发送给Client以确认连接请求，Server 进入 SYN-RCVD 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量。 第三次握手：Client 收到确认后，检查 seq 是否为 x + 1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack = y + 1，并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 y + 1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 established 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据。 文字太乱，show you picture： 四次挥手： 第一次挥手：Client 的应用进程先向其 TCP 发出连接释放报文段（FIN = 1，序号 seq = u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 Server 的确认。 第二次挥手：Server 收到连接释放报文段后即发出确认报文段，（ACK = 1，确认号 ack = u + 1，序号 seq = v），Server 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，Client 到 Server 的连接释放。 注：Client 收到 Server 的确认后，进入 FIN-WAIT-2（终止等待2）状态，等待 Server 发出的连接释放报文段。 第三次挥手：Server 已经没有要向 Client 发出的数据了，Server 发出连接释放报文段（FIN = 1，ACK = 1，序号 seq = w，确认号 ack = u + 1），Server 进入 LAST-ACK（最后确认）状态，等待 Client 的确认。 第四次挥手：Client 收到 Server 的连接释放报文段后，对此发出确认报文段（ACK = 1，seq = u + 1，ack = w + 1），Client 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，Client 才进入 CLOSED 状态。 文字太乱，show you picture： OK，至此我们就理解了 TCP 及其三次握手和四次挥手过程，为了方便小伙伴们形象记忆，jsliang 搞了个小故事，希望小伙伴们能加深印象： 三次握手 + 四次挥手形象记忆： jsliang：（对妹子发起微信好友申请）“你好，我可以加你好友吗？” —— 第一次握手 妹子：（通过审核）“你好，很高兴认识你~” —— 第二次握手 jsliang：“你好，我叫梁峻荣，前端折腾小能手……” —— 第三次握手 ……（聊天内容） …………（聊天内容） ………………（聊天内容） …………（聊天内容） ……（聊天内容） jsliang：（感冒拍了张纸篓都是纸巾的图）“啊，好难受今天。” —— 第一次挥手 妹子：“卧槽，你好恶心！” —— 第二次挥手 妹子：“咱还是当不认识吧，互删了，谢谢！” —— 第三次挥手 jsliang：（呆）“不是，你听我说！” —— 第四次挥手 妹子：（果断删除好友） —— CLOSED jsliang：（！“我今天感冒了。” 妹子开启了好友验证，你还不是她好友。请先发送好友验证请求，对方验证通过后，才能聊天。） ——— CLOSED OK，成功出糗，相信小伙伴们有了个很好的了解了。 那么，我们继续前行探索。 参考文献 1：《TCP三次握手和四次挥手过程》参考文献 2：《TCP的三次握手与四次挥手（详解+动图）》 八 浏览器渲染页面 返回目录 最后，我们解决第三个问题： 浏览器解析文档资源并渲染页面是个怎样的流程？ 话不多说，一起来看： 浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。 浏览器通过 CSSParser 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。 浏览器将 JavaScript 通过 DOM API 或者 CSSOM API 将 JS 代码解析并应用到布局中，按要求呈现响应的结果。 根据 DOM 树和 CSSOM 树来构造 render Tree。 layout：重排（也可以叫回流），当 render tree 中任一节点的几何尺寸发生改变，render tree 就会重新布局，重新来计算所有节点在屏幕的位置。 repaint：重绘，当 render tree 中任一元素样式属性（几何尺寸没改变）发生改变时，render tree 都会重新画，比如字体颜色，背景等变化。 paint：遍历 render tree，并调动硬件图形 API 来绘制每个节点。 文字讲解肯定还是不够清晰的，但是 jsliang 画了几张图也累了，所以咱们 盗 来了一张图： 这样，我们就对 浏览器渲染页面过程 一清二楚啦~ 参考文献：《一篇文章搞定前端面试》 九 总结 返回目录 至此，我们回顾下自己做了什么？ 我们在工作中碰到一些问题，这些问题会卡住页面，于是我们查资料，知道想要减少浏览器的开销，我们就需要使用 防抖与节流。 使用 防抖与节流 解决完问题后，我们好奇为什么会有这样的操作，于是我们深入了解了下 重绘与回流。 重绘与回流 只告诉了我们浏览器在 CSS 上的渲染，我们需要进一步了解 浏览器渲染页面 的详细过程，但洋葱还是要一层一层剥开的，所以我们需要从 浏览器解析 URL 开始了解。 在 浏览器解析 URL 中，我们顺带了解下 DNS 域名解析、TCP 三次握手与四次挥手 这两个知识点。 最后，我们终于知道了 浏览器渲染页面 是怎么一回事。 综上，如果我们仅仅是需要关注面试的一个点，我们很可能因为不知头尾，而被面试官问得哑口无言。 但是，如果我们知道一个知识点，并对其进行思路发散，深入学习，相信面试官问起来的时候，小伙伴们就可以侃侃而谈，而不会被问地体无完肤了！ 最后祝小伙伴们找到合适的满意的工作~ 十 参考文献 返回目录 《函数防抖和节流》 《节流 & 防抖》 《JS奇淫巧技：防抖函数与节流函数》 《闲聊 JS 中的 apply 和 call》 《js 中 arguments 的用法》 《防抖和节流的应用场景和实现》 《网页解析的全过程(输入url到展示页面)》 《浏览器渲染页面过程剖析》 《一篇文章搞定前端面试》 不折腾的前端，和咸鱼有什么区别！ jsliang 会每天在公众号发表一篇文章，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构等等。 扫描上方二维码，关注 jsliang 的公众号，让我们一起折腾！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:40:31 "},"HttpAndBrowerAndPerformanceSafety/Interview/performance.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/performance.html","title":"性能相关 ✘","keywords":"","body":"Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 20:51:09 "},"Coding/js/手写代码.html":{"url":"Coding/js/手写代码.html","title":"js手写代码 ✘","keywords":"","body":"js手写代码 算法相关  [1. JS实现的数组全排列输出算法](#S1)  [2. 判断一个单词是否是回文？](#S2)  [3. 去掉一组整型数组重复的值](#S3)  [4. 随机生成指定长度的字符串](#S4)  [5. js中的广度优先遍历（BFS）和深度优先遍历（DFS][https://www.jianshu.com/p/b4d8085e84bd][https://www.jianshu.com/p/5e9ea25a1aae](#S4) --> 基础 1. 函数节流 将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 function throttle(fn,delay){ let timer = null; let startTime = +new Date() return function(...args){ let curTime = +new Date() let remaining = delay - (curTime -startTime) const context = this clearTimeout(timer) if(remaining 2. 函数防抖 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 function debounce(fn,wait=50,immediate) { let timer; return function() { if(immediate) { fn.apply(this,arguments) } if(timer) clearTimeout(timer) timer = setTimeout(()=> { fn.apply(this,arguments) },wait) } } 3. 手写promise 简化版 //简易promise实现(resolve,reject) function promise(fn) { this.value = undefined // 成功状态值 this.err = undefined // 失败状态值 this.status = 'pending' // 开始状态（就绪） var t = this // 就绪 -> 成功 function resolve(val) { if (t.status === 'pending') { t.value = val t.status = 'success' } } // 就绪 -> 失败 function reject(err) { if (t.status === 'pending') { t.err = err t.status = 'fail' } } fn(resolve, reject) } promise.prototype.then = function(isSuccess, isFail) { var t = this // 实现promise的链式调用 return new promise(function(resolve, reject) { // 用setTimeout模拟实现then方法的异步操作 setTimeout(function() { if (t.status === 'success') { // 将then1回调函数返回的值传给then2回调函数，以此类推 resolve(isSuccess(t.value)) } if (t.status === 'fail') { reject(isFail(t.err)) } }) }) } // test var p = new promise(function(resolve, reject) { if (1) { resolve(\"test resolve success\") } else { reject(\"test rejecr fail\") } }) p.then(function(val) { console.log(val) return val + \"链式调用return\" }).then(function(val) { console.log(val) }) // test resolve success // test resolve success链式调用return 升级版 const PENDING = \"pending\"; const FULFILLED = \"fulfilled\"; const REJECTED = \"rejected\"; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() => { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb => cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() => { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 => rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb => cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) => { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); } } Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value => value; onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason; }; if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) => { setTimeout(() => { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) => { setTimeout(() => { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) => { that.onFulfilledCallbacks.push((value) => { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) => { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } }; 4.用Promise对象实现的 Ajax const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); }); return promise; }; getJSON(\"/posts.json\").then(function(json) { console.log('Contents: ' + json); }, function(error) { console.error('出错了', error); }); 方法（递归）： 简化版 阶乘的实现方法（递归）： function factorial (num) { if (num 6.实现一个JSON.stringify > Boolean | Number| String 类型会自动转换成对应的原始值。 undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = [] let arr = Array.isArray(obj) for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\") } } jsonStringify({x : 5,aa: {bb: {cc: {dd: {ee:1}}}}}) \"{\"x\":5,\"aa\":{\"bb\":{\"cc\":{\"dd\":{\"ee\":1}}}}}\" 8.写一个sum函数满足无限传参的条件 一个sum函数满足无限传参的条件 sum(1) = 1;//返回的是一个函数，此时调用函数的valueOf函数 sum(1)(2)(3) = 6; sum(1, 2, 3)(4) = 10; sum(1)(2)(3)(4)(5) = 15; 写 解题： function sum() { var args = Array.prototype.slice.call(arguments); //将arguments转成数组 var funName = arguments.callee; //记录函数名，以便后面递归调用函数 var fn = function () { var innerArgs = Array.prototype.slice.call(arguments); 将arguments转成数组 var finals = args.concat(innerArgs); return funName.apply(null, finals); //递归 } fn.valueOf = function () {// 当函数返回的是函数时，自动调用fn.valueOf函数 return args.reduce(function (a, b) { return a + b; }) } return fn; } 9.转换成数组的方法 方法一：var args = Array.prototype.slice.call(arguments); 方法二：var args = [].slice.call(arguments, 0); 方法三： var args = []; for (var i = 1; i var toArray = function(s){ try{ return Array.prototype.slice.call(s); } catch(e){ var arr = []; for(var i = 0,len = s.length; i 算法相关 1. JS实现的数组全排列输出算法 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。 function permute(input) { var permArr = [], usedChars = []; function main(input){ var i, ch; for (i = 0; i 2. 判断一个单词是否是回文？ function checkPalindrom(str) { return str == str.split('').reverse().join(''); } 3. 去掉一组整型数组重复的值 比如 输入: [1,13,24,11,11,14,1,2]， 输出: [1,13,24,11,14,2] ，需要去掉重复的11 和 1 这两个元素。 function(arr) { let hashTable = {}; let data = []; for(let i=0,l=arr.length;i// 去除数组的重复成员 [...new Set(array)] 上面的方法也可以用于，去除字符串里面的重复字符。 [...new Set('ababbc')].join('') // \"abc\" 4. 随机生成指定长度的字符串 实现一个算法，随机生成指制定长度的字符窜。 function randomString(n) { let str = 'abcdefghijklmnopqrstuvwxyz9876543210'; let tmp = '', i = 0, l = str.length; for (i = 0; i Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 21:08:02 "},"Coding/":{"url":"Coding/","title":"手写代码","keywords":"","body":"手写代码 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 21:00:30 "},"Coding/js/":{"url":"Coding/js/","title":"js ✘","keywords":"","body":"js手写代码 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 21:00:41 "}}