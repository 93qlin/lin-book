{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 开启服务 gitbook serve 打包 gitbook build 发布 sudo gh-pages -d _book Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-24 11:38:13 "},"webpack/webpack面试题.html":{"url":"webpack/webpack面试题.html","title":"webpack","keywords":"","body":"目录  1.对webpack的了解  2.webpack，里面的webpack.config.js怎么配置  3.webpack本地开发怎么解决跨域的  4.如何配置多入口文件  5. webpack与grunt、gulp的不同  6. 有哪些常见的Loader？他们是解决什么问题的  7. 有哪些常见的Plugin？他们是解决什么问题的  8. Loader和Plugin的不同  9. webpack的构建流程是什么  10. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路  11. webpack的热更新是如何做到的？说明其原理  12. 如何利用webpack来优化前端性能  13. 如何提高webpack的构建速度  14. 怎么配置单页应用？怎么配置多页应用  15. 什么是bundle,什么是chunk，什么是module 1. 对webpack的了解 官方文档 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，将项目当作一个整体，通过一个给定的的主文件，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包成一个或多个浏览器可识别的js文件 核心概念： 入口(entry) 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点） module.exports = { entry: './path/to/my/entry/file.js' }; 输出(output) output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist loader loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript） 插件(plugins) loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量 模式 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 module.exports = { mode: 'production' }; 2. webpack，里面的webpack.config.js怎么配置 let webpack = require('webpack'); module.exports = { entry:'./entry.js', //入口文件 output:{ //node.js中__dirname变量获取当前模块文件所在目录的完整绝对路径 path:__dirname, //输出位置 filename:'build.js' //输入文件 }, module:{ // 关于模块的加载相关，我们就定义在module.loaders中 // 这里通过正则表达式去匹配不同后缀的文件名，然后给它们定义不同的加载器。 // 比如说给less文件定义串联的三个加载器（！用来定义级联关系）： rules:[ { test:/\\.css$/, //支持正则 loader:'style-loader!css-loader' } ] }, //配置服务 devServer:{ hot:true, //启用热模块替换 inline:true //此模式支持热模块替换：热模块替换的好处是只替换更新的部分,而不是页面重载. }, //其他解决方案配置 resolve:{ extensions:['','.js','.json','.css','.scss'] }, //插件 plugins:[ new webpack.BannerPlugin('This file is create by baibai') ] } 3. webpack本地开发怎么解决跨域的 下载 webpack-dev-server 插件 配置 webpack.config.js 文件 // webpack.config.js var WebpackDevServer = require(\"webpack-dev-server\"); module.exports = { ... devServer: { ... port: '8088', //设置端口号 // 代理设置 proxy: { '/api': { target: 'http://localhost:80/index.php', // 目标代理 pathRewrite: {'^/api' : ''}, // 重写路径 secure: false, // 是否接受运行在 HTTPS 上 } } } } 4. 如何配置多入口文件 配置多个入口文件 entry: { home: resolve(__dirname, \"src/home/index.js\"), about: resolve(__dirname, \"src/about/index.js\") } 5. webpack与grunt、gulp的不同 三者都是前端构建工具 grunt 和 gulp 是基于任务和流的。找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程 webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能 webpack 与前者最大的不同就是支持代码分割，模块化（AMD,CommonJ,ES2015），全局分析 为什么选择webpack 6. 有哪些常见的Loader？他们是解决什么问题的 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS slint-loader：通过 SLint 检查 JavaScript 代码 babel-loader：把 ES6 转换成 ES5 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 7. 有哪些常见的Plugin？他们是解决什么问题的 define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 AutoWebPlugin: 管理多个单页应用, 8. Loader和Plugin的不同 loader 加载器 Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件. Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力 在 module.rules 中配置，也就是说他作为模块的解析规则而存在，类型为数组 Plugin 插件 扩展 webpack 的功能，让 webpack 具有更多的灵活性 在 plugins 中单独配置。类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入 9. webpack的构建流程是什么 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果 10. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路 编写 Loader 时要遵循单一原则，每个 Loader 只做一种\"转义\"工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback() 方法，将内容返回给 webpack 。 还可以通过 this.async()生成一个 callback 函数，再用这个 `callback`` 将处理后的内容输出出去 相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果 11. webpack的热更新是如何做到的？说明其原理 具体可以参考 这里 12. 如何利用webpack来优化前端性能 压缩代码。删除多余的代码、注释、简化代码的写法等等方式 利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径 删除死代码 Tree Shaking）。将代码中永远不会走到的片段删除掉 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载，提取公共代码 给打包出来的文件名添加哈希，实现浏览器缓存文件 13. 如何提高webpack的构建速度 参考 这里 14. 怎么配置单页应用？怎么配置多页应用 单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可 多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范 15. 什么是bundle,什么是chunk，什么是module bundle 是由 webpack 打包出来的文件，chunk 是指 webpack 在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-28 10:57:21 "},"CssAndHtml/":{"url":"CssAndHtml/","title":"Html和Css","keywords":"","body":"Html和Css相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 19:41:12 "},"CssAndHtml/Interview/":{"url":"CssAndHtml/Interview/","title":"面试必问 ✘","keywords":"","body":"Html和Css面试相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 19:41:23 "},"CssAndHtml/Interview/Html.html":{"url":"CssAndHtml/Interview/Html.html","title":"Html ✘","keywords":"","body":"面试知识点 - HTML HTML 属于结构层，负责描绘出内容的结构。 CSS 属于表示层，负责如何显示有关内容。 JavaScript 属于行为层，负责内容应如何对事件做出反应。 HTML学习推荐 《前端工程师手册》 《HTML 教程- (HTML5 标准) - 菜鸟教程》  1. Doctype作用，HTML5 为什么只需要写  2. 行内元素有哪些，块级元素有哪些，空(void)元素有那些  3. 简述一下你对HTML语义化的理解  4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解  5. html5有哪些新特性  6. 描述一下 cookies，sessionStorage 和 localStorage 的区别  7. 如何实现浏览器内多个标签页之间的通信  8. HTML5的离线存储怎么使用，解释一下工作原理  9. src与href的区别  10. 表单提交中Get和Post方式的区别  11. cookies、session、sessionStorage、localStorage  12. 渐进增强和优雅降级？  13. img 的 alt 与 title 有何异同？ strong 与 em 的异同？  14.document load 和document ready 的区别  15.document.write(),outerHTML、outerText、innerHTML、innerText属性 1. Doctype作用，HTML5 为什么只需要写 doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的（document type definition）文档类型定义（DTD）来解析文档.声明必须是HTML文档的第一行，位于html标签之前 HTML 4.01 基于 SGML:标准通用标示语言（Standard Generalized Markup Language）是现时常用的超文本格式的最高层次标准。 HTML5不基于SGML，所以不需要引用DTD。在HTML5中只有一种 2. 行内元素有哪些，块级元素有哪些，空(void)元素有那些 行内元素：a span i img input select b 等 块级元素：div ul ol li h1~h6 p table 等 空元素：br hr link 等 3. 简述一下你对HTML语义化的理解 简单来说，就是合适的标签做合适的事情，这样具有以下好处： 有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取，利于SEO 有利于不同设备的解析 有利于构建清晰的机构，有利于团队的开发、维护 便于盲人浏览网页 简单来说，能用 、 等 div 新标签的就不用 ，不要使用 来存放段落等…… 4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解 Trident内核：IE Gecko内核：NETSCAPE6及以上版本，火狐 Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari，Chrome等。[Chrome的：Blink（WebKit的分支）] 浏览器内核又可以分成两部分：渲染引擎和JS引擎。 渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。 5. html5有哪些新特性 语义化标签: header footer nav section article aside 等 增强型表单：date(从一个日期选择器选择一个日期) email(包含 e-mail 地址的输入域) number(数值的输入域) range(一定范围内数字值的输入域) search(用于搜索域) tel(定义输入电话号码字段) 等 视频和音频：audio video Canvas绘图 SVG绘图 地理定位：Geolocation 拖放API：drag web worker：是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能 web storage: localStorage sessionStorage WebSocket: HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议6. 描述一下 cookie，sessionStorage 和 localStorage 的区别 特性 Cookie localStorage sessionStorage 生命周期 可设置失效时间，没有设置的话，默认是关闭浏览器后失效 除非被手动清除，否则将会永久保存 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 存放数据大小 4KB左右 可以保存5MB的信息 http请求 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 7. 如何实现浏览器内多个标签页之间的通信 使用localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket协议 webworker 多个标签页之间的通信 8. HTML5的离线存储怎么使用，解释一下工作原理 HTML5的离线存储 9. src与href的区别 区别：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系 浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的 当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件 10. 表单提交中Get和Post方式的区别 Get一般用于从服务器上获取数据，Post向服务器传送数据 Get传输的数据是拼接在Url之后的，对用户是可见的；Post的传输数据对用户是不可见的 Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制 Get安全性非常低，Post安全性较高 在FORM提交的时候，如果不指定Method，则默认为Get请求常见浏览器及其内核 Chrome Firefox Safari IE Opera 排版引擎 Blink Gecko Webkit Trident Blink JS 引擎 V8 SpiderMonkey Nitro Chakra V8 国内一些浏览器使用较多的是 Webkit 内核。 针对不同浏览器内核，HTML 辨别： IE 内核浏览器识别： 非 IE 内核浏览器识别： 针对不同浏览器内核，CSS 辨别： /* 设置文字不可选取 */ * { -moz-user-select: none; /* 火狐 浏览器 */ -webkit-user-select: none; /* Webkit 浏览器 */ -o-user-select: none; /* Opera 浏览器 */ -ms-user-select: none; /* IE10 浏览器 */ -khtml-user-select: none; /* 早期浏览器 */ user-select: none; /* 默认 */ } 11. cookies、session、sessionStorage、localStorage cookies：存储于浏览器端的数据。可以设置 cookies 的到期时间，如果不设置时间，则在浏览器关闭窗口的时候会消失。 session：存储于服务器端的数据。session 存储特定用户会话所需的属性和配置信息。 cookies 和 session 的区别在于： cookies 数据存放在客户的浏览器上，session 数据存放在服务器上。 前端都是裸君子，没有安全可言，cookies 可能会被黑客利用作数据欺骗。所以重要信息记得存 session。 session 如果在生效期内量过大，会占用服务器性能。 单个 cookies 保存的数据不能超过 4 K，很多浏览器限制一个站点保存最多 20 个 cookies。 sessionStorage：生命周期存在于标签页或窗口，用于本地存储一个会话（session）中的数据，这些数据会随着窗口或者标签页的关闭而被清空。 localStorage：生命周期是永久的，除非用户主动清除浏览器上存储的 localStorage 信息，否则它将会永久存在。 sessionStorage 和 localStorage 操作方法：setItem、getItem 以及 removeItem。 以 localStorage 为例： localStorage.getItem('name'); // 获取 name 的值 localStorage.setItem('name', 'jsliang'); // 设置 name 的值为 jsliang localStorage.removeItem('name'); // 删除 name 的值 参考 1：《前端分享之cookie的使用及单点登录》参考 2：《Cookie、session和localStorage、以及sessionStorage之间的区别》 渐进增强和优雅降级？ 复制代码 .transition{ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; } .transition{ 　　 transition: all .5s; 　　 -o-transition: all .5s; 　-moz-transition: all .5s; -webkit-transition: all .5s; } 第一个例子的写法叫做渐进增强（progressive enhancement），第二个例子的写法叫做优雅降级（graceful degradation）。（关于渐进增强，可以参考张鑫旭的文章： http://www.zhangxinxu.com/wordpress/?p=788） 什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？ 渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。） 优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。） 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要。 img 的 alt 与 title 有何异同？ strong 与 em 的异同？ img中的alt和title都是提示文字,但是alt是图片加载失败时的提示文字,title是鼠标放在图片上时的提示文字 strong和em都是强调的意思,只不过strong是强烈的强调,strong在显示时是黑粗体,em是倾斜体 Html b加粗与html strong加粗本质没有区别 document load 和document ready 的区别 load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数 问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 $(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行 在原生的jS中不包括ready()这个方法，只有load方法就是onload事件 document.write(),outerHTML、outerText、innerHTML、innerText属性 document.write是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。 outerHTML | outerText | innerHTML | innerText 这四个都是js原生DOM对象的属性，返回的数据都是string类型。 看例子： 获取属性 ``` var oHtml = $(\"div\")[0].outerHTML; var oText = $(\"div\")[0].outerText; var iHtml = $(\"div\")[0].innerHTML; var iText = $(\"div\")[0].innerText; div a 分别返回： div a div a div a div a 设置属性 $(\"div\")[0].outerHTML = \"a\"; $(\"div\")[0].outerText = \"a\"; $(\"div\")[0].innerHTML = \"a\"; $(\"div\")[0].innerText = \"a\"; 分别变成： a a a a ``` 也就是说: outer和inner决定是不是包含最外层（当前）标签； Text和HTML获取时决定是否把标签忽略，插入时决定是否把字符串解析为标签。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-28 13:43:32 "},"CssAndHtml/Interview/Css.html":{"url":"CssAndHtml/Interview/Css.html","title":"Css ✘","keywords":"","body":"面试知识点 - css CSS CSS 属于表示层，负责如何显示有关内容。 CSS 学习推荐 《前端工程师手册》 《CSS 权威指南》 《CSS 揭秘》 《CSS 世界》 CSS部分  1. css盒子模型，box-sizing属性的理解  2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法  3. 如何让一个不定宽高的盒子水平垂直居中  4. px和em和rem的区别  5. position的值有哪些  6. display:none与visibility：hidden的区别  7. CSS中link 和@import的区别  8. 什么是响应式设计，响应式设计的基本原理是什么  9. 为什么要初始化CSS样式  10. CSS3有哪些新特性  11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用  12. CSS优化、提高性能的方法有哪些  13. 重绘和重排（回流）的理解  14. flex布局css预处理器  15. css预处理器  16. css中可以让文字在垂直和水平方向上重叠的两个属性是什么？  17.消除inline-block元素间隔  18.绘制三角形  19.选择器优先  20.css伪类和伪元素  21.脱离文档流的有哪些  22.为何要清除浮动？如何清除？  23.css哪些属性可以继承  24.三栏布局（圣杯和双飞翼）和两栏布局  25.:link、:hover、:active和:visited的区别？ CSS 1. css盒子模型，box-sizing属性的理解 IE盒模型和标准盒模型的区别 css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定 先说重要的区别： 两者的区别在于content的不同，IE盒模型的content包括border、padding 即IE的border,padding改变实际大小（width,height）不变。但是标准的会变 box-sizing是一个CSS3属性，与盒子模型有着密切联系。即决定元素的宽高如何计算，box-sizing有三个属性： box-sizing: content-box|border-box|inherit: content-box 使得元素的宽高即为内容区的宽高(默认模式) border-box: 计算方式content + padding + border = 本身元素大小，即缩小了content大小 inherit 指定box-sizing属性的值，应该从父元素继承 2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方式： 为父元素设置高度 为父元素添加overflow:hidden 伪元素.fix::after { content:\"\"; display:block; clear:both; } 使用伪元素的好处：不增加冗余的DOM节点，符合语义化 overflow:hidden可以触发BFC机制。BFC：块级格式化上下文，创建了 BFC的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算BFC的高度时，浮动元素也参与计算 3. 如何让一个不定宽高的盒子水平垂直居中 定位的方式 .father { position: relative; } .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; } css3属性 .father { position: relative; } .son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex布局 .father { display: flex; justify-content: center; align-items: center; } 4. px和em和rem的区别 px: 像素，相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em的值并不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素 的，也代表倍数 5. position的值有哪些 static： 默认值。没有定位，元素出现在正常的流中 relative（相对定位）：生成相对定位的元素,相对于其正常（原先本身）位置进行定位 absolute（绝对定位）：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位 fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位 6. display:none与visibility：hidden的区别 区别 display:none visibility：hidden的 是否占据空间 不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中） 该元素空间依旧存在 是否渲染 会触发reflow（回流），进行渲染 只会触发repaint（重绘），因为没有发现位置变化，不进行渲染 是否是继承属性 不是继承属性，元素及其子元素都会消失 是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出 7. CSS中link 和@import的区别 link属于XHTML标签，@import完全是CSS提供的一种方式,只能加载CSS 加载顺序的差别，当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载 兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，而link标签无此问题 当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的 8. 什么是响应式设计，响应式设计的基本原理是什么 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 9. 为什么要初始化CSS样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异 初始化样式会对 SEO 有一定的影响 10. CSS3有哪些新特性 实现圆角border-radius，阴影box-shadow，边框图片border-image 对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient 实现旋转transform:rotate(90deg),缩放scale(0.85,0.90),translate(0px,-30px)定位,倾斜skew(-9deg,0deg); 增加了更多的CSS选择器、多背景、rgba() 唯一引入的伪元素是::selection； 实现媒体查询@media，多栏布局flex 过渡transition 动画animation 1）边框： border-radius：圆角边框，border-radius:25px; box-shadow：边框阴影，box-shadow: 10px 10px 5px #888888; border-image：边框图片，border-image:url(border.png) 30 30 round; （2）背景： background-size：规定背景图片的尺寸，background-size:63px 100px; background-origin：规定背景图片的定位区域，背景图片可以放置于 content-box、padding-box 或 border-box 区域。background-origin:content-box; CSS3 允许您为元素使用多个背景图像。background-image:url(bg_flower.gif),url(bg_flower_2.gif); （3）文本效果： text-shadow：向文本应用阴影，可以规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。text-shadow: 5px 5px 5px #FF0000; word-wrap：允许文本进行换行。word-wrap:break-word; （4）字体：CSS3 @font-face 规则可以自定义字体。 （5）2D 转换（transform） translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 transform: translate(50px,100px); rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform: rotate(30deg); scale()：元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。transform: scale(2,4); skew()：元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。transform: skew(30deg,20deg); matrix()： 把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。transform:matrix(0.866,0.5,-0.5,0.866,0,0); （6）3D 转换 rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform: rotateX(120deg); rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform: rotateY(130deg); （7）transition：过渡效果，使页面变化更平滑 transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。 transition-duration：过渡动画的一个持续时间。 transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 。 transition-delay：延迟多久后开始动画。 简写为：transition: [ || || || ]; （8）animation：动画 使用CSS3 @keyframes 规则。 animation-name: 定义动画名称 animation-duration: 指定元素播放动画所持续的时间长 animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )： 指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。 animation-delay: 指定元素动画开始时间 animation-iteration-count:infinite | ：指定元素播放动画的循环次 animation-direction: normal | alternate： 指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。 animation-play-state:running | paused ：控制元素动画的播放状态。 简写为： animation:[ || || || || || ] 11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）,双冒号是在当前规范中引入的，用于区分伪类和伪元素 12. CSS优化、提高性能的方法有哪些 移除空的css规则（Remove empty rules） 正确使用display的属性 不滥用浮动、web字体 不声明过多的font-size 不在选择符中使用ID标识符 遵守盒模型规则 尽量减少页面重排、重绘 抽象提取公共样式，减少代码量 13. 重绘和重排（回流）的理解 重绘（repaint或redraw）： 重绘是指当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知render 重新描绘相应的元素, 此过程称为重绘。 重排： 重排是指某些元素变化涉及元素布局 (如width), 浏览器则抛弃原有属性, 重新计算，此过程称为重排。（重排一定会重绘，重绘不一定重排） 回流（reflow）： 重排好的结果，传递给render以重新描绘页面元素, 此过程称为回流 重绘和重排（回流）的理解 14. flex布局 flex布局教程--阮一峰 15. css预处理器 提供了一种css的书写方式，常见的就是 SAAS文档 和 LESS文档 16. css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height 水平方向：letter-spacing 那么问题来了，关于letter-spacing的妙用知道有哪些么？ 答案:可以用于消除inline-block元素间的换行符空格间隙问题 17.消除inline-block元素间隔 父元素 设置font-size：0 ；letter-spacing：-3px ，子元素重新设置font-size，letter-spacing: 0; 18.绘制三角形 首先先做一个测试深入理解一下盒子模型，主要体会一下height和border-width的用法： \\#div1{ height: 80px; border-style: solid; border-width: 100px 100px 100px 100px; border-color: red forestgreen blue cyan; width: 80px; } \\ ## \\ 最后结果为： 其中，红色的块儿代表是上边框宽度，右边的块儿代表右边框宽度，以此类推，发现几个边距的宽度而言，他们之间的分界恰好是这个正方形的对角线所在的直线，如果里面的小盒子宽高无穷小，那么这个图形将是一个由四块不同颜色三角形拼接而成的图形，因此可以利用这个性质进行绘制三角形。若height:0;width:0;得到下面的图形： 如果我们想要得到一个上三角，那么根据刚刚的原理，只要将上边框、左右边框设置为隐藏，即可实现一个上三角。 border-color: transparent transparent blue transparent; 但是有个问题，这里这个三角距离上面总是有100px的边距，是因为隐藏的边框依然占位，所以直接将上边框去掉就好了 所以实现三角形 第一步：新建一个div。 第二步：为盒子添加样式。 1.向上.kailong{ width:0; height:0; border-right:50px solid transparent; border-left:50px solid transparent; border-bottom:50px solid red; } 2.向下.kailong{ width:0; height:0; border-right:50px solid transparent; border-left:50px solid transparent; border-top:50px solid red; } 3.向左 .kailong{ width:0; height:0; border-top:50px solid transparent; border-bottom:50px solid transparent; border-right:50px solid red; } 4.向右 .kailong{ width:0; height:0; border-top:50px solid transparent; border-bottom:50px solid transparent; border-left:50px solid red; } 19.选择器优先级 !important > 内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 元素选择器 = 关系选择器 = 伪元素选择器 > 通配符选择器 20.css伪类和伪元素 css伪类 css伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息 :link, :visited, :hover, :focus, :active, :first-child, :lang - css3新增的伪类： :last-child, :only-child, :first-of-type, :last-of-type, :only-of-type, :nth-child(n), :nth-last-child(n), :nth-of-type(n), :nth-last-of-type(n), :root, :empty, :target, :enabled, :disabled, :checked, :not(selector), css伪元素 css伪元素本质上是创建了一个有内容的虚拟容器。 ::first-letter, ::first-line, ::before, ::after css3新增的伪元素 ::selection 总结 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息； 伪元素本质上是创建了一个有内容的虚拟容器； CSS3中伪类和伪元素的语法不同； 可以同时使用多个伪类，而只能同时使用一个伪元素；css伪类和伪元素的区别 为了避免大家混淆伪类和伪元素，css3中的标准规定伪类使用单冒号“:” ，伪元素使用双冒号“::”，但在此之前都使用的单冒号“:”，所以为了保证兼容伪元素两种使用方法都是可以的。 伪类可以叠加使用，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。 .box:first-child:hover { color: #000;} //使用伪类 .box:first-letter { color: #000;} //使用伪元素 .box:first-letter:hover { color: #000;} //错误写法 伪类与类优先级相同，伪元素与标签优先级相同。顺便说一下优先级怎么判断， 一般是 !important > 行内样式> ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性。还有一个简单的计算方法，内联样式表的权值为 1000，ID 选择器的权值为 100，Class 类选择器的权值为 10，HTML 标签选择器的权值为 1，权值实际并不是按十进制计算的，用数字表示只是说明思想，我们可以把选择器中规则对应做加法，比较权值大小，权值越大优先级越高，如果权值相同前面的样式会被后面的覆盖。 21.脱离文档流的有哪些 - 浮动 - 绝对定位 - 固定定位 > 元素脱离文档流会导致父元素高度塌陷，要修复高度塌陷问题，可以将子元素与父元素放在同一个BFC中 22.为何要清除浮动？如何清除？ 原因： > 元素设置了float属性后，就会脱离文档流，当 包含框 的高度小于 浮动框 的时候，会出现高度塌陷。因此才需要清除浮动！ 清除浮动方法： 1：给 包含框 添加 after伪元素清除浮动。代码： ``` .clearfix:after{ display: block; content:''; clear: both; height:0; } ``` 2：使用BFC， 原理：让浮动块包含在同一个BFC中。 给 包含框 加一个overflow：hidden就可以了；代码： ``` .container{ overflow: hidden; } .container div{ float: left; } ``` 3: 在 浮动元素 的最后面添加一个新元素，应用clear:both. ``` .clearfix{ clear:both; } ``` 这种方法不太好，使margin实效了，并且增加了一个无用的element 23.css哪些属性可以继承 字体相关：line-height, font-family, font-size, font-style, font-variant, font-weight, font 文本相关： letter-spacing, text-align, text-indent, text-transform, word-spacing 列表相关：list-style-image, list-style-position, list-style-type, list-style 颜色：color 24.三栏布局（圣杯和双飞翼）和两栏布局 一、两栏布局 左边固定长度，右边自适应 1. 浮动布局 + BFC 左 右 .left{ float:left; border:2px solid red; width:100px; } .right{ border:2px solid black; display:flow-root } 2. 浮动布局 / 绝对定位 + 外边距 左 右 .left{ float:left;/* position:absolute; */ border:2px solid red; width:100px; } .right{ border:2px solid black; margin-left:100px; } 3. 使用Flexbox .contain{ display:flex; flex-direction:row; } .left{ border:2px solid red; width:100px; } .right{ border:2px solid black; flex:1; } 二、三栏布局 两边固定长度，中间自适应 1. 浮动布局 + BFC 左 右 中 .left{ border:2px solid red; width:100px; float:left; } .center{ border:2px solid black; display:flow-root; } .right{ border:2px solid red; width:100px; float:right; } 2. 浮动布局 / 绝对定位 + 外边距 左 右 中 .left{ border:2px solid red; width:100px; float:left; } .center{ border:2px solid black; margin:0 100px } .right{ border:2px solid red; width:100px; float:right; } 3. 使用Flexbox 左 中 右 .contain{ display:flex; } .left{ border:2px solid red; width:100px; } .center{ border:2px solid black; flex:1 } .right{ border:2px solid red; width:100px; } 圣杯布局 .container { padding: 0 100px 0 200px; } .left { width: 200px; background: red; /* 关键点：-100%表示向左移动他的父元素content的宽度，这一行不能容纳，于是就**移动到了上一行**，刚好middle的左边界与left的左边界重合*/ margin-left: -100%; left: -200px; } .right { width: 100px; background: blue; margin-left: -100px; right: -100px; } .main { background: yellow; width: 100%; } .left, .main, .right{ float: left; min-height: 200px; position: relative; } main left right 双飞翼布局 中间的 div 外层用另一个 div 包裹了一下，然后被包裹用 margin 来把自己挤到中间 实现三栏水平布局之双飞翼布局 .left, .main, .right { float: left; min-height: 130px; text-align: center; } .left { margin-left: -100%; background: green; width: 200px; } .right { margin-left: -300px; background-color: red; width: 300px; } .main { background-color: blue; width: 100%; } .content{ /* 关键点：用margin把div挤到中间正常展示*/ margin: 0 300px 0 200px; } 　 　　 main 　　left 　　right 二者异同 圣杯布局与双飞翼布局实现的效果是一样的，即： 两边宽度不变，中间的部分会随浏览器窗口大小而改变。 相同点 middle中的三个div都用了浮动。 都利用负的margin-left把三个div放在一行。 middle的宽度设置为100%。 （处理遮挡文字以上的部分都相同） 不同点 圣杯布局为middle添加padding，将middle往中间缩，然后用position来处理两边的位置。 双飞翼布局是在middle里又加了一个inner，然后为inner添加padding。 25.:link、:hover、:active和:visited的区别？ （小技巧：有一天我走在路上，捡到一个lv的包，我就很开心，笑haha。l在头，v在尾，ha依次在中间） :link、:hover、:active和:visited的区别？ :link表示鼠标点击之前，也称为原始状态 :hover表示鼠标悬停状态 :active表示鼠标点击状态 :visited表示鼠标点击之后状态 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-28 10:57:21 "},"CssAndHtml/Interview/图片.html":{"url":"CssAndHtml/Interview/图片.html","title":"图片 ✘","keywords":"","body":"面试知识点 - 图片 在我们日常工作中，我们会经常使用 JPG、PNG、GIF、SVG 等格式图片。 但是，你真的懂图片吗？不同格式图片的区分，它们的优劣势以及使用场景等…… 下面，将根据搜集的资料，进行关于图片的科普。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 BMP  3.2 JPEG  3.3 PNG  3.4 GIF  3.5 SVG  3.6 Base64  3.7 WebP  3.8 雪碧图 四 总结 五 参考文献 二 前言 返回目录 你熟悉图片吗？能讲讲 JPG、PNG、GIF 的适用场景吗？然后 PNG 为什么会有 PNG-8 和 PNG-24？知道 SVG 吗？能讲讲它们与 JPG、PNG、GIF 的差别吗？…… 三 正文 返回目录 首先，我们要清楚的是，图片从类型上分，可以分为 位图 和 矢量图。 位图：位图又叫点阵图或像素图，计算机屏幕上的图是由屏幕上的发光点（即像素）构成的，每个点用二进制数据来描述其颜色与亮度等信息。因为这些点是离散的，类似于点阵，同时因为多个像素的色彩组合就形成了图片，所以叫这种图为点阵图或者位图。常见位图有 JPG、PNG、GIF 等格式。 矢量图：矢量图又叫向量图，它是由一系列计算机指令来描述和记录一幅图，一幅图可以解为点、线、面等组成的子图。生成的矢量图文件存储量很小，特别适用于文字设计、图案设计等，而在前端中比较常用的矢量图有 SVG 等格式…… 然后，我们按压缩划分，可以将图片分为 无损压缩 和 有损压缩。 无损压缩：无损压缩是对文件本身的压缩，使图片占用的存储空间变小，并且不会损害图片的质量。常见无损压缩有 PNG 等。 有损压缩：有损压缩是对图像本身的改变，会对图片质量造成损害，随着压缩次数越来越多，那么图片质量会越来越差。常见有损压缩有 JPG 等。 最后，究根结底，我们需要知道在计算机中，像素是用二进制来表示的。不同图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，那么它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。 一个二进制位表示两种颜色 【 0|1 黑|白 】，如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 中颜色。例如： PNG-8：它有 2^8 种颜色，即 256 种颜色。 PNG-24：它有 2^24 种颜色，即 1677216 种颜色（1600 万种颜色）。 OK，知道了这些基础知识，我们就按图片出现的顺序，一一讲解下常用的图片知识吧！ 3.1 BMP 返回目录 早期使用的图片格式，叫 BMP，取自英文单词 BitMap，Windows 中文版译作 位图，它的文件结构很简单，没有压缩，一个一个像素地记录下来。 如果你的系统是 Windows，你可以打开 画图 工具，然后点击另存为，你可以看到保存的选项中有个 24位位图 的格式，即 1600 万色的图片。 当然，历史总在前进，BMP 这种没有压缩的图片格式，逐渐被后起之秀代替了。 不知道为什么，查不到 JPG、PNG、GIF 的出现顺序，下面只好按我个人记忆方式来编文章段落。 3.2 JPEG 返回目录 关键字：有损压缩、体积小、加载快、不支持透明 简要介绍： JPEG/JPG 格式，是应用最广泛的图片格式之一，特点如下： JPEG/JPG 采用特殊的有损压缩算法，将不易被人眼察觉的图像颜色删除，从而达到较大的压缩比，因此它的压缩文件尺寸较小，下载速度快，成为互联网最广泛使用的格式。 JPEG/JPG 因为属于有损压缩，所以当压缩级别逐渐增大的时候，图片质量会逐渐损耗，所以压缩要适当。 在合适的场景下，即便我们将图片体积压缩至原有体积的 50% 以下，JPG 仍能保持住 60% 的品质，且因为 JPG 格式以 24 位图存储单个图，可以呈现多达 1600 万种颜色，足以满足大多数场景， 适用场景： 大的背景图 轮播图 Banner 图 3.3 PNG 返回目录 关键字：无损压缩、质量高、体积大、支持透明 简要介绍： PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式，它的压缩比高于 GIF，支持图像透明，可以利用 Alpha 通道调节图像透的明度。 PNG 分 PNG-8 和 PNG-24。 PNG-8：PNG-8 是无损压缩的索引色彩模式。PNG-8 是 GIF 格式很好的替代，虽然不能像 GIF 一样有动画，也不兼容 IE6 等老旧浏览器。PNG-8 最多支持 256 中颜色。 PNG-24：PNG-24 是无损压缩的直接色彩模式。PNG-24 会比 JPEG、GIF、PNG-8 占用更大的存储空间。PNG-24 可以呈现 1600 万种颜色。 2^8 = 256，2^24 = 1677216 适用场景： 普遍场景 小的 Logo，颜色简单且对比强烈的图片或者背景。 颜色简单、对比度强的透明小图。 什么时候使用 PNG-8，什么时候使用 PNG-24 呢？ 理论上，位数最大的就是最好的，直接上 PNG-24；但是实际上，为了避免体积过大的问题，一般在适合使用 PNG 的场景中，优先选择比较小巧的 PNG-8。 如何确定是使用 PNG-8 还是 PNG-24，这就看你的 UI 设计师或者负责人能接受那个了，除非你设计功底非常好，要不然不要做这个选择！ 3.4 GIF 返回目录 关键字：支持动画 简要介绍： GIF 格式，不仅仅支持静止图片，也可以支持动画，并且支持透明背景图像，适用于多种操作系统，体积很小，网上小动画很多是 GIF 格式。但是色域不太广，只支持 256 种颜色，这意味着颜色种类少。 GIF 格式的压缩率一般在 50% 左右。 适用场景： 动图 3.5 SVG 返回目录 关键字：文本文件、体积小、不失真、兼容性好 简要介绍： SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式，是可缩放的矢量图形。与 JPG、PNG、GIF 等位图不同，SVG 可以直接用代码来描绘图像，并通过任意文字处理工具打开 SVG 图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到 HTML 中通过浏览器来观看。 SVG 格式的图片可以任意放大图形显示，并且不会损失图片质量；SVG 格式可编辑和可搜寻；SVG 格式平均来讲，比 JPG 和 GIF 格式文件要小，并且下载也比较快。 SVG 文件通常是极小的，但是当图形的复杂度变高的时候，SVG 文件大小会随之上升，因为 SVG 在渲染的时候需要比像素图更多的计算能力，这也意味着性能的损耗。所以在 Logo 等图上，应尽可能简洁。 适用场景： SVG loading 效果图：SVG-Loaders 转换工具：在线 JPG、PNG 转 SVG 工具 矢量图标库：阿里巴巴矢量图标 3.6 Base64 返回目录 关键字：文本文件、依赖编码、小图标解决方案 简要介绍： Base64 并非一种图片格式，而是一种编码方式，它类似于雪碧图，是作为小图标解决方案而存在的。和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。Base64 是作为雪碧图的补充而存在的。 Base64 是一种用于传输 8 Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。 适用场景： 图片的实际尺寸很小。尽可能在图片不超过 2KB 的情况下（可查看掘金的 Base64 图）。 图片无法以雪碧图的形式与其他小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）。 图片的更新频率非常低（不需要我们重复编码和修改文件内容，维护成本较低） 为什么大图不使用 Base64？因为 Base64 编码后，图片大小会膨胀为源文件的 4/3，如果将大图编码到 HTML 或者 CSS 中，这样后者的体积增加，即便减少了 HTTP 请求，也无法弥补庞大的体积带来的性能开销。 如何获取： Webpack 的 loader：url-loader 在线编码工具：图片转换Base64 3.7 WebP 返回目录 关键字：年轻的全能型选手 简要介绍： 2010 年由 Google 提出，转为 Web 开发的一种旨在加快图片加载速度的图片格式，支持有损压缩和无损压缩。 WebP 像 JPEG 一样对图片细节丰富，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片。 官方介绍：与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。 适用场景： 由于 WebP 支持情况仅 Chrome、UC 等几家浏览器支持，所以局限性较大，目前暂不考虑使用。 参考自 Can I Use 网站中的浏览器支持程度：webp 3.8 雪碧图 返回目录 雪碧图，CSS Sprites，听起来就很清爽的一种图片，刚开始的时候 以为是大街小巷上卖的 3 块钱瓶装雪碧饮料上的图片，后来知道压根不是同一码事。 雪碧图不属于图片格式，而是一种图片应用形式。但是因为它在前端赫赫有名，经常使用，故此将其记载下来。 雪碧图又叫精灵图，因为 Sprites 的原因叫 “雪碧”，出现的原因是随着网速的提升，同时因为请求次数过多的时候会卡网页，所以我们就将 N 张小图集成到一张大图上，从而提升页面打开的速度。这种多张小图放在一张大图上的操作，就叫做精灵图（雪碧图 - CSS Sprites） 那么，平时如何使用雪碧图呢？ .img{background:url(../images/img.png) no-repeat;} .my-head{height:160px;width:120px;background-position:0 0;} .my-picture{height:292px;width:1253px;background-position:0 -160px;} @mixin img{background:url(../images/img.png) no-repeat; } @mixin my-head{height:160px;width:120px;background-position: 0 0;} @mixin my-picture{height:292px;width:1253px;background-position: 0 -160px;} 如上面代码所示，现在网上有非常多的雪碧图制作工具，我们只需要将小图发到工具上去，就可以生成大图，同时获得它的 css/sass 代码，而不需要自己一个一个定位。 这是 Windows 版本的工具，网上有很多雪碧图/精灵图制作工具，这里就不推荐本人使用的了。 MDN 定义：图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。 四 总结 返回目录 至此，我们对图片的介绍就结束了，在这里我们列个表进行汇总： 格式 使用场景 JPG/JPEG 1. 大的背景图； 2. 轮播图； 3. Banner 图 PNG 1. 小 Logo； 2. 透明背景 GIF 动态图片 SVG 能适应不同设备且画质不能损坏的图片 Base64 大小不超过 2KB，且更新率低的图片 雪碧图 小图太多的时候，集中成一张图片减少 HTTP 请求 雪碧图不属于格式，但属于一种应用形式 最后，在开发中会常用到一些资料，下面是 在图片方面的个人资源，如果小伙伴有其他的好用资源推荐，可以 QQ 或者评论留言： 常用优秀资源： SVG loading 效果：SVG-Loaders 矢量图标库：Iconfont-阿里巴巴矢量图标库 在线制作 Logo：U 钙网 压缩 PNG 或者 JPG：TinyPNG 获取图片素材： 千库网：地址 包图网：地址 在线转换工具： JPG、PNG 转 SVG JPG、PNG、GIF 转 Base64 JPG、PNG、GIF 转 ICO 其他资料支持： Can I Use —— 查看各种浏览器支持程度：caniuse.com 五 参考文献 返回目录 《jpg、png、svg、gif等图片格式的区别》 《PNG、JPEG、GIF、SVG应该用哪个？》 《图片优化——质量与性能的博弈》 《横向对比 gif、jpeg、png、svg，教你如何合理选择图像格式》 《JPG？GIF？PNG？前端如何选择图片格式？》 《矢量图与位图的区别》 《无损压缩和有损压缩是数码图像文件压缩的两种类型。》 不折腾的前端，和咸鱼有什么区别！ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-24 14:38:30 "},"CssAndHtml/Css/flex.html":{"url":"CssAndHtml/Css/flex.html","title":"flex ✔","keywords":"","body":"一、基本概念 Flex 容器: 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。 Flex 项目: 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。 在 Flexbox 模型中，有三个核心概念： – flex 项（注：也称 flex 子元素），需要布局的元素 – flex 容器，其包含 flex 项 – 排列方向（direction），这决定了 flex 项的布局方向 二、容器属性 2.1 flex-direction: row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿2.2 flex-wrap: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 2.3 justify-content: flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.4 align-items: flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.5 align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 结合 justify-content和align-items，看看在 flex-direction 两个不同属性值的作用下，轴心有什么不同： 三、项目属性 3.1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 80px; text-align: center; margin-left: 20px; } p:nth-child(1){ order: 4; } p:nth-child(2){ order: 3; } p:nth-child(4){ order: -1; /** 设置为-1 **/ } 1 2 3 4 3.2 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 80px; text-align: center; margin-left: 20px; } p:nth-child(1){ flex-grow: 2; } p:nth-child(2){ flex-grow: 1; } p:nth-child(3){ flex-grow: 1; margin-right: 20px; } 1 2 3 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.3 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 150px; text-align: center; margin-left: 20px; } p:nth-child(1){ } p:nth-child(2){ flex-shrink: 0; /**设置为0**/ } p:nth-child(3){ margin-right: 20px; } 1 2 3 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 3.4 Flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 150px; text-align: center; margin-left: 20px; } p:nth-child(2){ flex-basis: 30px; } 1 2 3 它可以设为跟width或height属性一样的值（比如30px），则项目将占据固定空间。 3.5flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 p { flex: none | [ ? || ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 3.6 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 150px; text-align: center; margin-left: 20px; } p:nth-child(2){ align-self: flex-end; } 1 2 3 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 flex-start | flex-end | center | baseline | stretch; Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-30 00:27:37 "},"HttpAndBrowerAndPerformanceSafety/":{"url":"HttpAndBrowerAndPerformanceSafety/","title":"Http和浏览器以及安全","keywords":"","body":"http和浏览器以及性能相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-16 21:48:08 "},"HttpAndBrowerAndPerformanceSafety/Interview/":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/","title":"面试必问 ✘","keywords":"","body":"常见面试题 网络方面的知识 常见面试题 Http、Socket、WebSocket之间联系与区别？ Http、Socket、WebSocket之间联系与区别？ 为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 CDN 作用：依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 基本原理是：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 跨域，同源策略，TCP/UDP，HTTP2.0，HTTPS，DNS，CDN，安全。HTTPS 建立连接的过程，XSS,CSRF，http缓存，请求，http报文 Http请求中的keep-alive有了解吗。 答案： 在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。 但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-01 21:10:03 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/","title":"Http和浏览器相关 ✘","keywords":"","body":"http和浏览器相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-11 13:51:51 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/用户输入URL到浏览器呈现页面.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/用户输入URL到浏览器呈现页面.html","title":"用户输入URL到浏览器呈现页面 ✘","keywords":"","body":"面试知识点 - 用户输入URL到浏览器呈现页面 大纲 从浏览器接收url到开启网络请求线程 多进程的浏览器 多线程的浏览器内核 解析URL 网络请求都是单独的线程 更多 开启网络线程到发出一个完整的http请求 DNS查询得到IP tcp/ip请求 五层因特网协议栈 从服务器接收到请求到对应后台接收到请求 -负载均衡 -后台的处理 后台和前台的http交互 http报文结构 cookie以及优化 gzip压缩 长连接与短连接 http 2.0 https 单独拎出来的缓存问题，http的缓存 = 强缓存与弱缓存 = 缓存头部简述 = 头部的区别 解析页面流程 流程简述 HTML解析，构建DOM 生成CSS规则 构建渲染树 渲染 简单层与复合层 Chrome中的调试 资源外链的下载 loaded和domcontentloaded CSS的可视化格式模型 包含块（Containing Block） 控制框（Controlling Box） BFC（Block Formatting Context） IFC（Inline Formatting Context） 其它 JS引擎解析过程 JS的解释阶段 JS的预处理阶段 JS的执行阶段 回收机制 其它 总结 从浏览器接收url到开启网络请求线程 这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制 具体请看浏览器多进程到JS单线程，JS运行机制 多进程的浏览器 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程） 进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等 Browser进程：浏览器的主进程（负责协调、主控），只有一个 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制 浏览器渲染进程（内核进程）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程 多线程的浏览器内核 每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程 GUI线程 JS引擎线程 事件触发线程 定时器线程 网络请求线程 这里JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的 解析URL 输入URL后，会进行解析（URL的本质就是统一资源定位符） URL一般包括几大部分： protocol，协议头，譬如有http，ftp等 host，主机域名或IP地址 port，端口号 path，目录路径 query，即查询参数 fragment，即#后的hash值，一般用来定位到某个位置 网络请求都是单独的线程 每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载 因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复） 更多 开启网络线程到发出一个完整的http请求 这一部分主要内容包括：dns查询，tcp/ip请求构建，五层因特网协议栈等等 仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多） DNS查询得到IP 如果输入的是域名，需要进行dns解析成IP，大致流程： 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP 注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话） 而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化 tcp/ip请求 http的本质就是tcp/ip请求 需要了解3次握手规则建立连接以及断开连接时的四次挥手 tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输 三次握手 三次握手，其实就是要双方相互确认彼此能够通信。 一般要与对方确认可以通信，就要确认自己能够跟对方通信(1)，且能够收到对方的通信(2)，反过来对方也能够和自己通信(3)，且能收到自己的通信(4)。基于这一点，流程就简化为3次握手通信。 首先，client发送一个SYN=1，seq=X（X随机）到server，server收到这个消息，则确认了client能够与server通信这件事(1),这时，server将SYN=1，ACK=1，ack=X+1,seq=Y（Y随机）发送给client；client收到这个消息，则确认了client能够收到对方的通信(2)和server能够与client通信这件事(3)，最后client发送ack=Y+1,ACK=1返回给server，server收到后，确认了server能够收到client的通信这件事(4)。至此，双方的通信确认过程完成且建立了连接。（总结上面的发送信息，简单的说就是：SYN:表示一个想要连接对方的请求；ACK、ack表示一个答复对方连接请求的响应;中间随机数seq：请求连接的信物） 这里的三次握手重点每一次都有关联，seq随机一个数发送给对方，对方收到后用ack=seq+1的方式表示针对上一个通信的准确回复。如果不用序列号的话，client在最后一步的发送中可以发送任意数据给server，确认最后的连接过程且最终建立连接。由于client可以随意伪造任意多的ip，那么最终server建立了很多不存在且无用的TCP连接。 但是这个机制同样存在一个问题，就是SYN攻击。client伪造大量随机ip，向server发送SYN=1，seq=X的第一步的连接请求，server给不存在的ip发送SYN=1，ACK=1，ack=X+1,seq=Y响应，由于client的ip不是实际存在的，所以server发出的消息不能到达，server不断的重试直到超时，那么server的连接队列会被占满，正常的TCP握手请求就无法到达server，影响了正常的连接请求，导致网络阻塞或者server系统瘫痪。 这种SYN攻击通过命令netstat -nap | grep SYN_RECV可以查出来. 三次握手的步骤： 客户端：首先发送一个带 SYN 标志的数据包给对方 服务端：收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息 客户端：回传一个带 ACK 标志的数据包 建立连接成功后，接下来就正式传输数据 然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手） 三次握手的作用： 通过三次握手，就能明确双方的收发功能均正常，也就是说，保证了建立的连接是可靠的。而且，由上可见，三次是确保连接可靠的最少次数，再就多余。 四次挥手的步骤：（抽象派） 只要弄懂了三次握手，四次挥手很简单辣，因为四次就是将三次握手的第2步拆分了而已。为什么会拆分呢？是因为连接时必须同时进行连接，但是断开时，不一定同时断开，可能一方断开，另一方继续传输数据。 四次挥手(简化版)为： 客户端发送断开请求，即FIN seq=x。 服务端接收客户端的断开请求，返回客户端请求的同意断开(ask=x+1)。 服务端发送断开请求，即FIN seq=y。 客户端接收服务端的断开请求，返回服务端请求的同意断开(ask=y+1)。 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 tcp/ip的并发限制 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等） 而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求 所以针对这个瓶颈，又出现了很多的资源优化方案 get和post的区别 get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。 get会产生一个tcp数据包，post两个 具体就是： get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据）， post请求时，浏览器先发送headers，服务器响应100 continue， 浏览器再发送data，服务器响应200（返回数据）。 再说一点，这里的区别是specification（规范）层面，而不是implementation（对规范的实现） 更多 五层因特网协议栈 其实就是一个概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。 简括就是： 从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。 当然，服务端的接收就是反过来的步骤 五层因特网协议栈其实就是： 1.应用层(dns,http) DNS解析成IP并发送http请求 2.传输层(tcp,udp) 建立tcp连接（三次握手） 3.网络层(IP,ARP) IP寻址 4.数据链路层(PPP) 封装成帧 5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质） 当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。 OSI七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程 除了层的数量之外，开放式系统互联（OSI）模型与TCP/IP协议有什么区别？ 开放式系统互联模型是一个参考标准，解释协议相互之间应该如何相互作用。TCP/IP协议是美国国防部发明的，是让互联网成为了目前这个样子的标准之一。开放式系统互联模型中没有清楚地描绘TCP/IP协议，但是在解释TCP/IP协议时很容易想到开放式系统互联模型。两者的主要区别如下： TCP/IP协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能 更多 从服务器接收到请求到对应后台接收到请求 服务端在接收到请求时，内部会进行很多的处理 这里由于不是专业的后端分析，所以只是简单的介绍下，不深入 负载均衡 对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡 当然了，负载均衡不止这一种实现方式，这里不深入… 简单的说： 用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户 后台的处理 一般后台都是部署到容器中的，所以一般为： 先是容器接受到请求（如tomcat容器） 然后对应容器中的后台程序接收到请求（如java程序） 然后就是后台会有自己的统一处理，处理完后响应响应结果 概括下： 一般有的后端是有统一的验证的，如安全拦截，跨域验证 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等） 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等） 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装） 然后就是将这个包从后端发送到前端，完成交互 后台和前台的http交互 前后端交互时，http报文作为信息的载体 所以http是一块很重要的内容，这一部分重点介绍它 http报文结构 报文一般包括了：通用头部，请求/响应头部，请求/响应体 通用头部 这也是开发人员见过的最多的信息，包括如下： Request Url: 请求的web服务器地址 Request Method: 请求方式 （Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE） Status Code: 请求的返回状态码，如200代表成功 Remote Address: 请求的远程服务器地址（会转为IP） 譬如，在跨域拒绝时，可能是method为options，状态码为404/405等（当然，实际上可能的组合有很多） 其中，Method的话一般分为两批次： HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP 1.0定义参考：https://tools.ietf.org/html/rfc1945 HTTP 1.1定义参考：https://tools.ietf.org/html/rfc2616 这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）： 200——表明该请求被成功地完成，所请求的资源发送回客户端 301——永久性重定向。该状态码表示请求的资源已被分配了新的 URI 302——临时性重定向。已移动的资源对应的URI 将来还有可能发生改变。 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 400——客户端请求有错（譬如可以是安全模块拦截） 401——请求未经授权 403——禁止访问（譬如可以是未登录时禁止） 404——资源未找到 500——服务器内部错误 502——错误网关 503——服务不可用 ... 再列举下大致不同范围状态的意义 1xx——指示信息，表示请求已接收，继续处理 2xx——成功，表示请求已被成功接收、理解、接受 3xx——重定向，要完成请求必须进行更进一步的操作 4xx——客户端错误，请求有语法错误或请求无法实现 5xx——服务器端错误，服务器未能实现合法的请求 请求/响应头部 请求和响应头部也是分析时常用到的 常用的请求头部（部分）： Accept: 接收类型，表示浏览器支持的MIME类型 （对标服务端返回的Content-Type） Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收 Content-Type：客户端发送出去实体内容的类型 application/x-www-form-urlencoded, multipart/form-data, application/json, application/xml 这四个是ajax的请求，表单提交或上传文件的常用的资源类型。 Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中 Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间 Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中 If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中 Cookie: 有cookie并且同域访问时会自动带上 Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive Host：请求的服务器URL Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私 Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段) User-Agent：用户客户端的一些必要信息，如UA头部等 常用的响应头部（部分）： Access-Control-Allow-Headers: 服务器端允许的请求Headers Access-Control-Allow-Methods: 服务器端允许的请求方法 Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*） Content-Type：服务端返回的实体内容的类型 text/html, text/plain, text/css, text/javascript, image/jpeg, image/png, image/gif Date：数据从服务器发送的时间 Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档 Last-Modified：请求资源的最后修改时间 Expires：应该在什么时候认为文档已经过期,从而不再缓存它 Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效 ETag：请求变量的实体标签的当前值 Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端 Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38） Server：服务器的一些相关信息 一般来说，请求头部和响应头部是匹配分析的。 譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错 譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误 譬如，在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应 还有很多的分析方法，这里不一一赘述 请求/响应实体 http请求时，除了头部，还有消息实体，一般来说 请求实体中会将一些需要的参数都放入进入（用于post请求）。 譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等 而一般响应实体中，就是放服务端需要传给客户端的内容 一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。 CRLF CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在 请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔 一般来说（分隔符类别）： CRLF->Windows-style LF->Unix Style CR->Mac Style cookie以及优化 cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。 场景如下（简述）： 在登陆页面，用户登陆了 此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等） 然后会有一个sessionid（相当于是服务端的这个session对应的key） 然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx 然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。 上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素） 一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在*cookie中设置httponly（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全） 另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。 譬如以下场景： 客户端在域名A下有cookie（这个可以是登陆时由服务端写入的） 然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源） 此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie 也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证 此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了） 当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是： 将静态资源分组，分别放到不同的域名下（如static.base.com） 而page.base.com（页面所在域名）下请求时，是不会带上static.base.com域名的cookie的，所以就避免了浪费 说到了多域名拆分，这里再提一个问题，那就是： 在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc） 此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用） 关于cookie的交互，可以看下图总结 长连接与短连接 首先看tcp/ip层面的定义： 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包） 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接 然后在http层面： http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接 http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接 注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效 http 2.0 http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的） 然后简述下http2.0与http1.1的显著不同点： http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来 http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。 所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等） 然后简述下http2.0的一些特性： 多路复用（即一个tcp/ip连接可以请求多个资源） 首部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） https https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析 一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了） HTTPS的七次握手（TCP三次+TLS四次） TLS的握手阶段是发生在TCP握手之后 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息） 对称加密和非对称加密 对称加密 即加密的密钥和解密的密钥相同, 非对称加密 非对称加密将密钥分为公钥和私钥,公钥可以公开,私钥需要保密,客户端公钥加密的数据,服务端可以通过私钥来解密 浏览器收到服务端的证书后 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密Premaster secret，发送给服务器。 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-session key 使用约定好的HASH算法计算握手消息，并使用生成的session key对消息进行加密，最后将之前生成的所有信息发送给服务端。 服务端收到浏览器的回复 利用已知的加解密方式与自己的私钥进行解密，获取Premaster secret 和浏览器相同规则生成session key 使用session key解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致 使用session key加密一段握手消息，发送给浏览器 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束， 之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密 单独拎出来的缓存问题（浏览器缓存和CDN缓存） http的缓存 前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的 缓存判断顺序 先判断Cache-Control，在Cache-Control的max-age之内，直接返回200 from cache； 没有Cache-Control再判断Expires，再Expires之内，直接返回200 from cache； Cache-Control=no-cache或者不符合Expires，浏览器向服务器发送请求； 服务器同时判断ETag和Last-Modified，都一致，返回304，有任何一个不一致，返回200。强缓存与弱缓存 缓存可以简单的划分成两种类型：强缓存200 ok ( from cache )与协商缓存（304） 区别简述如下： 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存 对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效 但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧） 缓存头部简述 上述提到了强缓存和协商缓存，那它们是怎么区分的呢？ 答案是通过不同的http头部控制 先看下这几个头部： If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires 这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。 属于强缓存控制的： （http1.1）Cache-Control/Max-Age （http1.0）Pragma/Expires 注意：Max-Age不是一个头部，它是Cache-Control头部的值 属于协商缓存控制的： （http1.1）If-None-Match/E-tag （http1.0）If-Modified-Since/Last-Modified 可以看到，上述有提到http1.1和http1.0，这些不同的头部是属于不同http时期的 HTML页面中可以用一个meta标签可以控制缓存方案 经测试跨浏览器禁止缓存的 headers,其他文件就需要使用服务器设置文件控制 header 如下： Cache-Control: no-cache, no-store, must-revalidate Pragma: no-cache Expires: 0 因为是 HTML 页面，可以于 HEAD 标签内直接添加 META 标签： 头部的区别 首先明确，http的发展是从http1.0到http1.1 而在http1.1中，出了一些新内容，弥补了http1.0的不足。 http1.0中的缓存控制： Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用） Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41 If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内 http1.1中的缓存控制： Cache-Control：缓存控制头部，有no-cache、max-age等多种取值 Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算 If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。 Max-Age相比Expires？ Expires使用的是服务器端的时间 但是有时候会有这样一种情况-客户端时间和服务端不同步 那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期 所以一般http1.1后不推荐使用Expires 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题 因此推荐使用Max-Age。 注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。 E-tag相比Last-Modified？ Last-Modified： 表明服务端的文件最后何时改变的 它有一个缺陷就是只能精确到1s， 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效 而E-tag： 是一种指纹机制，代表文件相关指纹 只有文件变才会变，也只要文件变就会变， 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了 如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag Etag主要在断点下载时比较有用 各大缓存头部的整体关系如下图 CDN 利用负载均衡等技术让用户访问就近的缓存服务器 解析页面流程 前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染 这部分很多都参考了网上资源，特别是图片，参考了来源中的文章 流程简述 浏览器内核拿到内容后，渲染步骤大致可以分为以下几步： 解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 如下图： HTML解析，构建DOM 整个渲染步骤中，HTML解析是第一步。 简单的理解，这一步的流程是这样的：浏览器解析HTML，构建DOM树。 但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。 解析HTML到构建出DOM当然过程可以简述如下： Bytes → characters → tokens → nodes → DOM 譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式） Critical Path Hello web performance students! 浏览器的处理如下： 列举其中的一些重点过程： Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符 Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集 Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则 DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象 最后的DOM树如下： 生成CSS规则 同理，CSS规则树的生成也是类似。简述为： Bytes → characters → tokens → nodes → CSSOM 譬如style.css内容如下： body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } 那么最终的CSSOM树就是： 构建渲染树 当DOM树和CSSOM都有了后，就要开始构建渲染树了 一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应 因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等 整体来说可以看图： 渲染 有了render树，接下来就是开始渲染，基本流程如下 图中重要的四个步骤就是： 计算CSS样式 构建渲染树 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性 绘制，将图像绘制出来 然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint） 这里Layout和Repaint的概念是有区别的： Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树 Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了 回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。 什么会引起回流？ 1.页面渲染初始化 2.DOM结构改变，比如删除了某个节点 3.render树变化，比如减少了padding 4.窗口resize 5.最复杂的一种：获取某些属性，引发回流， 很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流， 但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括 (1) offset(Top/Left/Width/Height) (2) scroll(Top/Left/Width/Height) (3) cilent(Top/Left/Width/Height) (4) width,height (5) 调用了getComputedStyle()或者IE的currentStyle 回流一定伴随着重绘，重绘却可以单独出现 所以一般会有一些优化方案，如： 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document 避免多次读取offset等属性。无法避免则将它们缓存到变量 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高 注意：改变字体大小会引发回流 再来看一个示例： var s = document.body.style; s.padding = \"2px\"; // 回流+重绘 s.border = \"1px solid red\"; // 再一次 回流+重绘 s.color = \"blue\"; // 再一次重绘 s.backgroundColor = \"#ccc\"; // 再一次 重绘 s.fontSize = \"14px\"; // 再一次 回流+重绘 // 添加node，再一次 回流+重绘 document.body.appendChild(document.createTextNode('abc!')); 简单层与复合层 上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。 这里不展开，进简单介绍下： 可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的 如果开启了硬件加速功能，可以将某个节点变成复合图层 复合图层之间的绘制互不干扰，由GPU直接控制 而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速 更多参考： 普通图层和复合图层 Chrome中的调试 资源外链的下载 上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了 简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）： CSS样式资源 JS脚本资源 img图片类资源遇到外链时的处理 当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接） 遇到CSS样式资源 CSS资源的处理有几个特点： CSS下载时异步，不会阻塞浏览器构建DOM树 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建） 有例外，media query声明的CSS是不会阻塞渲染的 遇到JS脚本资源 JS脚本资源的处理有几个特点： 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已 defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行 注意，defer和async是有区别的： defer是延迟执行，而async是异步执行。 简单的说（不展开）： async是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前或后 defer是延迟执行，在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在DOMContentLoaded事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面） 遇到img图片类资源 遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方 loaded和domcontentloaded 简单的对比： DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成) load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了 CSS的可视化格式模型 这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源 前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： CSS的可视化格式模型 先了解： CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示） 然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局 换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等 说到底： CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树 另外，CSS有三种定位机制：普通流，浮动，绝对定位，如无特别提及，下文中都是针对普通流中的 关键字： 包含块（Containing Block） 控制框（Controlling Box） BFC（Block Formatting Context） IFC（Inline Formatting Context） 定位体系 浮动 ... 包含块（Containing Block） 一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。 元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系 譬如： 根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块 static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建 fixed的包含块是当前可视窗口 absolute的包含块由它最近的position 属性为absolute、relative或者fixed的祖先元素创建 如果其祖先元素是行内元素，则包含块取决于其祖先元素的direction特性 如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界 控制框（Controlling Box） 块级元素和块框以及行内元素和行框的相关概念 块框: 块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子box和生成的内容 块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围 关于匿名块框的生成，示例： Some text More text div生成了一个块框，包含了另一个块框p以及文本内容Some text，此时Some text文本会被强制加到一个匿名的块框里面，被div生成的块框包含（其实这个就是IFC中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同） 换句话说: 如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框） 行内框： 一个行内元素生成一个行内框 行内元素能排在一行，允许左右有其它元素 关于匿名行内框的生成，示例： Some emphasized text P元素生成一个块框，其中有几个行内框（如EM），以及文本Some ， text，此时会专门为这些文本生成匿名行内框 display属性的影响 display的几个属性也可以影响不同框的生成： block，元素生成一个块框 inline，元素产生一个或多个的行内框 inline-block，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生BFC） none，不生成框，不再格式化结构中，当然了，另一个visibility: hidden则会产生一个不可见的框 总结： 如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决） 如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列 BFC（Block Formatting Context） FC（格式上下文）？ FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如 FC像是一个大箱子，里面装有很多元素 箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染） 内部的规则可以是：如何定位，宽高计算，margin折叠等等 不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC 注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则 BFC规则： 在块格式化上下文中 每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边） 即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合） 除非这个元素也创建了一个新的BFC 总结几点BFC特点： 内部box在垂直方向，一个接一个的放置 box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠 BFC区域不会与float box重叠（可用于排版) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌） 如何触发BFC？ 根元素 float属性不为none position为absolute或fixed display为inline-block, flex, inline-flex，table，table-cell，table-caption overflow不为visible 这里提下，display: table，它本身不产生BFC，但是它会产生匿名框（包含display: table-cell的框）而这个匿名框产生BFC IFC（Inline Formatting Context） IFC即行内框产生的格式上下文 IFC规则 在行内格式化上下文中 框一个接一个地水平排列，起点是包含块的顶部。 水平方向上的 margin，border 和 padding 在框之间得到保留 框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐 行框 包含那些框的长方形区域，会形成一行，叫做行框 行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定 行框的规则： 如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割） 行框在堆叠时没有垂直方向上的分割且永不重叠 行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐） 行框的左边接触到其包含块的左边，右边接触到其包含块的右边。 结合补充下IFC规则： 浮动元素可能会处于包含块边缘和行框边缘之间 尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化 同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本） 当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性 空的行内框应该被忽略 即不包含文本，保留空白符，margin/padding/border非0的行内元素， 以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)， 并且不是以换行结束的行框， 必须被当作零高度行框对待 总结： 行内元素总是会应用IFC渲染规则 行内元素会应用IFC规则渲染，譬如text-align可以用来居中等 块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则 行内框内部，对于那些行内元素，一样应用IFC渲染规则 另外，inline-block，会在元素外层产生IFC（所以这个元素是可以通过text-align水平居中的），当然，它内部则按照BFC规则渲染 相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件） 但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解 其它 当然还有有一些其它内容： 譬如常规流，浮动，绝对定位等区别 譬如浮动元素不包含在常规流中 譬如相对定位，绝对定位，Fixed定位等区别 譬如z-index的分层显示机制等 这里不一一展开，更多请参考： http://bbs.csdn.net/topics/340204423 JS引擎解析过程 前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程） JS的解释阶段 首先得明确： JS是解释型语音，所以它无需提前编译，而是由解释器实时运行 引擎对JS的处理过程可以简述如下： 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token） 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree） 使用翻译器（translator），将代码转为字节码（bytecode） 使用字节码解释器（bytecode interpreter），将字节码转为机器码 最终计算机执行的就是机器码。 为了提高运行速度，现代浏览器一般采用即时编译（JIT-Just In Time compiler） 即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache） 这样整个程序的运行速度能得到显著提升。 而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8） 总结起来可以认为是： 核心的JIT编译器将源码编译成机器码运行 JS的预处理阶段 上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等） 预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分： 分号补全 JS执行是需要分号的，但为什么以下语句却可以正常运行呢？ console.log('a') console.log('b') 原因就是JS解释器有一个Semicolon Insertion规则，它会按照一定规则，在适当的位置补充分号 譬如列举几条自动加分号的规则： 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。 当有}时，如果缺少分号，会补分号。 程序源代码结束时，如果缺少分号，会补分号。 于是，上述的代码就变成了 console.log('a'); console.log('b'); 所以可以正常运行 当然了，这里有一个经典的例子： function b() { return { a: 'a' }; } 由于分号补全机制，所以它变成了： function b() { return; { a: 'a' }; } 所以运行后是undefined 变量提升 一般包括函数提升和变量提升 譬如： a = 1; b(); function b() { console.log('b'); } var a; 经过变量提升后，就变成： function b() { console.log('b'); } var a; a = 1; b(); 这里没有展开，其实展开也可以牵涉到很多内容的 譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等 JS的执行阶段 此阶段的内容中的图片来源：深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇） 解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念： 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文） VO（变量对象）和AO（活动对象） 作用域链 this机制等 这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性 执行上下文简单解释 JS有执行上下文） 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出） 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。 这样依次执行（最终都会回到全局执行上下文） 譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收 然后执行上下文与VO，作用域链，this的关系是： 每一个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 具体看变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链 回收机制 JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。 一般来说，垃圾处理器有自己的回收策略。 譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能） 常用的两种垃圾回收规则是： 标记清除 引用计数 Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），简单解释如下： 遍历所有可访问的对象。 回收已不可访问的对象。 譬如：（出自javascript高程） 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。 而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。 而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。 最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 关于引用计数，简单点理解： 跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug） GC的缺陷 和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作这是为了安全考虑。 而Javascript的GC在100ms甚至以上对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。 这就是引擎需要优化的点： 避免GC造成的长时间停止响应。 GC优化策略 这里介绍常用到的：分代回收（Generation GC） 目的是通过区分“临时”与“持久”对象: 多回收“临时对象”区（young generation） 少回收“持久对象”区（tenured generation） 减少每次需遍历的对象，从而减少每次GC的耗时。 像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。） 更多可以参考： V8 内存浅析 相关博文: FEX-输入 URL 到页面加载完成的过程中都发生了什么事情？ 从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ 一篇文章搞定前端面试 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-05 10:37:46 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/浏览器多进程到JS单线程，JS运行机制.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/浏览器多进程到JS单线程，JS运行机制.html","title":"浏览器多进程到JS单线程，JS运行机制 ✘","keywords":"","body":"浏览器多进程到JS单线程，JS运行机制 大纲 区分进程和线程 浏览器是多进程的 浏览器都包含哪些进程？ 浏览器多进程的优势 重点是浏览器内核（渲染进程） Browser进程和浏览器内核（Renderer进程）的通信过程 梳理浏览器内核中线程之间的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker，JS的多线程？ WebWorker与SharedWorker 简单梳理下浏览器渲染流程 load事件与DOMContentLoaded事件的先后 css加载是否会阻塞dom树渲染？ 普通图层和复合图层 区分进程和线程 通俗的话：如果把cpu看作一个工厂，那进程好比工厂的车间，代表cpu能处理的单个任务，任意时刻cpu总是运行一个进程，其他进程都要停止，线程就好比车间的工人.每个线程都共享着内存空间。 官方的话：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 根本区别： 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。浏览器是多进程的 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 浏览器都包含哪些进程？ Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有负责浏览器界面显示，与用户交互。如前进，后退等负责各个页面的管理，创建和销毁其他进程将Renderer进程得到的内存中的Bitmap，绘制到用户界面上网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 浏览器多进程的优势 相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。 重点是浏览器内核（渲染进程） 重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程 可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程 请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分） 终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）： GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 5.异步http请求线程 ** 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧： Browser进程和浏览器内核（Renderer进程）的通信过程 再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。 打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）， 然后在这前提下，看下整个的过程：(简化了很多) Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染 - 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） - 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来浏览器内核中线程之间的关系 GUI渲染线程与JS引擎线程互斥 由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 JS阻塞页面加载 从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？ 前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？ 所以，后来HTML5中支持了Web Worker。 MDN的官方解释是： Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面 一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window 因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误 这样理解下： 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect! 而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。 其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。WebWorker与SharedWorker 既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混） WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程 简单梳理下浏览器渲染流程 本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本） 为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文） 浏览器输入url，浏览器主进程接管，开一个下载线程， 然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容， 随后将内容通过RendererHost接口转交给Renderer进程 浏览器渲染流程开始 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了 既然略去了一些详细的步骤，那么就提一些可能需要注意的细节吧。 这里重绘参考来源中的一张图：（参考来源第一篇） 参考： load事件与DOMContentLoaded事件的先后 上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？ 很简单，知道它们的定义就可以了： 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了） 所以，顺序是：DOMContentLoaded -> load css加载是否会阻塞dom树渲染？ 这里说的是头部引入css的情况 首先，我们都知道：css是由单独的下载线程异步下载的。 然后再说下几个现象： css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 这可能也是浏览器的一种优化机制。 因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 普通图层和复合图层 渲染步骤中就提到了composite概念。 可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘） 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒 可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息 如何变成复合图层（硬件加速） 将该元素变成一个复合图层，就是传说中的硬件加速技术 最常用的方式：translate3d、translateZ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\\\\\\\\等元素 其它，譬如以前的flash插件 absolute和硬件加速的区别 可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。 所以，就算absolute中信息改变时不会改变普通文档流中render树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的） 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图） 复合图层的作用？ 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡 硬件加速时请使用index 使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染 具体的原理时这样的： webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 从Event Loop谈JS的运行机制 事件循环机制： 上面讲了JS引擎线程会维护一个执行栈，执行栈中的所有任务从顶向下同步执行并出栈； 但当遇到一些需要异步执行的任务，如ajax、setTimeout等时，会立即返回函数，然后将异步操作交给浏览器内核中的其他模块处理（如timer、network、DOM Binding模块），接着主线程继续往下执行 栈中的任务。 当上面说的异步操作完成后如ajax接受完响应、setTimeout到达指定延时；这些任务 即回调函数会被放入到任务队列中。一般不同的异步任务的回调函数会放入不同的任务队列之中。（分为宏任务和微任务；优先执行微任务队列） 只有当执行栈为空时，执行引擎才会去看任务队列有无可执行的任务；如果有，就取一个放入到执行栈中执行。执行完后，执行栈为空，便又去检查任务队列。 不断地循环重复上述过程的机制，就是“事件循环(event loop)机制”。 此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。 这里不谈可执行上下文，VO，scop chain等概念相关会总结 在知道JS引擎是单线程后再理解一个概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。 事件循环机制进一步补充 总结： JS引擎线程只执行执行栈中的事件 执行栈中的代码执行完毕，就会读取事件队列中的事件 事件队列中的回调事件，是由各自线程插入到事件队列中的 如此循环 单独说说定时器 上述事件循环机制的核心是：JS引擎线程和事件触发线程 但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？ 是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身） 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 譬如: setTimeout(function(){ console.log('hello!'); }, 1000); 这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行 setTimeout(function(){ console.log('hello!'); }, 0); console.log('begin'); 这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行 注意： 执行结果是：先begin后hello! 虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定) 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列） setTimeout而不是setInterval 用setTimeout模拟定期计时和直接用setInterval是有区别的。 因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关） 而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间） 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。 事件循环进阶：js 宏任务和微任务 可以看看这篇 简单概括： 宏任务（macrotask ）和微任务（microtask ） macrotask 和 microtask 表示异步任务的两种分类。 在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。 宏任务和微任务之间的关系 看个例子 setTimeout(() => { //执行后 回调一个宏事件 console.log('内层宏事件3') }, 0) console.log('外层宏事件1'); new Promise((resolve) => { console.log('外层宏事件2'); resolve() }).then(() => { console.log('微事件1'); }).then(()=>{ console.log('微事件2') }) 我们看看打印结果 外层宏事件1 外层宏事件2 微事件1 微事件2 内层宏事件3 首先浏览器执行js进入第一个宏任务进入主线程, 遇到 setTimeout 分发到宏任务Event Queue中 遇到 console.log() 直接执行 输出 外层宏事件1 遇到 Promise， new Promise 直接执行 输出 外层宏事件2 执行then 被分发到微任务Event Queue中 第一轮宏任务执行结束，开始执行微任务 打印 '微事件1' '微事件2' 第一轮微任务执行完毕，执行第二轮宏事件，打印setTimeout里面内容'内层宏事件3' 宏任务 # 浏览器 Node setTimeout √ √ setInterval √ √ setImmediate x √ requestAnimationFrame √ x 微任务 # 浏览器 Node process.nextTick x √ MutationObserver √ x Promise.then catch finally √ √ 这个例子看懂基本js执行机制就理解了 //主线程直接执行 console.log('1'); //丢到宏事件队列中 setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') }) }) //微事件1 process.nextTick(function() { console.log('6'); }) //主线程直接执行 new Promise(function(resolve) { console.log('7'); resolve(); }).then(function() { //微事件2 console.log('8') }) //丢到宏事件队列中 setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') }) }) 首先浏览器执行js进入第一个宏任务进入主线程, 直接打印console.log('1') 遇到 setTimeout 分发到宏任务Event Queue中 遇到 process.nextTick 丢到微任务Event Queue中 遇到 Promise， new Promise 直接执行 输出 console.log('7'); 执行then 被分发到微任务Event Queue中 第一轮宏任务执行结束，开始执行微任务 打印 6,8 第一轮微任务执行完毕，执行第二轮宏事件，执行setTimeout 先执行主线程宏任务，在执行微任务，打印'2,4,3,5' 在执行第二个setTimeout,同理打印 ‘9,11,10,12’ 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 以上是在浏览器环境下执行的数据，只作为宏任务和微任务的分析，我在node环境下测试打印出来的顺序为：1，7，6，8，2，4，9，11，3，10，5，12。node环境执行结果和浏览器执行结果不一致的原因是：浏览器的Event loop是在HTML5中定义的规范，而node中则由libuv库实现。libuv库流程大体分为6个阶段：timers，I/O callbacks，idle、prepare，poll，check，close callbacks，和浏览器的microtask，macrotask那一套有区别。 参考： 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 深入解析浏览器的幕后工作原理 js 宏任务和微任务 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-07 13:22:14 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/Axios.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/Axios.html","title":"Axios ✘","keywords":"","body":"Axios 饮水思源：Axios 中文文档 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 一 目录 目录 一 目录 二 正文  2.1 get  2.1 post 二 正文 返回目录 axios 实战经验 2.1 get 返回目录 方法：axios.get(url, options) 话不多说，先上代码： Vue学习 new Vue({ el: document.getElementById('app'), template: ` 发送请求 数据为： {{ getData }} `, data() { return { getData: '' } }, methods: { sendAjax() { // 直接使用 axios // get 为请求方式 axios.get('https://www.easy-mock.com/mock/5be3885e033152564881d354/getInfo') // then 为 promise 获取数据 .then((res) => { this.getData = res.data; }) // catch 为 promise 捕获异常 .catch(); } } }) 如上，我们使用 axios 非常简单，只需要引用它的 cdn，然后通过： axios.get() .then() .catch() 就可以直接调用 axios 获取数据。 2.2 post 返回目录 post 请求讲解 三 杂记 3.1 跨域代理 http-proxy-middleware | 代理了解推荐文章 步骤 1. 设置 index.js： dev: { proxyTable: { '/stat': { target: 'http://172.**.**.**:8080/', // 接口的域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 } }, }, 步骤 2. 设置 main.js 全局拦截器： // 设置 axios import axios from 'axios'; // 添加请求拦截器 axios.interceptors.request.use( (config) => { config.headers.common['timestamp'] = \"******\"; config.headers.common['deviceid'] = \"******\"; config.headers.common['signature'] = \"******\"; // 在发送请求之前做些什么 return config; }, (error) => { // 在请求错误时做些什么 return Promise.reject(error); }) 步骤 3. 调用 PartOne.vue： axios({ url: \"stat/getApersonnelDistribution\", method: \"get\", params: { rank: 4 }, }).then( (res) => { console.log(res); }) 3.2 单个页面多 API 调用 步骤 1. 全代码为： create() { this._getApi(); }, methods: { _getApi() { axios(xxx).then( res=> { console.log(res); this._drawxxx(res); }) }, _drawxxx(res) { } } 步骤 2. 理解： 首先，在 create() 中调用方法体。 然后，在 methods() 中编写方法体，方法体调用 axios。 最后，在方法体中通过 axios 获取到数据之后，将数据传入到方法中进行处理。 步骤 3. 缘故：这样分布处理，有利于代码逻辑优化，当某步出现错误的时候，方便调试。同时使用 _ 开头命名方法，防止与其他 api 冲突。 3.3 Axios 封装 步骤 1. 封装 api 到 src/api/api.js 中 api.js /** * 封装逻辑 * 1. 引入 axios。 * 2. 设置请求配置 request。如：请求超时，响应头等 * 3. 设置请求中的遮罩（未实现） * 4. 设置请求成功后的数据过滤（未实现） * 5. 设置并暴露接口，传 data、method、url 到请求配置 request 上。 */ // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 本地开发 dev 的时候，不需要开启这个 // baseURL: 'http://172.****.****.5:8080', timeout: 5000, headers: { timestamp: \"20181026094424\", deviceid: \"10102\", signature: \"F9CB03DD3ED50EDA5DB214C42D4DC0D6\", } }) /** * 获取用户名 * userId */ export const getUserName = data => request({ method: 'get', url: '/api/getUserName', params: data }) 步骤 2. 在 Pages 中调用： UserInfo.vue // 引用接口 import { getUserName } from \"@/api/api\" export default { methods: { _getUserName() { // 获取用户名 getUserName({ userId: this.userId, }).then( (res) => { console.log(\"\\n【API - 获取用户名】：\"); }) } } } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 21:40:00 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/OSI七层模型-tcpIP四层模型 - 五层模型.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/OSI七层模型-tcpIP四层模型 - 五层模型.html","title":"OSI七层模型-tcpIP四层模型 - 五层模型 ✘","keywords":"","body":"OSI七层模型-tcpIP四层模型 - 五层模型 源自http://www.colasoft.com.cn/download/protocols_map.php OSI七层模型 OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。OSI 七层模型是一种框架性的设计方法 ，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能使就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。如下图： 五层模型 5层只是OSI和TCP/IP的综合，是业界产生出来的非官方协议模型，但是很多具体的应用。实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。 tcp/IP四层模型 4层是指TCP/IP四层模型，主要包括：应用层、传输层、网络层和数据链路层。 4层协议和对应的标准7层协议的关系如下图： 数据包 从上往下，每经过一层，协议就会在包头上面做点手脚，加点东西，传送到接收端，再层层解套出来，如下示意图： 应用层 HTTP 超文本传输协议 FTP 文件传输协议 SMTP 简单邮件传输协议 TELNET TCP/IP终端仿真协议 POP3 邮局协议第三版 Finger 用户信息协议 NNTP 网络新闻传输协议 IMAP4 因特网信息访问协议第四版 LPR UNIX 远程打印协议 Rwho UNIX 远程 Who协议 Rexec UNIX远程执行协议 Login UNIX 远程登陆协议 RSH UNIX 远程Shell协议 NTF HP网络文件传输协议 RDA HP 远程数据库访问协议 VT 虚拟终端仿真协议 RFA HP 远程文件访问协议 RPC Remote Process Comm. S-HTTP 安全超文本传输协议 GDP网关发现协议 X-Window CMOT 基于TCP/IP的CMIP协议 SOCKS 安全套接字协议 FANP流属性通知协议 SLP服务定位协议 MSN微软网络服务 Radius 远程用户拨号认证服务协议 DNS 域名系统 NFS网络文件系统协议 NIS SUN 网络信息系统协议 R-STAT SUN远程状态协议 NSM SUN 网络状态监测协议 PMAP SUN 端口映射协议 Mount LPR UNIX远程打印协议 常用UDP协议的应用层服务 BOOTP引导协议 DHCP动态主机配套协议 NTP网络时间协议 TFTP简单文件传输协议 SNMP简单网络管理协议表示层 DECnet NSP LPP 轻量级表示协议 NBSSN NetBIOS会话服务协议 XDP外部数据表示协议 IPX会话层 SSL 安全套接字层协议 TLS传输层安全协议 DAP目录访问协议 LDAP轻量级目录访问协议 RPC远程过程调用协议 VINES NETRPC VFRP NeTBIOS IPX 传输层 XOT 基于tcp之上的X协议 Van Jacobson 压缩TCP协议 ISO-DE ISO 开发环境-------->NetBISO TALI 传输适配层接口协议 DSI、NetBIOS、IP NeTBIOS、ISO-TP SSP、SMB、MSRPC UDP用户数据报协议 RUDP可靠的用户数据报协议 Mobile IP 移动IP协议网络层 IP/IPv6 互联网协议/互联网协议第六版 ICMPv6互联网控制信息协议第六版 ICMP互联网控制信息协议 IGMP 互联网组管理协议 SLIP 串行线路IP协议 安全协议 AH 认证头协议 ESP 安装封装有效载荷协议 路由协议 EGP 外部网关协议 OSPF 开放最短路径优先协议 IGRP 内部网关路由协议 NHRP 下一跳解析协议 IE-IRGP 增强内部网关路由选择协议 RIPng for IPv6 IPv6路由信息协议 GGP 网关到网关协议 VRRP 虚拟路由器冗余协议 PGM 实际通用组播协议 RSVP 资源预留协议 PIM-DM 密集模式独立组播协议 DVMRP 距离矢量组播路由协议 RIP2 路由信息协议第二版 PIM-SM 稀疏模式独立组播协议 MOSPF 组播开放最短路径优先协议数据链路层 MPLS 多协议标签交换协议 XTP 压缩传输协议 DCAP 数据转换客户访问协议 SLE 串行连接封装协议 IPinIP IP套IP封装协议 隧道协议 PPTP点对点隧道协议 L2F第二层转发协议 L2TP 第二层隧道协议 ATMP接入隧道管理协议 Cisco 协议 CDP 思科发现协议 CGMP 思科组管理协议 地址解析协议 ARP地址解析协议 RAR逆向地址解析协议物理层 IEEE 802.2 Ethernet v.2 Internetwork Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-12 00:18:04 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/什么是TCP、UDP以及两者的区别.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/什么是TCP、UDP以及两者的区别.html","title":"什么是TCP、UDP以及两者的区别 ✘","keywords":"","body":"什么是TCP TCP(Transmission Control Protocol传输控制协议）是一种面向连接的，可靠的，基于字节流的传输通信协议。 1、tcp(Transmission Control Protocol传输控制协议) 2、传输层协议 3、原因：应用层需要可靠的连接，但是IP层没有这样的流机制 4、面向连接，即在客户端和服务器之间发送数据之间，必须先建立连接 5、位于应用层和IP层之间 6、连接需要建立三次握手、四次挥手断开连接 7、传输数据时可靠的 TCP连接建立——使用三次握手建立连接 1、客户端发送请求【寻址请求】 2、服务器端收到报文请求，向客户端发回确认报文【确认请求】 3、客户端收到服务端的报文进行回应。【连接请求】 三次握手完成，TCP客户端和服务端成功地建立连接，可以传输数据。 TCP终止一个连接——四次握手 1、数据验证请求码 2、传输结束标记 3、确认结束标记 4、连接断开标记 UDP(User Datagram Protocol用户数据报协议) 1、UDP(User Datagram Protocol用户数据报协议) 2、传输层协议 3、无连接的数据报协议 4、不能提供数据报分组，组装和不能对数据报进行排序 5、主要用于不要求分组顺序到达的传输中，分组传输顺序的检查和排序有应用层完成。 6、提供面向事务的简单不可靠传递服务。 7、UDP协议使用端口分别运行在同一台设备上的多个应用程序 8、功能：为了在给定的主句上能识别多个目的的地址，同时允许多个应用程序在同一台主句上工作并能够独立地进行数据包的发送和接受，设计用户数据报协议UDP TCP、UDP两者的区别 1、TCP是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP是无连接的（发送数据之前不需要先建立连接） 2、TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP使用越来越多。 4、每一条TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信。 5、TCP对系统资源要去比较多，UDP对系统资源要求比较少 6、UDP程序结构更加简单 7、TCP是流模式，UDP是数据报模式 1、字节流是通过二进制进行传输，比如0101010001之类的。 2、用户数据传输分为两种协议：udp、tcp。 3、UDP协议不建立连接直接传输，每次最大数据64k，打包形式。 4、TCP协议是经过三次握手协议(先连接)，安全，数据大小不限，传输速度慢。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-05 10:43:06 "},"HttpAndBrowerAndPerformanceSafety/Interview/safe/":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/safe/","title":"网络安全相关 ✘","keywords":"","body":"安全相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-11 13:52:29 "},"HttpAndBrowerAndPerformanceSafety/Interview/safe/safe.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/safe/safe.html","title":"网络安全相关 ✘","keywords":"","body":"面试知识点 - web安全 [参考]（https://segmentfault.com/a/1190000012693772） Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 19:15:31 "},"HttpAndBrowerAndPerformanceSafety/Interview/Performance/":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/Performance/","title":"性能相关 ✘","keywords":"","body":"我们都知道对于Web应用来说性能很重要。然而性能优化相关的知识却非常的庞大并且杂乱。对于性能优化需要做些什么以及性能瓶颈是什么，通常我们并不清楚（不包括那些对性能优化有丰富经验的高手）。 事实上关于Web性能有很多可以优化的点，其中涉及到的知识大致可以划分为几类：度量标准、编码优化、静态资源优化、交付优化、构建优化、性能监控。 本文主要介绍性能优化需要做的事以及需要考虑的问题。目的在于给读者脑海中生成一个宏观的地图。 不会介绍每个优化项目具体如何操作。PS：后续会有系列文章针对不同优化分类下的具体优化操作进行更详细的介绍。 1.度量标准与设定目标 在进行性能优化之前，我们需要为应用选择一个正确的度量标准（性能指标）以及设定一个合理的优化目标。 并不是所有指标都同样重要，这取决于你的应用。最后根据度量标准设定一个现实的目标。 1.1 度量标准 下面是一些值得考虑的指标： 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上） 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成） 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互） 输入响应（Input responsiveness，界面响应用户输入所需的时间） 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好） 自定义指标，由业务需求和用户体验来决定。 FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。 1.2设定目标 100毫秒的界面响应时间与60FPS 速度指标（Speed Index）小于1250ms 3G网络环境下可交互时间小于5s 重要文件的大小预算小于170kb 以上四种指标的设定都有据可循。详细信息请查看RAIL性能模型。 2.编码优化 编码优化涉及到应用的运行时性能，本小节介绍几个可以提升程序运行时性能的建议。 2.1 数据读取速度 事实上数据访问速度有快慢之分，下面列出几个影响数据访问速度的因素： 字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢 变量从局部作用域到全局作用域的搜索过程越长速度越慢 对象嵌套的越深，读取速度就越慢 对象在原型链中存在的位置越深，找到它的速度就越慢 推荐的做法是缓存对象成员值。将对象成员值缓存到局部变量中会加快访问速度 2.2 DOM 应用在运行时，性能的瓶颈主要在于DOM操作的代价非常昂贵，下面列出一些关于DOM操作相关提升性能的建议： 在JS中对DOM进行访问的代价非常高。请尽可能减少访问DOM的次数（建议缓存DOM属性和元素、把DOM集合的长度缓存到变量中并在迭代中使用。读变量比读DOM的速度要快很多。） 重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，建议先让元素脱离文档流，处理完毕后再让元素回归文档流，这样浏览器只会进行两次重排与重绘（脱离时和回归时）。 善于使用事件委托 2.3 流程控制 下面列出一些流程控制相关的一些可以略微提升性能的细节，这些细节在大型开源项目中大量运用（例如Vue）： 避免使用for...in（它能枚举到原型，所以很慢） 在JS中倒序循环会略微提升性能 减少迭代的次数 基于循环的迭代比基于函数的迭代快8倍 用Map表代替大量的if-else和switch会提升性能 3.静态资源优化 Web应用的运行离不开静态资源，所以对静态资源的优化至关重要。 3.1 使用Brotli或Zopfli进行纯文本压缩 在最高级别的压缩下Brotli会非常慢（但较慢的压缩最终会得到更高的压缩率）以至于服务器在等待动态资源压缩的时间会抵消掉高压缩率带来的好处，但它非常适合静态文件压缩，因为它的解压速度很快。 使用Zopfli压缩可以比Zlib的最大压缩提升3％至8％。 3.2 图片优化 尽可能通过srcset，sizes和元素使用响应式图片。还可以通过元素使用WebP格式的图像。 响应式图片可能大家未必听说过，但响应式布局大家肯定都听说过。响应式图片与响应式布局类似，它可以在不同屏幕尺寸与分辨率的设备上都能良好工作（比如自动切换图片大小、自动裁切图片等）。 当然，如果您不满足这种尺度的优化，还可以对图片进行更深层次的优化。例如：模糊图片中不重要的部分以减小文件大小、使用自动播放与循环的HTML5视频替换GIF图，因为视频比GIF文件还小（好消息是未来可以通过img标签加载视频）。 4.交付优化 交付优化指的是对页面加载资源以及用户与网页之间的交付过程进行优化。 4.1 异步无阻塞加载JS JS的加载与执行会阻塞页面渲染，可以将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS。有多种无阻塞加载JS的方法：defer、async、动态创建script标签、使用XHR异步请求JS代码并注入到页面。 但更推荐的做法是使用defer或async。如果使用defer或async请将Script标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。 4.2 使用Intersection Observer实现懒加载 懒加载是一个比较常用的性能优化手段，下面列出了一些常用的做法： 可以通过Intersection Observer延迟加载图片、视频、广告脚本、或任何其他资源。 可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。 延迟加载所有体积较大的组件、字体、JS、视频或Iframe是一个好主意 4.3 优先加载关键的CSS CSS资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成标签中CSS的加载与解析之后才会渲染页面。如果CSS文件过大，用户就需要等待很长的时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的CSS提取出来内嵌到中，然后再将剩余部分的CSS用异步的方式加载。可以通过Critical做到这一点。 4.4 资源提示（Resource Hints） Resource Hints（资源提示）定义了HTML中的Link元素与dns-prefetch、preconnect、prefetch与prerender之间的关系。它可以帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。 4.4.1 dns-prefetch dns-prefetch可以指定一个用于获取资源所需的源（origin），并提示浏览器应该尽可能早的解析。 > 4.4.2 preconnect preconnect用于启动预链接，其中包含DNS查找，TCP握手，以及可选的TLS协议，允许浏览器减少潜在的建立连接的开销。 4.4.3 prefetch Prefetch用于标识下一个导航可能需要的资源。浏览器会获取该资源，一旦将来请求该资源，浏览器可以提供更快的响应。 > > 浏览器不会预处理、不会自动执行、不会将其应用于当前上下文。 as与crossorigin选项都是可选的。 4.4.4 prerender prerender用于标识下一个导航可能需要的资源。浏览器会获取并执行，一旦将来请求该资源，浏览器可以提供更快的响应。 浏览器将预加载目标页面相关的资源并执行来预处理HTML响应。 4.5 Preload 通过一个现有元素（例如：img，script，link）声明资源会将获取与执行耦合在一起。然而应用可能只是想要先获取资源，当满足某些条件时再执行资源。 Preload提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。因此，Preload可以构建自定义的资源加载与执行。 例如，应用可以使用Preload进行CSS资源的预加载、并且同时具备：高优先级、不阻塞渲染等特性。然后应用程序在合适的时间使用CSS资源： var res = document.createElement(\"link\"); res.rel = \"preload\"; res.as = \"style\"; res.href = \"styles/other.css\"; document.head.appendChild(res); Link: ; rel=preload; as=style 4.6 快速响应的用户界面 PSI（Perceptual Speed Index，感知速度指数）是提升用户体验的重要指标，让用户感觉到页面的反馈比没有反馈体验要好很多。 可以尝试使用骨架屏或添加一些Loading过渡动画提示用户体验。 输入响应（Input responsiveness）指标同样重要，甚至更重要。试想，用户点击了网页后缺毫无反应会是什么心情。JS的单线程大家已经不能再熟悉，这意味着当JS在运行时用户界面处于“锁定”状态，所以JS同步执行的时间越长，用户等待响应的时间也就越长。 据调查，JS执行100毫秒以上用户就会明显觉得网页变卡了。所以要严格限制每个JS任务执行时间不能超过100毫秒。 解决方案是可以将一个大任务拆分成多个小任务分布在不同的Macrotask中执行（通俗的说是将大的JS任务拆分成多个小任务异步执行）。或者使用WebWorkers，它可以在UI线程外执行JS代码运算，不会阻塞UI线程，所以不会影响用户体验。 应用越复杂，主动管理UI线程就越重要 5.构建优化 现代前端应用都需要有构建的过程，项目在构建过程中是否进行了合理的优化，会对Web应用的性能有着巨大的影响。例如：影响构建后文件的体积、代码执行效率、文件加载时间、首次有效绘制指标等。 5.1 使用预编译 拿Vue举例，如果您使用单文件组件开发项目，组件会在编译阶段将模板编译为渲染函数。最终代码被执行时可以直接执行渲染函数进行渲染。而如果您没有使用单文件组件预编译代码，而是在网页中引入vue.min.js，那么应用在运行时需要先将模板编译成渲染函数，然后再执行渲染函数进行渲染。相比预编译，多了模板编译的步骤，所以会浪费很多性能。 5.2 使用 Tree-shaking、Scope hoisting、Code-splitting Tree-shaking是一种在构建过程中清除无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。 目前Webpack与Rollup都支持Scope Hoisting。它们可以检查import链，并尽可能的将散乱的模块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了一次的模块才会被合并。使用Scope Hoisting可以让代码体积更小并且可以降低代码在运行时的内存开销，同时它的运行速度更快。前面2.1节介绍了变量从局部作用域到全局作用域的搜索过程越长执行速度越慢，Scope Hoisting可以减少搜索时间。 code-splitting是Webpack中最引人注目的特性之一。此特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。code-splitting可以用于获取更小的bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 5.3 服务端渲染（SSR） 单页应用需要等JS加载完毕后在前端渲染页面，也就是说在JS加载完毕并开始执行渲染操作前的这段时间里浏览器会产生白屏。 服务端渲染（Server Side Render，简称SSR）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。 比较推荐的做法是：使用服务端渲染静态HTML来获得更快的首次有效绘制，一旦JavaScript加载完毕再将页面接管下来。 5.4 使用import函数动态导入模块 使用import函数可以在运行时动态地加载ES2015模块，从而实现按需加载的需求。 这种优化在单页应用中变得尤为重要，在切换路由的时候动态导入当前路由所需的模块，会避免加载冗余的模块（试想如果在首次加载页面时一次性把整个站点所需要的所有模块都同时加载下来会加载多少非必须的JS，应该尽可能的让加载的JS更小，只在首屏加载需要的JS）。 使用静态import导入初始依赖模块。其他情况下使用动态import按需加载依赖 5.5 使用HTTP缓存头 正确设置expires，cache-control和其他HTTP缓存头。 推荐使用Cache-control: immutable避免重新验证。 6.其他 其他一些值得考虑的优化点： HTTP2 使用最高级的CDN（付费的比免费的强的多） 优化字体 其他垂直领域的性能优化 7.性能监控 最后，你可能需要一个性能检测工具来持续监视网站的性能。 8.总结 最后用一张图来总结这篇文章所表达的内容 参考资源 https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/ 《高性能JavaScript》 https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images https://www.w3.org/TR/preload/ https://w3c.github.io/resource-hints/ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 21:19:00 "},"HttpAndBrowerAndPerformanceSafety/Interview/Performance/detail.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/Performance/detail.html","title":"详细 ✔","keywords":"","body":"https://csspod.com/frontend-performance-best-practices/ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-16 01:24:33 "},"Javascript/":{"url":"Javascript/","title":"Javascript","keywords":"","body":"Javascript Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 18:54:11 "},"Javascript/interview/js基础面试.html":{"url":"Javascript/interview/js基础面试.html","title":"Javascript基础面试","keywords":"","body":" 目录  1. JavaScript 有哪些数据类型  2. 怎么判断不同的JS数据类型  3. undefined 和 null 有什么区别  4. 数组对象有哪些常用方法  5. Js 有哪几种创建对象的方式  6. 怎么实现对对象的拷贝(浅拷贝与深拷贝)  7. 什么是闭包，为什么要用它  8. 介绍一下 JavaScript 原型，原型链，它们有何特点  9. JavaScript 如何实现继承  10. new 操作符具体干了什么  11. 同步和异步的区别，怎么异步加载 JavaScript  12. 跨域问题的产生，怎么解决它  13. 对 this 的理解  14. apply()、call()和 bind() 是做什么的，它们有什么区别  15. 什么是内存泄漏，哪些操作会造成内存泄漏  16. 什么是事件代理，它的原理是什么  17. 对AMD和CMD的理解，它们有什么区别  18. 对ES6的了解  19. 箭头函数有什么特点  20. Promise 对象的了解  21. async 函数以及 awit 命令  22. export 与 export default有什么区别  23. 前端性能优化  24. 对JS引擎执行机制的理解  25. 事件流  26. 事件循环event-loop 1. JavaScript 有哪些数据类型 6种原始数据类型： Boolean: 布尔表示一个逻辑实体，可以有两个值：true 和 false Number: 用于表示数字类型 String: 用于表示文本数据 Null: Null 类型只有一个值： null,特指对象的值未设置 Undefined: 一个没有被赋值的变量会有个默认值 undefined Symbol: 符号(Symbols)是ECMAScript第6版新定义的。符号类型是唯一的并且是不可修改的 引用类型：Object 详见 JavaScript的数据类型-MDN 2. 怎么判断不同的JS数据类型 typeof操作符：返回一个字符串，表示未经计算的操作数的类型 typeof 操作符对于简单数据类型，返回其本身的数据类型，函数对象返回 function ，其他对象均返回 Object null 返回 Object instanceof: 用来判断A 是否是 B的实例，表达式为 A instanceof B，返回一个Boolean类型的值 instanceof 检测的是原型,只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型 let a = []; a instanceof Array // true a instanceof Object // true 变量a 的 __proto__ 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，a 就是Object的实例.针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型 constructor: 当一个函数被定义时，JS引擎会为其添加prototype原型，然后再在 prototype上添加一个 constructor 属性，并让其指向该函数的引用 null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过其他方式来判断 函数的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor引用会丢失，constructor会默认为 Object function F() {}; var f = new F; f.constructor == F // true F.prototype = {a: 1} var f = new F f.constructor == F // false 在构造函数 F.prototype 没有被重写之前，构造函数 F 就是新创建的对象 f 的数据类型。当 F.prototype 被重写之后，原有的 constructor 引用丢失, 默认为 Object 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改 toString: Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(11) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call([]) ; // [object Array] 3. undefined 和 null 有什么区别 null表示\"没有对象\"，即该处不应该有值 典型用法： 作为函数的参数，表示该函数的参数不是对象 作为对象原型链的终点 undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义 典型用法： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值的属性，该属性的值为undefined 函数没有返回值时，默认返回undefined 详见： undefined和null的区别-阮一峰 4. 数组对象有哪些常用方法 修改器方法： pop(): 删除数组的最后一个元素，并返回这个元素 push()：在数组的末尾增加一个或多个元素，并返回数组的新长度 reverse(): 颠倒数组中元素的排列顺序 shift(): 删除数组的第一个元素，并返回这个元素 unshift(): 在数组的开头增加一个或多个元素，并返回数组的新长度 sort(): 对数组元素进行排序，并返回当前数组 splice(): 在任意的位置给数组添加或删除任意个元素 访问方法： concat(): 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组 join(): 连接所有数组元素组成一个字符串 slice(): 抽取当前数组中的一段元素组合成一个新数组 indeOf(): 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1 lastIndexOf(): 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1 迭代方法： forEach(): 为数组中的每个元素执行一次回调函数,最终返回 undefined every(): 如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false some(): 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false filter(): 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回 map(): 返回一个由回调函数的返回值组成的新数组 更多方法请参考 MDN 传送门 5. Js 有哪几种创建对象的方式 对象字面量 var obj = {} Object 构造函数 var obj = new Object() 工厂模式 function Person(name, age) { var o = new Object() o.name = name; o.age = age; o.say = function() { console.log(name) } return o } 缺点： 每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源 构造函数模式 function Person(name, age) { this.name = name this.age = age this.say = function() { console.log(name) } } var person = new Person('hello', 18) 构造函数模式隐试的在最后返回return this 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象,可以根据return this 的特性调用call或者apply指定this 原型模式 function Person() {} Person.prototype.name = 'hanmeimei'; Person.prototype.say = function() { alert(this.name); } Person.prototype.friends = ['lilei']; var person = new Person(); 实现了方法与属性的共享，可以动态添加对象的属性和方法。但是没有办法创建实例自己的属性和方法，也没有办法传递参数 构造函数和原型组合 function Person(name, age) { this.name = name this.age = age } Person.prototype.say = function() { console.log(this.name) } var person = new Person('hello') 还有好几种模式，感兴趣的小伙伴可以参考 红宝书，你们肯定知道的了！ 6. 怎么实现对对象的拷贝(浅拷贝与深拷贝) 浅拷贝 拷贝原对象引用 可以使用Array.prototype.slice()也可以完成对一个数组或者对象的浅拷贝 Object.assign()方法 深拷贝 最常用的方式就是 JSON.parse(JSON.stringify(目标对象)，缺点就是只能拷贝符合JSON数据标准类型的对象 7. 什么是闭包，为什么要用它 简单来说，闭包就是能够读取其他函数内部变量的函数 function Person() { var name = 'hello' function say () { console.log(name) } return say() } Person() // hello 由于 JavaScript 特殊的作用域，函数外部无法直接读取内部的变量，内部可以直接读取外部的变量，从而就产生了闭包的概念 用途： 最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中 注意点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 8. 介绍一下 JavaScript 原型，原型链，它们有何特点 首先明确一点，JavaScript是基于原型的 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针. 图解： 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象 原型对象默认拥有一个constructor属性，指向指向它的那个构造函数 每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象 那么什么是原型链： JavaScript中所有的对象都是由它的原型对象继承而来。而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链 所有原型链的终点都是Object函数的prototype属性。Objec.prototype指向的原型对象同样拥有原型，不过它的原型是null，而null则没有原型 9. JavaScript 如何实现继承 原型链继承 function Animal() {} Animal.prototype.name = 'cat' Animal.prototype.age = 1 Animal.prototype.say = function() {console.log('hello')} var cat = new Animal() cat.name // cat cat.age // 1 cat.say() // hello 最简单的继承实现方式，但是也有其缺点 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 要想为子类新增属性和方法，必须要在new语句之后执行，不能放到构造器中 构造继承 function Animal() { this.species = \"动物\" } function Cat(name, age) { Animal.call(this) this.name = name this.age = age } var cat = new Cat('豆豆', 2) cat.name // 豆豆 cat.age // 2 cat.species // 动物 使用call或apply方法，将父对象的构造函数绑定在子对象上. 组合继承 function Animal() { this.species = \"动物\" } function Cat(name){ Animal.call(this) this.name = name } Cat.prototype = new Animal() // 重写原型 Cat.prototype.constructor = Cat 如果没有Cat.prototype = new Animal()这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal.这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat extends 继承 ES6新增继承方式，Class 可以通过extends关键字实现继承 class Animal { } class Cat extends Animal { constructor() { super(); } } 使用 extends 实现继承，必须添加 super 关键字定义子类的 constructor，这里的super() 就相当于 Animal.prototype.constructor.call(this) 当然，还有很多种实现继承的方式，这里就不多说了。然后，再推荐一波 红宝书 10. new 操作符具体干了什么 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 11. 同步和异步的区别，怎么异步加载 JavaScript 同步模式 同步模式，又称阻塞模式。javascript 在默认情况下是会阻塞加载的。当前面的 javascript 请求没有处理和执行完时，会阻止浏览器的后续处理 异步模式 异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理 异步加载 JavaScript 动态添加 script 标签 defer async defer属性和async都是属于 script 标签上面的属性，两者都能实现 JavaScript 的异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到 html 加载完毕之后再执行 12. 跨域问题的产生，怎么解决它 由于浏览器的 同源策略，在出现 域名、端口、协议有一种不一致时，就会出现跨域，属于浏览器的一种安全限制。 解决跨域问题有很多种方式，常用的就是以下几种： jsonp 跨域：动态创建script，再请求一个带参网址实现跨域通信.缺点就是只能实现 get 一种请求 document.domain + iframe跨域：两个页面都通过js强制设置document.domain为基础主域，就实现了同域.但是仅限主域相同，子域不同的跨域应用场景 跨域资源共享（CORS）：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置 nginx反向代理接口跨域：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题 WebSocket协议跨域 13. 对 this 的理解 在 JavaScript 中，研究 this 一般都是 this 的指向问题，核心就是 this 永远指向最终调用它的那个对象，除非改变 this 指向或者箭头函数那种特殊情况 function test() { console.log(this); } test() // window var obj = { foo: function () { console.log(this.bar) }, bar: 1 }; var foo = obj.foo; var bar = 2; obj.foo() // 1 foo() // 2 // 函数调用的环境不同，所得到的结果也是不一样的 14. apply()、call()和 bind() 是做什么的，它们有什么区别 相同点：三者都可以改变 this 的指向 不同点： apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组 var obj = { name : 'sss' } function func(firstName, lastName){ console.log(firstName + ' ' + this.name + ' ' + lastName); } func.apply(obj, ['A', 'B']); // A sss B call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组 var obj = { name: 'sss' } function func(firstName, lastName) { console.log(firstName + ' ' + this.name + ' ' + lastName); } func.call(obj, 'C', 'D'); // C sss D bind 接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数 var obj = { name: 'sss' } function func() { console.log(this.name); } var func1 = func.bind(null, 'xixi'); func1(); apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数 bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window bind 在传递参数的时候会将自己带过去的参数排在原函数参数之前 function func(a, b, c) { console.log(a, b, c); } var func1 = func.bind(this, 'xixi'); func1(1,2) // xixi 1 2 15. 什么是内存泄漏，哪些操作会造成内存泄漏 内存泄漏：是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束 可能造成内存泄漏的操作： 意外的全局变量 闭包 循环引用 被遗忘的定时器或者回调函数 你可能还需要知道 垃圾回收机制 此外，高程上面对垃圾回收机制的介绍也很全面，有兴趣的小伙伴可以看看 16. 什么是事件代理，它的原理是什么 事件代理：通俗来说就是将元素的事件委托给它的父级或者更外级元素处理 原理：利用事件冒泡机制实现的 优点：只需要将同类元素的事件委托给父级或者更外级的元素，不需要给所有元素都绑定事件，减少内存空间占用，提升性能; 动态新增的元素无需重新绑定事件 17. 对AMD和CMD的理解，它们有什么区别 AMD和CMD都是为了解决浏览器端模块化问题而产生的，AMD规范对应的库函数有 Require.js，CMD规范是在国内发展起来的，对应的库函数有Sea.js AMD和CMD最大的区别是对依赖模块的执行时机处理不同 1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 2、CMD推崇就近依赖，只有在用到某个模块的时候再去require 参考：AMD-中文版 CMD-规范 18. 对ES6的了解 ECMAScript 6.0 是 JavaScript 语言的下一代标准 新增的特性： 声明变量的方式 let const 变量解构赋值 字符串新增方法 includes() startsWith() endsWith() 等 数组新增方法 Array.from() Array.of() entries() keys() values() 等 对象简洁写法以及新增方法 Object.is() Object.assign() entries() keys() values()等 箭头函数、rest 参数、函数参数默认值等 新的数据结构： Set 和 Map Proxy Promise对象 async函数 await命令 Class类 Module 体系 模块的加载和输出方式 了解更多，参考 ES6入门-阮一峰 19. 箭头函数有什么特点 ES6 允许使用“箭头”（=>）定义函数 var f = v => v; // 等同于 var f = function (v) { return v; } 注意点： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 20. Promise 对象的了解 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大.所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果 --ES6入门-阮一峰 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 特点： 对象的状态不受外界影响 一旦状态改变，就不会再变，任何时候都可以得到这个结果 Promise 新建后就会立即执行 const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 promise.then(function(value) { // success }, function(error) { // failure }) then 方法返回的是一个新的Promise实例 Promise.prototype.catch 用于指定发生错误时的回调函数,具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获 getJSON('/post/1.json').then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }); catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法 出去上述方法，Promise还有其他用法，小伙伴们可以在这里查看大佬写的文章 ES6入门-阮一峰 21. async 函数以及 awit 命令 async 函数是什么？一句话，它就是 Generator 函数的语法糖 了解Generator函数的小伙伴，这里 传送门 async 特点： async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数 async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误 async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到 function timeout(ms) { return new Promise((resolve) => { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint('hello world', 50); await 命令: await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值 async function f() { // 等同于 // return 123; return await 123; } f().then(v => console.log(v)) // 123 await 命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象.也就是说就算一个对象不是Promise对象，但是只要它有then这个方法， await 也会将它等同于Promise对象 使用注意点： await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中 多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发 await 命令只能用在 async 函数之中，如果用在普通函数，就会报错 了解更多，请点击 这里 22. export 与 export default有什么区别 export 与 export default 均可用于导出常量、函数、文件、模块等 在一个文件或模块中，export、import 可以有多个，export default 仅有一个 通过 export 方式导出，在导入时要加 { }，export default 则不需要 使用 export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名; export 加载的时候需要知道加载模块的变量名 export default 命令的本质是将后面的值，赋给 default 变量，所以可以直接将一个值写在 export default 之后 23. 前端性能优化 参见 雅虎14条前端性能优化 24. 对JS引擎执行机制的理解 首选明确两点： JavaScript 是单线程语言 JavaScript 的 Event Loop 是 JS 的执行机制, 也就是事件循环 console.log(1) setTimeout(function(){ console.log(2) },0) console.log(3) // 1 3 2 JavaScript 将任务分为同步任务和异步任务，执行机制就是先执行同步任务，将同步任务加入到主线程，遇到异步任务就先加入到 event table ，当所有的同步任务执行完毕，如果有可执行的异步任务，再将其加入到主线程中执行 视频详解，移步 这里 setTimeout(function(){console.log(1);},0); new Promise(function(resolve){ console.log(2); for(var i = 0; i 在异步任务中，定时器也属于特殊的存在。有人将其称之为 宏任务、微任务，定时器就属于宏任务的范畴。 参考 JS引擎的执行机制 25. 事件流 参考 [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://www.cnblogs.com/cangqinglang/p/8963557.html) 事件流分为两种，捕获事件流和冒泡事件流。 - 捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。 - 冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。 26. 事件循环event-loop[https://blog.csdn.net/qq_36150631/article/details/88787226] 概括 事件循环：从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到任务队列中排队。程序按照代码顺序执行完毕后，查询任务队列中是否有等待的任务。如果有，则按照次序从任务队列中把任务放到执行栈中执行。执行完毕后，再从任务队列中获取任务，再执行，不断重复。 　　由于主线程不断的重复读取任务、执行任务、再取任务、再执行。所以，这种机制被称为事件循环 线程 javascript是单线程的语言，也就是说，同一个时间只能做一件事 why? 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 排队 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着 var i, t = Date.now() for (i = 0; i 像上面这样，如果排队是因为计算量大，CPU忙不过来，倒也算了 但是，如果是网络请求就不合适。因为一个网络请求的资源什么时候返回是不可预知的，这种情况再排队等待就不明智了 同步和异步 【同步】 如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的 Math.sqrt(2); console.log('Hi'); 第一个函数返回时，就拿到了预期的返回值：2的平方根；第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串所以这两个函数都是同步的 【异步】 如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的 fs.readFile('foo.txt', 'utf8', function(err, data) { console.log(data); }); 在上面的代码中，我们希望通过fs.readFile函数读取文件foo.txt中的内容，并打印出来。但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间 所以，fs.readFile函数是异步的 　　正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择 异步详解 从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有执行异步操作、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分 　　一个异步过程通常是这样的：主线程发起一个异步请求，异步任务接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时异步操作开始执行；执行完成后通知主线程；主线程收到通知后，执行一定的动作(调用回调函数) 　　因此，一个异步过程包括两个要素：注册函数和回调函数，其中注册函数用来发起异步过程，回调函数用来处理结果 　　下面的代码中，其中的setTimeout就是异步过程的发起函数，fn是回调函数 setTimeout(fn, 1000); 有一个很重要的问题，如何才算是异步操作执行完成呢？对于不同类型的异步任务，操作完成的标准不同 【异步类型】 　　一般而言，异步任务有以下三种类型 　　1、普通事件，如click、resize等 　　2、资源加载，如load、error等 　　3、定时器，包括setInterval、setTimeout等 　　下面对这三种类型分别举例说明，下面代码中，鼠标点击div时，就代表任务执行完成了 div.onclick = () => { console.log('click') } 下面代码中，XHR对象的readyState值为4，即已经接收到全部响应数据了，代表任务执行完成 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ //实际操作 result.innerHTML += xhr.responseText; } } } 下面代码中，过1s后，代表任务执行完成 setTimeout(() => { console.log('timeout') },1000) 对于同步任务来说，按顺序执行即可；但是，对于异步任务，各任务执行的时间长短不同，执行完成的时间点也不同，主线程如何调控异步任务呢？这就用到了任务队列 任务队列 　　有些文章把任务队列称为消息队列，或者叫事件队列，总之是和异步任务相关的队列 　　可以确定的是，它是队列这种先入先出的数据结构，和排队是类似的，哪个异步操作完成的早，就排在前面。不论异步操作何时开始执行，只要异步操作执行完成，就可以到任务队列中排队 　　这样，主线程在空闲的时候，就可以从任务队列中获取任务并执行 　　任务队列中放的任务具体是什么东西？任务的具体结构当然跟具体的实现有关。但是为了简单起见，可以认为：任务就是注册异步任务时添加的回调函数 任务队列的宏任务和微任务 任务队列的宏任务和微任务JS异步还有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入event queue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数，如下图： 【事件】 　　为什么叫事件循环？而不叫任务循环或消息循环。究其原因是任务队列中的每条任务实际上都对应着一个事件 　　DOM操作对应的是DOM事件，资源加载操作对应的是加载事件，而定时器操作可以看做对应一个“时间到了”的事件 如图： 同步和异步任务分别进入不同的执行“场所”，同步进入主线程，异步进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，回去了Event Queue读取对应的函数，进入主线程。上述过程会不断重复，也就是常说的Event Loop（事件循环）。 Event-loop 是如何工作的？ 先看一个简单的示例： setTimeout(()=>{ console.log(\"setTimeout1\"); Promise.resolve().then(data => { console.log(222); }); }); setTimeout(()=>{ console.log(\"setTimeout2\"); }); Promise.resolve().then(data=>{ console.log(111); }); // qqqq 复制代码思考一下, 运行结果是什么？ 运行结果为: 111 setTimeout1 222 setTimeout2 复制代码我们来看一下为什么？ 我们来详细说明一下, JS引擎是如何执行这段代码的: 主线程上没有需要执行的代码 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)。 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在再下一次的事件循环中执行)。 首先检查微任务队列, 即 microtask队列，发现此队列不为空，执行第一个promise的then回调，输出 '111'。 此时microtask队列为空，进入下一个事件循环, 检查宏任务队列，发现有 setTimeout的回调函数，立即执行回调函数输出 'setTimeout1',检查microtask 队列，发现队列不为空，执行promise的then回调，输出'222'，microtask队列为空，进入下一个事件循环。 检查宏任务队列，发现有 setTimeout的回调函数, 立即执行回调函数输出'setTimeout2'。 再思考一下下面代码的执行顺序: console.log('script start'); setTimeout(function () { console.log('setTimeout---0'); }, 0); setTimeout(function () { console.log('setTimeout---200'); setTimeout(function () { console.log('inner-setTimeout---0'); }); Promise.resolve().then(function () { console.log('promise5'); }); }, 200); Promise.resolve().then(function () { console.log('promise1'); }).then(function () { console.log('promise2'); }); Promise.resolve().then(function () { console.log('promise3'); }); console.log('script end'); 复制代码思考一下, 运行结果是什么？ 运行结果为: script start script end promise1 promise3 promise2 setTimeout---0 setTimeout---200 promise5 inner-setTimeout---0 复制代码那么为什么？ 我们来详细说明一下, JS引擎是如何执行这段代码的: 首先顺序执行完主进程上的同步任务，第一句和最后一句的console.log 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)。 接着遇到setTimeout 200，它的作用是在 200ms 后将回调函数放到宏任务队列中(这个任务在再下一次的事件循环中执行)。 同步任务执行完之后，首先检查微任务队列, 即 microtask队列，发现此队列不为空，执行第一个promise的then回调，输出 'promise1'，然后执行第二个promise的then回调，输出'promise3'，由于第一个promise的.then()的返回依然是promise，所以第二个.then()会放到microtask队列继续执行，输出 'promise2'; 此时microtask队列为空，进入下一个事件循环, 检查宏任务队列，发现有 setTimeout的回调函数，立即执行回调函数输出 'setTimeout---0',检查microtask 队列，队列为空，进入下一次事件循环. 检查宏任务队列，发现有 setTimeout的回调函数, 立即执行回调函数输出'setTimeout---200'. 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中，检查微任务队列，即 microtask 队列，发现此队列不为空，执行promise的then回调，输出'promise5'。 此时microtask队列为空，进入下一个事件循环，检查宏任务队列，发现有 setTimeout 的回调函数，立即执行回调函数输出，输出'inner-setTimeout---0'。代码执行结束. 为什么会需要event-loop? 因为 JavaScript 是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 最后有一点需要注意的是：本文介绍的是浏览器的Event-loop，因此在测试验证时，一定要使用浏览器环境进行测试验证，如果使用了node环境，那么结果不一定是如上所说。 1.forEach、for-in与for-of的区别 forEach介绍 objArr.forEach(function (value) { console.log(value); }); foreach 方法没办法使用 break 语句跳出循环，或者使用return从函数体内返回 for-in介绍 for-in循环设计之初，是给普通以字符串的值为key的对象使用的。而非数组。 所以： for(var index in objArr){ console.log(objArr[index]) } 以上代码会出现的问题： index 值 会是字符串（String）类型 循环不仅会遍历数组元素，还会遍历任意其他自定义添加的属性，如，objArr上面包含自定义属性，objArr.name，那这次循环中也会出现此name属性 某些情况下，上述代码会以随机顺序循环数组 for-of介绍 for(let value of objArr){ console.log(value) } 可以避免所有 for-in 循环的陷阱 不同于 forEach()，可以使用 break, continue 和 return for-of 循环不仅仅支持数组的遍历。同样适用于很多类似数组的对象 它也支持字符串的遍历 for-of 并不适用于处理原有的原生对象 for-of 遍历 Set var uniqueWords = new Set(words); for (var word of uniqueWords) { console.log(word); } for-of 遍历 Map for (var [key, value] of phoneBookMap) { console.log(key + \"'s phone number is: \" + value); } Map是键值对组成，需要用到 Es6新特性解构 for-of 遍历原生对象 // 输出对象自身可以枚举的值 for (var key of Object.keys(someObject)) { console.log(key + \": \" + someObject[key]); } 总结 for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法： for (var key of Object.keys(someObject)) { console.log(key + \": \" + someObject[key]); } 遍历map对象时适合用解构,例如; for (var [key, value] of phoneBookMap) { console.log(key + \"'s phone number is: \" + value); }new一个函数的过程 function Foo(){}; var f = new Foo(); 这个过程等同于function Foo(){} var f = new Object(); // 新建一个对象 f.proto = Foo.prototype;// 使该构造函数的隐式原形等于实例函数的显示原形 Foo.call(f); // 使用call方法调用函数并且指定上下文的'this' // 当调用Foo方法的时候，该方法的this值会绑定到f对象上。 说说你对AMD和Commonjs的理解? CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-25 11:09:51 "},"Javascript/基础1.1JavaScript声明变量详解.html":{"url":"Javascript/基础1.1JavaScript声明变量详解.html","title":"基础1.1JavaScript声明变量详解 ✔","keywords":"","body":"前言 如果文章中有出现纰漏、错误之处，还请看到的小伙伴多多指教，先行谢过 在ES5阶段，JavaScript 使用 var 和 function 来声明变量， ES6 中又添加了let、const、import、 Class 这几种声明变量的方式。那么，他们各自都有什么样的特点呢？ 下面，就让我们一起去探究一下吧 以下↓ 变量就是存储信息的容器。 ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据 var 声明 一直以来，我们都是使用 var 关键字来声明变量 var a = 1; var b; console.log(a) // 1 console.log(b) // undefined console.log(c) // undefined var b = 2; var c = 3; console.log(b) // 2 console.log(c) // 3 function f() { var c = 4; console.log(c) // 4 c = 5; console.log(c) // 5 } f(); console.log(c) // 3 function fun() { c = 6 } fun(); console.log(c) // 6 从上面的结果我们不难看出，使用var声明的变量具有以下特点： 变量可以没有初始值，会保存一个特殊的值 undefined 变量可以重复定义，且可以修改值 变量声明语句从自动提升到所在作用域的顶端 函数内重复定义对函数外无影响(局部变量) 函数内重新赋值对函数外有影响 function 关键字声明 在 ES5 中，除了使用 var 声明变量，我们也可以使用 function 关键字声明变量 f(); function f() {console.log(1)} var f; console.log(f) // function f 特点： 使用 function 声明的是函数对象，也存在声明提升 函数声明要优于变量声明 let声明 由于 ES5 中使用 var 声明变量存在着一些很让人迷惑的特性（比如变量提升，重复定义等），ES6 中新增 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在 let 命令所在的代码块内有效 { var a = 1; let b = 2; } console.log(a) // 1 console.log(b) // Uncaught ReferenceError: b is not defined console.log(c) // Uncaught ReferenceError: c is not defined let c = 3 let a = 4 console.log(a) // Identifier 'a' has already been declared 通过以上的代码，我们很容易发现使用 let 声明变量的特点： let 声明的变量只在它所在的代码块有效 不存在变量提升 不可以重复声明 由于 let 声明变量的这些特点，所以 for 循环的计数器，就很合适使用 let 命令 for(let i = 0; i let 实际上为 JavaScript 新增了块级作用域 const声明 const 也是 ES6 新增的声明变量的方式，const 声明一个只读的常量。一旦声明，常量的值就不能改变 const API; console.log(API) // SyntaxError: Missing initializer in const declaration console.log(MAX); // Uncaught ReferenceError: MAX is not defined const MAX = 1; const MAX = 2; console.log(MAX); // Identifier 'MAX' has already been declared const PI = 3.1415; console.log(PI) // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const f = {} f.name = 'HELLO' // 正常执行 f = {name: 'World'} // 报错 所以，使用 const 声明的变量具有以下特点： const 一旦声明变量，就必须立即初始化，不能留到以后赋值 不允许重复声明 不存在变量提升 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动 如果真的想将对象冻结，应该使用 Object.freeze 方法 import 声明 ES6 新增的模块的概念。 模块功能主要由两个命令构成：export 和 import。 export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能 所以在一定程度上来说，import 也具有声明变量的功能。只是在使用 import 的时候，具有一些限制 export { first, last } import { first, last } from './xxx' first = {} // Syntax Error : 'a' is read-only; first.name = 'Hello' // 成功执行，但是不建议这样使用 export default function(){} // a.js import xxx from 'a.js' import { New as $ } from './xxx' 特点： import 命令接受一对大括号，大括号里面的变量名，必须与被导入模块对外接口的名称相同 import 命令输入的变量都是只读的，因为它的本质是输入接口 当使用 export default 命令，为模块指定默认输出的时候，import 命令可以为该匿名函数指定任意名字 import 命令具有提升效果，会提升到整个模块的头部，首先执行 如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字 class 声明 ES6 引入了类的概念，有了 class 这个关键字，作为对象的模板。通过 class 关键字，可以定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，类的实质还是函数对象，类中的方法和对象其实都是挂在对应的函数对象的 prototype 属性下 所以就可以改写成下面这种ES5的方式 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function() { return '(' + this.x + ', ' + this.y + ')'; } 特点： 所有类都有 constructor 函数，如果没有显式定义，一个空的 constructor 方法会被默认添加。当然所有函数对象都必须有个主体 生成类的实例对象的写法，与 ES5 通过构造函数生成对象完全一样，也是使用 new 命令 class B {} let b = new B(); 在类的实例上面调用方法，其实就是调用原型上的方法 与函数对象一样，Class 也可以使用表达式的形式定义 Class 其实就是一个 function ，但是有一点不同，Class 不存在变量提升，也就是说 Class 声明定义必须在使用之前 全局变量 在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的 var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩 var a = 1; window.a // 1 let b = 2; window.b // undefined 隐式声明 在 JavaScript 中还存在着隐式声明。 a = 1; console.log(a) // 1 当没有声明，直接给变量赋值时，会隐式地给变量声明，此时这个变量作为全局变量存在。这个时候就不存在声明提前的问题了 最后 其实只要我们理解并掌握了这几种声明变量的方式，记住它们的特点，那么在实际使用的过程当中就很容易能够找到最合适的方式去定义 每天学习分享，不定期更新 最后，推荐一波前端学习历程，这段时间总结的一些面试相关，分享给有需要的小伙伴，欢迎 star 关注 传送门 参考文档 ECMAScript 6入门 ES6变量声明 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 18:31:53 "},"Javascript/基础1.2:变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链.html":{"url":"Javascript/基础1.2:变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链.html","title":"基础1.2:变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链 ✔","keywords":"","body":"基础1.1:变量（变量提升,暂时性死区）、执行环境、执行栈 一·变量提升 首先两个打印例子 a = 'ghostwu'; var a; console.log( a ); //ghostwu console.log( a ); var a = 'ghostwu'; //undefined why? 首先:明确两点 javascript代码并不是一行一行往下执行的. javascript执行分为2个步骤:1.编译(词法解释/预解释) 2.执行 其次:当我们碰到 var a = \"ghostwu\" 定义一个变量的时候， 其实js把这句话看成是2个阶段的事, var a 发生在==编译==阶段， a = 'ghostwu'发生在执行阶段. 然后 var a会被提升到当前作用域的最前面, a = 'ghostwu'留在原地==等待执行==阶段，所以： a = 'ghostwu'; var a; console.log( a ); // 上面这段代码经过编译之后，变成下面这样 var a; //被提升到当前作用域的最前面 a = 'ghostwu'; //留在原地，等待执行 console.log( a ); console.log( a ); var a = 'ghostwu'; //上面这段代码,经过编译之后，变成下面这样 var a; console.log( a ); a = 'ghostwu'; 明确函数定义的两种方式 //函数声明, 形如: function show(){ console.log( '函数声明方式' ); } //函数表达式, 形如: var show = function(){ console.log( '表达式方式' ); } 因为表达式和函数声明，在编译阶段，会产生不同的解释效果。 show(); //undefined function show(){ console.log( a ); var a = 'ghostwu'; } 函数声明会被提升 所以，上面的代码，经过编译之后，就变成了下面这样： function show(){ //函数声明被提升到 当前作用域的最前面 var a; //var声明被提升到当前作用域的最前面, 注意，它不会提升到函数的外面, 因为当前的作用域是在函数中 console.log( a ); a = 'ghostwu'; } show(); 函数表达式，是不会提升的, 看下面的例子: show(); //报错,show is not a function var show = function(){ console.log( 'ghostwu' ); } //对于上面这段表达式代码，经过编译之后: var show; show(); //执行之后就是 undefined, 所以在表达式定义之前，调用函数报错了 show = function(){ console.log( 'ghostwu' ); show(); //你好 var show; function show(){ console.log( '你好' ); } show = function(){ console.log( 'hello' ); } 上面的例子为什么是你好？ 因为： 当出现同名的函数声明，变量声明的时候， 函数声明会被优先提升，变量声明会被忽略。 所以经过编译之后，就变成: function show(){ console.log( '你好' ); } show(); //你好 show = function(){ console.log( 'hello' ); } show();//如果这里在调用一次，就是hello, 因为show函数体在执行阶段 被 重新赋值了 如果有同名的函数声明，后面的会覆盖前面的，如下: show(); //how are you var show; function show(){ console.log( 'hello' ); } show = function(){ console.log( '你好' ); } function show(){ console.log( 'how are you!' ); } //上面的代码经过编译之后，变成如下形式: function show(){ console.log( 'how are you!' ); } show(); //how are you show = function(){ console.log( '你好' ); } show(); //如果在这里再执行一次，结果：你好 暂时性死区 我们都知道，var声明的变量会有变量提升的作用，如下 console.log(a); //1 var a=1; console.log(b); //undefined var b; 可以看出，虽然代码中console调用a在前，声明a在后，但是由于在js中，函数及变量的声明都将被提升到函数的最顶部，也就是说（var声明的）变量可以先使用再声明。 然后，使用let，const（后面会提及）声明的变量却不存在变量提升。 console.log(foo); // Uncaught ReferenceError: foo is not defined let foo = 2; console.log(foo1); // Uncaught ReferenceError: foo1 is not defined let foo1; ES6明确规定，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let,const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 注：“暂时性死区”也意味着typeof不再是一个百分之百安全的操作，因为会使typeof报错。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let和 const的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 let不允许在相同作用域内，重复声明同一个变量。 if (true) { let aa; let aa; // Uncaught SyntaxError: Identifier 'aa' has already been declared } if (true) { var _aa; let _aa; // Uncaught SyntaxError: Identifier '_aa' has already been declared } if (true) { let aa_; var aa_; // Uncaught SyntaxError: Identifier 'aa_' has already been declared } 全局变量 vs 全局对象的属性 ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window/global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。 ES6 中做了严格的区分，使用 var 和 function 声明的全局变量依旧作为全局对象的属性，使用 let, const 命令声明的全局变量不属于全局对象的属性。 let let_test = 'test'; console.log(window.let_test); // undefined console.log(this.let_test); // undefined var var_test = 'test'; console.log(window.var_test); // test console.log(this.var_test); // test const 除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。使用const声明变量的时候，必须同时赋值，否则会报错。并且之后任何试图修改值的操作都会引起错误. const data; //Uncaught SyntaxError: Missing initializer in const declaration if (true) { var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常 ! b = 4; // Uncaught TypeError: Assignment to constant variable. } console.log( a ); // 3 console.log( b ); // Uncaught ReferenceError: b is not defined 注：复合类型const变量保存的是引用。因为复合类型的常量不指向数据，而是指向数据(heap)所在的地址(stack)，所以通过 const 声明的复合类型只能保证其地址引用不变，但不能保证其数据不变。 const arr= [1, 2]; // 修改数据而不修改引用地址，正确执行 arr.push(3); // [1, 2, 3] // 修改 arr 常量所保存的地址的值，报错 arr = []; // Uncaught TypeError: Assignment to constant variable. 简单的使用const无法完成对象的冻结。可以通过Object.freeze()方法实现对对象的冻结。使用Object.freeze()方法返回的对象将不能对其属性进行配置(definedProperty()不可用)同时不能添加新的属性和移除(remove)已有属性。彻底冻结对象时需要递归的对它的对象属性进行冻结。 let obj = { a: 1, b: { b1: 2 } }; obj.b.b1 = 3; console.log(obj.b.b1 ); //3 function freeze(obj){ Object.freeze(obj); Object.values(obj).forEach(function (value,index) { if(typeof value === 'object'){ freeze(value); } }) } freeze(obj); obj.b.b1 = 4; console.log(obj.b.b1); //3 二：执行环境 什么是js的\"执行环境\"？ 执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了各自的行为。每个执行环境中包含这三部分： 变量对象/活动对象 作用域链 this的值 当JavaScript代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。 执行环境的类型 执行环境总共有三种类型 1.全局执行环境：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 2.函数执行环境：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行环境。 3.Eval 函数执行环境： 指的是运行在 eval 函数中的代码，不用很少用而且不建议使用。 执行栈 用于存储在代码执行期间创建的所有执行环境。 JavaScript解释器在浏览器中是单线程的（下面再说进程和线程），这意味着浏览器在同一时间内只执行一个事件，对于其他的事件我们把它们排队在一个称为 执行栈的地方。下表是一个单线程栈的抽象视图。 当浏览器第一次加载你的script，它默认的进了全局执行环境。如果在你的全局代码中你调用了一个函数，那么顺序流就会进入到你调用的函数当中，创建一个新的执行环境并且把这个环境添加到执行栈的顶部。如果在当前的函数中调用了其他函数，同样的事会再次发生。执行流进入内部函数，并且创建一个新的执行环境，把它添加到已经存在的执行栈的顶部。浏览器始终执行当前在栈顶部的执行环境。一旦函数完成了当前的执行环境，它就会被弹出栈的顶部, 把控制权返回给当前执行环境的下个执行环境。下面例子展示了一个递归函数和该程序的执行栈： javascript (function foo(i) { if (i === 3) { return; } else { foo(++i); } }(0)); 这段代码简单地调用了自己三次，由1递增i的值。每次函数foo被调用，一个新的执行环境就会被调用。一旦一个环境完成了执行，它就会被弹出执行栈并且把控制权返回给当前执行环境的下个执行环境直到再次到达全局执行环境。 记住执行栈，有五个关键点 单线程 同步执行 一个全局环境 无限的函数环境 函数被调用就会创建一个新的执行环境，甚至调用自己。 执行环境的详情 一个函数被调用就会创建一个新的执行环境。然而解释器的内部，每次调用执行环境会有两个阶段： 创建阶段 当函数被调用，但是为执行内部代码之前: 创建一个作用域链。 创建变量，函数和参数。 确定this的值。 激活/代码执行阶段 赋值，引用函数，解释/执行代码。 这可能意味着每个执行环境在概念上作为一个对象并带有三个属性executionContextObj = { scopeChain: { /* variableObject + all parent execution context's variableObject */ }, //作用域链：{变量对象＋所有父执行环境的变量对象} variableObject: { /* function arguments / parameters, inner variable and function declarations */ }, //变量对象:{函数形参＋内部的变量＋函数声明(但不包含表达式)} this: {} } 活动／变量 对象(AO/VO) 当函数被调用，executionContextObj就被创建，该对象在实际函数执行前就已创建。这就是已知的第一个阶段创建阶段.在第一阶段，解释器创建了executionContextObj对象，通过扫描函数，传递形参，函数声明和局部变量声明。扫描的结果成为了变量对象在executionContextObj中。 这有一个解释器是如何评估代码的伪概述： 找到一些代码来调用函数 在执行函数代码前，创建执行环境 进入创建阶段： 初始化作用域链 创建变量对象: 创建arguments对象，检查环境中的参数，初始化名和值，创建一个参考副本 扫描环境中内的函数声明： 某个函数被发现，在变量对象创建一个属性，它是函数的确切名。它是一个指针在内存中，指向这个函数。 如果这个函数名已存在，这个指针的值将会重写。 扫描环境内的变量声明 某个变量声明被发现，在变量对象中创建一个属性，他是变量的名，初始化它的值为undefined。 如果变量名在变量对象中已存在，什么也不做，继续扫描。 在环境中确定this的值。 激活/代码执行阶段：在当前环境上运行/解释函数代码，并随着代码一行行执行指派变量的值 看下面例子： function foo(i) { var a = 'hello'; var b = function privateB() { }; function c() { } } foo(22); On calling foo(22), the creation stage looks as follows: 在调用foo(22)时，创建阶段像下面这样： fooExecutionContext = { scopeChain: { ... }, variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c() a: undefined, b: undefined }, this: { ... } } 正如你看到的，创建阶段处理了定义属性的名，但是并不把值赋给变量，不包括形参和实参。一旦创建阶段完成,执行流进入函数并且激活/代码执行阶段,在函数执行结束之后，看起来像这样： fooExecutionContext = { scopeChain: { ... }, variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c() a: 'hello', b: pointer to function privateB() }, this: { ... } } **进阶一言** 你可以在网上找到大量的术语来描述JavaScript进阶。解释变量和函数声明被提升到它们函数作用域的顶端。然而，没有一个详细的解释为什么这样， 现在你配备了关于解释器怎么创建活动对象的新知识，这会很明白这是为什么。看看下面例子： ​(function() { console.log(typeof foo); // function pointer console.log(typeof bar); // undefined var foo = 'hello', bar = function() { return 'world'; }; function foo() { return 'hello'; } }());​ ``` 现在我们能解答的问题有： 为什么在声明foo之前我们就可以调用? 如果我们按照创建阶段进行，我们知道变量在激活/执行阶段之前已经被创建了。因此，在函数流开始执行，foo已经在活动对象中被定义了。 foo被声明了两次, 为什么foo展现出来的是functiton，而不是undefined或者string 我们从创建阶段知道,尽管foo被声明了两次，函数在活动对象中是在变量之前被创建的，并且如果属性名在活动对象已经存在,我们会简单地绕过这个声明。 所以，引用函数foo（）是在活动对象上第一次被创建的， 当我们解释到 var foo的时候，我们发现属性名foo已经存在，所以代码不会做任何处理，只是继续进行 为什么bar是undefined？ bar确实是一个变量，并且值是一个函数。我们知道变量是在创建阶段被创建的，但是它们的值被初始化为undefined。 事件循环 可以看看这篇 事件循环机制： 上面讲了JS引擎线程会维护一个执行栈，执行栈中的所有任务从顶向下同步执行并出栈； 但当遇到一些需要异步执行的任务，如ajax、setTimeout等时，会立即返回函数，然后将异步操作交给浏览器内核中的其他模块处理（如timer、network、DOM Binding模块），接着主线程继续往下执行 栈中的任务。 当上面说的异步操作完成后如ajax接受完响应、setTimeout到达指定延时；这些任务 即回调函数会被放入到任务队列中。一般不同的异步任务的回调函数会放入不同的任务队列之中。（分为宏任务和微任务；优先执行微任务队列） 只有当执行栈为空时，执行引擎才会去看任务队列有无可执行的任务；如果有，就取一个放入到执行栈中执行。执行完后，执行栈为空，便又去检查任务队列。 不断地循环重复上述过程的机制，就是“事件循环(event loop)机制”。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-07 13:19:25 "},"Javascript/基础1.3：面向对象之理解对象.html":{"url":"Javascript/基础1.3：面向对象之理解对象.html","title":"基础1.3：面向对象之理解对象 ✔","keywords":"","body":"基础1.3：面向对象之理解对象 一.理解对象属性  1. 属性类型  2. 数据属性  3. 访问器属性 二.多个属性 三.读取属性的特性 理解对象属性 属性类型 首先理解特性与属性的关系? 特性是内部值，描述了属性的特征，ECMA-262第五版把特性放在两对方括号中 数据属性 包含一个数据值的位置，这个位置可以读取和写入值，数据属性有4个描述其行为的特性。 [[Configurable]] 能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为访问器属性。直接在对象上定义的属性默认为true。 [[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。 [[Writeable]] 能否修改属性的值 直接在对象上定义的属性默认为true。 [[Value]] 包含这个属性的数据值，这个特性默认为undefined。 Object.defineProperty()方法 要修改这四个，默认属性必须使用这个方法 这个方法接受三个参数（\"属性所在的对象\"，\"属性的名字\"，描述符对象），其中描述符对象属性必须是上面四个的一个或多个。可以修改对应的特性值。 访问器属性 它不包含数据值，包含getter和setter(这两个 不是必须的)，在读取访问器属性时会调用getter函数，在写入访问器属性时会调用setter函数并传入新值，负责处理数据。 [[Configurable]] 能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为数据属性。直接在对象上定义的属性默认为true。 [[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。 [[Get]] 读取属性时调用的函数，默认undefined。 [[Value]] 设置属性时调用的函数，默认undefined。var book = { _year: 2004, edition: 1 }; Object.defineProperty(book, \"year\", { get: function(){ return this._year; }, set: function(newValue){ if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } }); book.year = 2005; alert(book.edition); //2 以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition._year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此， 把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方 式，即设置一个属性的值会导致其他属性发生变化。 多个属性 Object.defineProperties()方法 。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应。例如： var book = {}; Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 }, year: { get: function(){ return this._year; }, set: function(newValue){ if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); 以上代码在 book对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。 最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。 支持 Object.defineProperties()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 读取属性的特性 Object.getOwnPropertyDescriptor() 可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value。例如： var book = {}; Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 }, year: { get: function(){ return this._year; }, set: function(newValue){ if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\"); alert(descriptor.value); //2004 alert(descriptor.configurable); //false alert(typeof descriptor.get); //\"undefined\" var descriptor = Object.getOwnPropertyDescriptor(book, \"year\"); alert(descriptor.value); //undefined alert(descriptor.enumerable); //false alert(typeof descriptor.get); //\"function\" 对于数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined。 对于访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter 函数的指针。 在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor()方法。支持这个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 总结：本节应该知道以下三点： 属性类型。 定义多个属性 读取属性特性 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-15 22:45:37 "},"Javascript/基础1.4：面向对象之创建对象的八种模式.html":{"url":"Javascript/基础1.4：面向对象之创建对象的八种模式.html","title":"基础1.4：面向对象之创建对象的八种模式 ✔","keywords":"","body":"创建对象八种模式 1.工厂模式 2.构造函数模式 3.原型模式 4.组合使用构造函数模式和原型模式(最佳) 5.动态原型模式 6.寄生构造函数模式（和工厂模式差不多） 7.稳妥构造函数模式（遵循与寄生构造函数类似的模式） 8.class的extend 工厂模式 1.工厂模式 考虑到在 ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示： 　　function createPerson(name,age,job){ 　　　　var o = new Object(); 　　　　o.name = name; 　　　　o.age = age; 　　　　o.job = job; 　　　　o.sayName = function(){ 　　　　　　alert(this.name); 　　　　} 　　　　return o; 　　} 　　var person1 = createPerson('Grey',27,'Doctor'); 函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建\\多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型？）。 什么是对象类型？ JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。 1 内部对象 js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。 其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。 2 宿主对象 宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度。 浏览器对象有很多，如Window和Document等等。 3 自定义对象 顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充。 优点：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 缺点：工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例. 构造函数模式 二.构造函数模式 function Person(name,age,job){ 　　　　this.name = name; 　　　　this.age = age; 　　　　this.job = job; 　　　　this.sayName = function(){ 　　　　　　alert(this.name); 　　　　} 　　} 　　var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); 　　var person2 = new Person('Grey',27,'Doctor'); 不同： 1 没有显式地创建对象 2 直接将属性和方法赋给了 this 对象 3 没有 return 语句 经历的步骤 (1) 创建一个新对象； (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； (3) 执行构造函数中的代码（为这个新对象添加属性）； (4) 返回新对象。 person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person，如下所示。 alert(person1.constructor == Person); //true alert(person2.constructor == Person); //true 对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person的实例，这一点通过 instanceof 操作符可以得到验证。 alert(person1 instanceof Object); //true alert(person1 instanceof Person); //true alert(person2 instanceof Object); //true alert(person2 instanceof Person); //true 优点：实例标识为一种特定的类型，即知道person1（person2）是Person对象的实例 弊端：也就是说相同的Person实例都有不同Function的实例，造成作用域链和标识符解析不同。如： alert(person1.sayName == person2.sayName); //false 三.原型模式 prototype（原型）属性：我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); person1.sayName(); //\"Nicholas\" var person2 = new Person(); person2.sayName(); //\"Nicholas\" alert(person1.sayName == person2.sayName); //true 与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，必须先理解 ECMAScript 中原型对象的性质。 1. 理解原型对象? 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从 Object继承而来的。m 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。 虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 isPrototypeOf(): 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之 间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象 （Person.prototype），那么这个方法就返回 true，如下所示： alert(Person.prototype.isPrototypeOf(person1)); //true alert(Person.prototype.isPrototypeOf(person2)); //true ES5:Object.getPrototypeOf() ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如： alert(Object.getPrototypeOf(person1) == Person.prototype); //true alert(Object.getPrototypeOf(person1).name); //\"Nicholas\" 这里的第一行代码只是确定 Object.getPrototypeOf()返回的对象实际就是这个对象的原型。 第二行代码取得了原型对象中 name 属性的值，也就是\"Nicholas\"。使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型 查找对象属性的过程 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值.这正是多个对象实例共享原型所保存的属性和方法的基本原理。 注意：前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问 前面的构造函数模式说person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person 问题这个constructor属性到底是在实例中还是在构造函数中？ 尝试解答 alert(person1.hasOwnProperty(\"constructor\")); //false 以上说明person1的constructor（构造函数）属性不是实例属性 （1）.通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值（2）.如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。（3）.修改后的例子中，我们使用 delete 操作符删除了 person1.name，之前它保存的\"Greg\" 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.name = \"Greg\"; alert(person1.name); //\"Greg\"——来自实例 alert(person2.name); //\"Nicholas\"——来自原型 delete person1.name; alert(person1.name); //\"Nicholas\"——来自原型 hasOwnProperty()方法 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); alert(person1.hasOwnProperty(\"name\")); //false person1.name = \"Greg\"; alert(person1.name); //\"Greg\"——来自实例 alert(person1.hasOwnProperty(\"name\")); //true alert(person2.name); //\"Nicholas\"——来自原型 alert(person2.hasOwnProperty(\"name\")); //false delete person1.name; alert(person1.name); //\"Nicholas\"——来自原型 alert(person1.hasOwnProperty(\"name\")); //false ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属 性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。 2. 原型与 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在通 过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。看一看下面的例子。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); alert(person1.hasOwnProperty(\"name\")); //false alert(\"name\" in person1); //true person1.name = \"Greg\"; alert(person1.name); //\"Greg\" ——来自实例 alert(person1.hasOwnProperty(\"name\")); //true alert(\"name\" in person1); //true alert(person2.name); //\"Nicholas\" ——来自原型 alert(person2.hasOwnProperty(\"name\")); //false alert(\"name\" in person2); //true delete person1.name; alert(person1.name); //\"Nicholas\" ——来自原型 alert(person1.hasOwnProperty(\"name\")); //false alert(\"name\" in person1); //true 无论该属性存在于实例中还是存在于原型中。 同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于 原型中，如下所示。 function hasPrototypeProperty(object, name){ return !object.hasOwnProperty(name) && (name in object); } 由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于 实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确 定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty()的用法。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person = new Person(); alert(hasPrototypeProperty(person, \"name\")); //true person.name = \"Greg\"; alert(hasPrototypeProperty(person, \"name\")); //false 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中 既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了(重写或其他)原型中不可枚举属性（即将 [[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所 有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。 IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。 例如： var o = { toString : function(){ return \"My Object\"; } }; for (var prop in o){ if (prop == \"toString\"){ alert(\"Found toString\"); //在 IE 中不会显示 } } 这里的对象 o 定义了 一个名为 toString()的方法，该方法屏蔽了原型中（不可枚举）的 toString()方法。在 IE 中，由 于其实现认为原型的 toString()方法被打上了值为 false 的[[Enumerable]]标记，因此应该跳过 该属性，结果我们就不会看到警告框。该 bug 会影响默认不可枚举的所有属性和方法，包括： hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和 valueOf()。 ECMAScript 5 也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不 是所有浏览器都照此实现。 Object.keys() 这个方法可以取得对象上所有可枚举的实例属性， 接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如： function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var keys = Object.keys(Person.prototype); alert(keys); //\"name,age,job,sayName\" var p1 = new Person(); p1.name = \"Rob\"; p1.age = 31; var p1keys = Object.keys(p1); alert(p1keys); //\"name,age 变量 keys 中将保存一个数组，数组中是字符串\"name\"、\"age\"、\"job\"和\"sayName\"。这 个顺序也是它们在 for-in 循环中出现的顺序。如果是通过 Person 的实例调用，则 Object.keys() 返回的数组只包含\"name\"和\"age\"这两个实例属性。 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。 var keys = Object.getOwnPropertyNames(Person.prototype); alert(keys); //\"constructor,name,age,job,sayName\" 注意结果中包含了不可枚举的 constructor 属性。Object.keys()和 Object.getOwnProperty￾Names()方法都可以用来替代 for-in 循环。支持这两个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 3. 更简单的原型语法 每添加一个属性和方法就要敲一遍 Person.prototype。为减少 不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的 对象字面量来重写整个原型对象，如下面的例子所示。 function Person(){ } Person.prototype = { name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () { alert(this.name); } }; 将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。 最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一 个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在 这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新 对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了，如下所示。 var friend = new Person(); alert(friend instanceof Object); //true alert(friend instanceof Person); //true alert(friend.constructor == Person); //false alert(friend.constructor == Object); //true 解决方法： 在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则 等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设 置回适当的值。 function Person(){ } Person.prototype = { constructor : Person, name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () { alert(this.name); } }; 又有个问题： 以上代码特意包含了一个 constructor 属性，并将它的值设置为 Person，从而确保了通过该属 性能够访问到适当的值。 注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。默认 情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引 擎，可以试一试 Object.defineProperty()。 function Person(){ } Person.prototype = { name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () { alert(this.name); } }; //重设构造函数，只适用于 ECMAScript 5 兼容的浏览器 Object.defineProperty(Person.prototype, \"constructor\", { enumerable: false, value: Person }); 4. 原型的动态性 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。 var friend = new Person(); Person.prototype.sayHi = function(){ alert(\"hi\"); }; friend.sayHi(); //\"hi\"（没有问题！） 以上代码先创建了 Person 的一个实例，并将其保存在 person 中。然后，下一条语句在 Person. prototype 中添加了一个方法 sayHi()。即使 person 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi() 时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存 在那里的函数。 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重 写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。 function Person(){ } var friend = new Person(); Person.prototype = { constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () { alert(this.name); } }; friend.sayName(); //error 在这个例子中，我们先创建了 Person 的一个实例，然后又重写了其原型对象。然后在调用 friend.sayName()时发生了错误，因为 friend 指向的原型中不包含以该名字命名的属性。图 6-3 展示了这个过程的内幕。 从图 6-3 可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它 们引用的仍然是最初的原型。 5. 原生对象的原型 原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式 创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。 例如，在 Array.prototype 中可以找到 sort()方法，而在 String.prototype 中可以找到 substring()方法，如下所示。 alert(typeof Array.prototype.sort); //\"function\" alert(typeof String.prototype.substring); //\"function\" 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自 定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型 String 添加了一个名为 startsWith()的方法。 String.prototype.startsWith = function (text) { return this.indexOf(text) == 0; }; var msg = \"Hello world!\"; alert(msg.startsWith(\"Hello\")); //true 这里新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。既然方法被 添加给了 String.prototype，那么当前环境中的所有字符串就都可以调用它。由于 msg 是字符串， 而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。 缺点6. 原型对象的问题 原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。 function Person(){ } Person.prototype = { constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", friends : [\"Shelby\", \"Court\"], sayName : function () { alert(this.name); } }; var person1 = new Person(); var person2 = new Person(); person1.friends.push(\"Van\"); alert(person1.friends); //\"Shelby,Court,Van\" alert(person2.friends); //\"Shelby,Court,Van\" alert(person1.friends === person2.friends); //true 假如我们的初衷就是像这样 在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部 属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。 四.组合使用构造函数模式和原型模式 组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; } Person.prototype = { constructor : Person, sayName : function(){ alert(this.name); } } var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); var person2 = new Person(\"Greg\", 27, \"Doctor\"); person1.friends.push(\"Van\"); alert(person1.friends); //\"Shelby,Count,Van\" alert(person2.friends); //\"Shelby,Count\" alert(person1.friends === person2.friends); //false alert(person1.sayName === person2.sayName); //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组。 这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自 定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 五. 动态原型模式 有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原 型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数 中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。 function Person(name, age, job){ //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\"){ Person.prototype.sayName = function(){ alert(this.name); }; } } var friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); 注意构造函数代码中加粗的部分。这里只在 sayName()方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可 以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆 if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使 用 instanceof 操作符确定它的类型。 使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果 在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 六.寄生构造函数模式（和工厂模式差不多） 通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式 的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但 从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。 function Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); //\"Nicholas\" 在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返 回了这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实 是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。 这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。 function SpecialArray(){ //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments); //添加方法 values.toPipedString = function(){ return this.join(\"|\"); }; //返回数组 return values; } var colors = new SpecialArray(\"red\", \"blue\", \"green\"); alert(colors.toPipedString()); //\"red|blue|green\" 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。 七.稳妥构造函数模式（遵循与寄生构造函数类似的模式） 道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这 个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在 一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的 实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的 Person 构造函数重写如下。 function Person(name, age, job){ //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function(){ alert(name); }; //返回对象 return o; } 注意，在以这种模式创建的对象中，除了使用 sayName()方法之外，没有其他办法访问 name 的值。可以像下面使用稳妥的 Person 构造函数。 var friend = Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); //\"Nicholas\" 这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName()方法外，没有别的方式可 以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传 入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环 境——例如，ADsafe（www.adsafe.org）和 Caja（http://code.google.com/p/google-caja/）提供的环境—— 下使用。 与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。 八.ES6类继承extends extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。 class Rectangle { // constructor constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea() } // Method calcArea() { return this.height * this.width; } } const rectangle = new Rectangle(10, 20); console.log(rectangle.area); // 输出 200 // 继承 class Square extends Rectangle { constructor(length) { super(length, length); // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 this.name = 'Square'; } get area() { return this.height * this.width; } } const square = new Square(10); console.log(square.area); // 输出 100 extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样 function _inherits(subType, superType) { // 创建对象，创建父类原型的一个副本 // 增强对象，弥补因重写原型而失去的默认的constructor 属性 // 指定对象，将新创建的对象赋值给子类的原型 subType.prototype = Object.create(superType && superType.prototype, { constructor: { value: subType, enumerable: false, writable: true, configurable: true } }); if (superType) { Object.setPrototypeOf ? Object.setPrototypeOf(subType, superType) : subType.__proto__ = superType; } } 1. 函数声明和类声明的区别 函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。 let p = new Rectangle(); // ReferenceError class Rectangle {} 2. ES5继承和ES6继承的区别 ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）. ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-15 23:10:03 "},"Javascript/基础1.5：面向对象之继承的的八种方式.html":{"url":"Javascript/基础1.5：面向对象之继承的的八种方式.html","title":"基础1.5：面向对象之继承的的八种方式 ✔","keywords":"","body":" title: 基础1.5.：面向对象之继承的的八种方式 categories: \"基础1.5.：面向对象之继承的的八种方式\" tags: JavaScript 基础 八种方式： 1 .原型链继承 2 .借用构造函数继承 3 .组合继承 4 .原型式继承 5 .寄生式继承 6 .寄生组合式继承(最佳方式) 7 .混入方式继承多个对象 8 .ES6类继承extends 一.原型链继承 基本思想： 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1.1构造函数、原型和实例的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。我们让原型对象等于另一个类型的实例,此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进,就构成了实例与原型的链条。这就是所谓原型链的基本概念。 function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function (){ return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); //true 1.2搜索机制 上一节中说到，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在 通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用 instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype； 3）搜索supertype.prototype, 1.3确定原型和实例的关系两种方式 alert(instance instanceof Object); //true alert(instance instanceof SuperType); //true alert(instance instanceof SubType); //true 由于原型链的关系，我们可以说 instance 是 Object、SuperType 或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了 true。 第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。 alert(Object.prototype.isPrototypeOf(instance)); //true alert(SuperType.prototype.isPrototypeOf(instance)); //true alert(SubType.prototype.isPrototypeOf(instance)); //true 1.4 谨慎地定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎 样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。 function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承了 SuperType SubType.prototype = new SuperType(); //添加新方法 SubType.prototype.getSubValue = function (){ return this.subproperty; }; //重写超类型中的方法 SubType.prototype.getSuperValue = function (){ return false; }; var instance = new SubType(); alert(instance.getSuperValue()); //false 1.5 缺点(主要两方面) 最主要的问题来自包含引 用类型值的原型。上一节说过包含引用类型值的原型属性会被所有实例共享；而 这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。function SuperType(){ this.colors = [\"red\", \"blue\", \"green\"]; } function SubType(){ } //继承了 SuperType SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green,black\" 当 SubType 通过原型链继承了 SuperType 之后，SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自 己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么 呢？结果是 SubType 的所有实例都会共享这一个 colors 属性。 第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上， 应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上 前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 二.借用构造函数 解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数,即在子类型构造函数的内部调用超类型构造函数。因为，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和call()方法也可以在（将来）新创建的对象上执行构造函数 function SuperType(){ this.colors = [\"red\", \"blue\", \"green\"]; } function SubType(){ //继承了 SuperType SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green\" 新创建的 SubType 实例的环境下调用了 SuperType 构造函数。 这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。 2.1. 传递参数 相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。 function SuperType(name){ this.name = name; } function SubType(){ //继承了 SuperType，同时还传递了参数 SuperType.call(this, \"Nicholas\"); //实例属性 this.age = 29; } var instance = new SubType(); alert(instance.name); //\"Nicholas\"; alert(instance.age); //29 以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造 函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。 2.2. 缺点 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现复用，每个子类都有父类实例函数的副本，影响性能 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 三 组合继承 是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ //继承属性 // 第二次调用SuperType() SuperType.call(this, name); this.age = age; } // 继承方法 // 构建原型链 // 第一次调用SuperType() SubType.prototype = new SuperType(); // 重写SubType.prototype的constructor属性，指向自己的构造函数SubType SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){ alert(this.age); }; var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" instance1.sayName(); //\"Nicholas\"; instance1.sayAge(); //29 var instance2 = new SubType(\"Greg\", 27); alert(instance2.colors); //\"red,blue,green\" instance2.sayName(); //\"Greg\"; instance2.sayAge(); //27 缺点： 第一次调用SuperType()：给SubType.prototype写入两个属性name，color。 第二次调用SuperType()：给instance1写入两个属性name，color。 实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 四 原型式继承 是借助原型可以基于已有的对象创建新对象 function object(o){ function F(){} F.prototype = o; return new F(); } 在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。 var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = object(person); anotherPerson.name = \"Greg\"; anotherPerson.friends.push(\"Rob\"); var yetAnotherPerson = object(person); yetAnotherPerson.name = \"Linda\"; yetAnotherPerson.friends.push(\"Barbie\"); alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" 这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到 object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends 不仅属于 person 所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。es5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。 var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = Object.create(person); anotherPerson.name = \"Greg\"; anotherPerson.friends.push(\"Rob\"); var yetAnotherPerson = Object.create(person); yetAnotherPerson.name = \"Linda\"; yetAnotherPerson.friends.push(\"Barbie\"); alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" Object.create()方法的第二个参数与Object.defineProperties()(理解对象的定义多个属性)方法的第二个参数格式相 同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属 性。例如： var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = Object.create(person, { name: { value: \"Greg\" } }); alert(anotherPerson.name); //\"Greg\" 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的 缺点： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数五 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 function createAnother(original){ var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function(){ //以某种方式来增强这个对象 alert(\"hi\"); }; return clone; //返回这个对象 } var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = createAnother(person); anotherPerson.sayHi(); //\"hi\" 这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。 缺点（同原型式继承）： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数六 寄生组合式继承 结合借用构造函数传递参数和寄生模式实现继承 背景 前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ SuperType.call(this, name); //第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); //第一次调用 SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){ alert(this.age); }; 加粗字体的行中是调用 SuperType 构造函数的代码。在第一次调用 SuperType 构造函数时， SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过 现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这 一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属 性。图 6-6 展示了上述过程。 有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。（上面有图说明这就是调 用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型。寄生组合式继承的基本模式如下所示。 function inheritPrototype(subType, superType){ var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本 prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性 subType.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型 } // 父类初始化实例属性和原型属性 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; // 借用构造函数传递增强子类实例属性（支持传参和避免篡改） function SubType(name, age){ SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); // 新增子类原型属性 SubType.prototype.sayAge = function(){ alert(this.age); } var instance1 = new SubType(\"xyc\", 23); var instance2 = new SubType(\"lxy\", 23); instance1.colors.push(\"2\"); // [\"red\", \"blue\", \"green\", \"2\"] instance1.colors.push(\"3\"); // [\"red\", \"blue\", \"green\", \"3\"] 这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf() 这是最成熟的方法，也是现在库实现的方法 七 混入方式继承多个对象 function MyClass() { SuperClass.call(this); OtherSuperClass.call(this); } // 继承一个类 MyClass.prototype = Object.create(SuperClass.prototype); // 混合其它 Object.assign(MyClass.prototype, OtherSuperClass.prototype); // 重新指定constructor MyClass.prototype.constructor = MyClass; MyClass.prototype.myMethod = function() { // do something }; Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。 八、ES6类继承extends 本质仍然是构造函数+原型链的组合式继承。 class A { constructor(name, age) { this.name = name; this.age = age; } getName() { return this.name; } } class B extends A { constructor(name, age) { super(name, age); this.job = \"IT\"; } getJob() { return this.job; } getNameAndJob() { return super.getName() + this.job; } } var b = new B(\"Tom\", 20); console.log(b.name); console.log(b.age); console.log(b.getName()); console.log(b.getJob()); console.log(b.getNameAndJob()); //输出：Tom，20，Tom，IT，TomIT extends关键字 上面代码定义了一个B类（class），该类通过extends关键字，继承了A类的所有属性和方法。A类中的所有方法默认是添加到B的原型上，所以extends继承的实质仍然是原型链。 console.log(\"constructor\" in b); console.log(\"getName\" in b); console.log(b.hasOwnProperty(\"getName\")); console.log(b.hasOwnProperty(\"constructor\")); //输出：true，true，false，false super关键字 super这个关键字，既可以当作函数使用，也可以当作对象使用。当作函数使用时，super代表父类的构造函数，并在子类中执行Parent.apply(this)，从而将父类实例对象的属性和方法，添加到子类的this上面。以下三点需要特别注意： 1、子类必须在constructor方法中调用super方法，如果子类没有定义constructor方法，constructor方法以及其内部的super方法会被默认添加。 class A { constructor(name, age) { this.name = name; this.age = age; } getName() { return this.name; } } class B extends A {} var b = new B(\"Tom\", 20); console.log(b.name); console.log(b.age); console.log(b.getName()); console.log(b.hasOwnProperty(\"name\")); //输出：Tom，20，Tom，true 2、在子类的constructor方法中，只有调用super之后，才可以使用this关键字，否则会报错。 class A { constructor(name, age) { this.name = name; this.age = age; } } class B extends A { constructor(name, age) { this.job = \"IT\"; super(name, age); } } var b = new B(\"Tom\", 20) //输出：报错 3、super()只能用在子类的constructor方法之中，用在其他地方就会报错。 测试代码： class A { constructor(name, age) { this.name = name; this.age = age; } } class B extends A { toStr(name, age) { super(name, age) } } var b = new B(\"Tom\", 20) //输出：报错 super作为对象时，在子类中指向父类的原型对象。 class A { constructor(name, age) { this.name = name; this.age = age; } getName() { console.log(this.name); } } A.prototype.n = 2; class B extends A { constructor(name, age) { super(name, age); } toStr() { return super.n; } activeGetName() { super.getName(); } } var b = new B(\"Tom\", 20); console.log(b.toStr()); console.log(b.activeGetName()); //输出：2，Tom 静态方法的继承 在一个方法前加上关键字static，就表示该方法不会被实例继承，但是父类的静态方法，会被子类继承。 例子： class A { static say() { console.log(\"hello\"); } } class B extends A {} console.log(B.say()); //输出：hello 也可以使用super在子类的静态方法中调用父类的静态方法。super在静态方法中指向父类本身，而不是父类的原型对象。 class A { static say() { console.log(\"hello\"); } } class B extends A { static toStr() { super.say(); } } var b = new B(); console.log(B.toStr()); //输出：hello 也可以使用super在子类的静态方法中调用父类的静态方法。super在静态方法中指向父类本身，而不是父类的原型对象。 class A { static say() { console.log(\"hello\"); } } class B extends A { static toStr() { super.say(); } } var b = new B(); console.log(B.toStr()); //输出：hello 继承表达式的类 类不但可以继承自其他类，也可以继承表达式。只要表达式可以被解析为一个函数并且通过new关键字可以创建新的实例对象即可。 let Obj = function(name) { this.name = name; } Obj.prototype.getName = function() { console.log(this.name); } class Person extends Obj { constructor(name, age) { super(name); this.age = age; } } const p = new Person(\"Tom\", 19); console.log(p.name); //输出：Tom console.log(p.age); //输出：19 p.getName(); //输出：Tom 继承函数返回结果 let fn = function() { return class Person { constructor(name) { return { name } } } } class SomeOne extends fn() { constructor(name) { super(name); } } let p = new SomeOne(\"Tom\"); console.log(p.name); //输出：Tom New.target 我们知道，函数内部有一个new.target对象用于判断函数是否通过new关键字调用。类构造函数也可以通过new.target来确定类的调用形式。 例子： class Obj { //new Obj()时，new.target的值为 Obj constructor() { if (new.target === Obj) { console.log(\"不可以直接调用基类！\"); } } fn() { console.log(this.name); } } class Person extends Obj { //new Person(\"Tom\")时，new.target的值为 Person constructor(name) { super(); this.name = name; } } let p1 = new Person(\"Tom\"); p1.fn(); //输出：Tom let p2 = new Obj(); //输出：不可以直接调用基类！ *因为类必须通过new关键字调用，所以在类的构造函数中new.target的值永远不会是undefined。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-10 10:19:11 "},"Javascript/基础2.1：原型和原型链（继承）.html":{"url":"Javascript/基础2.1：原型和原型链（继承）.html","title":"基础2.1：原型和原型链(继承) ✔","keywords":"","body":" 2.1原型与原型链(继承) https://github.com/mqyqingfeng/Blog/issues/2  1. 原型  2. 原型链  3. 继承 题目 1 var A = function() {}; A.prototype.n = 1; var b = new A(); A.prototype = { n: 2, m: 3 } var c = new A(); console.log(b.n); console.log(b.m); console.log(c.n); console.log(c.m); 请写出上面编程的输出结果是什么？ 题目 2 var F = function() {}; Object.prototype.a = function() { console.log('a'); }; Function.prototype.b = function() { console.log('b'); } var f = new F(); f.a(); f.b(); F.a(); F.b(); 请写出上面编程的输出结果是什么？ 题目 3 function Person(name) { this.name = name } let p = new Person('Tom'); 问题1：1. p.proto等于什么？ 问题2：Person.proto等于什么？ 题目 4 var foo = {}, F = function(){}; Object.prototype.a = 'value a'; Function.prototype.b = 'value b'; console.log(foo.a); console.log(foo.b); console.log(F.a); console.log(F.b); 请写出上面编程的输出结果是什么？ 解题 题目 1 答案： b.n -> 1 b.m -> undefined; c.n -> 2; c.m -> 3; 题目 2 答案： f.a() -> a f.b() -> f.b is not a function F.a() -> a F.b() -> b 题目 3 答案 答案1：Person.prototype 答案2：Function.prototype 题目 4 答案 foo.a => value a foo.b => undefined F.a => value a F.b => value b 如果小伙伴们查看完答案，仍不知道怎么回事，那么，我们扩展下自己的知识点，畅快了解更多地知识吧！ 前因后果 原因 OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承， 所以 其实现 继承 主要是依靠原型链 继续 原型链是用来实现继承的，因為沒有類的結構，用prototype實現有類語言的繼承特性(創建構造器，指向對象)原型的作用，则是实现对象的继承 1. 原型 每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个proto，可称为隐式原型。 每个对象都有一个proto属性，指向创建该对象的函数的prototype。 函数也是一种对象，函数也有proto，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的proto指向了自身的Prototype。 自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，Function.proto指向Function.prototype 函数.Object.prototype确实一个特例——它的proto指向的是null，切记切记！ 原型 传送门 2. 原型链 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 原型链是实现继承的\b主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 概念： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例\b都包含一个指向原型对象的指针。假如原型对象是另一个\b构造函数的实例，那么原型对象也包含一个指向另一个原型的指针，如此层层递进，就叫原型链。 简而言之：因为没有类的结构，用prototype实现有类语言的继承特性（创建构造器，指向对象） 注：所有引用类型都默认继承自 object ，object 的原型为null。 确定原型与实例之间的关系：instanceof isPrototypeOf 一张图总结： 3. 继承 八种继承的方式传送门 使用原型继承的缺陷 缺陷一：引用类型值的原型属性会被所有实例共享 举个例： function SuperType() { this.colors = [\"red\", \"blue\", \"green\"]; } function SubType() { } SubType.prototype = new SuperType(); var instance1 = new SuperType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green,black\" 例子中，SubType（子类）通过原型链继承了SuperType，SubType.prototype就变成了SuperType（超类，也就是我们所说的父类）的一个实例。也就是说，SubType.prototype中会有一个colors的数组，SubType的所有实例都将共享colors这个数组（引用类型值）。因此只要SubType其中一个实例对colors做了修改，就会影响到其他所有SubType的实例。 缺陷二：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 针对问题二中的第一句话，“在创建子类型的实例时，不能向超类型的构造函数中传递参数”，我举个例子： function SuperType(name) { // 超类型 this.name = name; } function SubType(age) { //子类型 this.age = age; } SubType.prototype = new SuperType(\"Allan\"); var instance1 = new SubType(10); console.log(instance1.name); // Allan console.log(instance1.age); // 10 var instance2 = new SubType(20); console.log(instance2.name); // 10 上面代码中构造函数SuperType完全等价于下面声明的形式。 function SuperType() { name = \"Allan\"; } instance1通过原型链继承的name属性值，在instance1创建之前就已经被确定为Allan了。无论怎么new SuperType()都更改不了name属性值，这就是所谓的“在创建子类型的实例时，不能向超类型的构造函数中传递参数”。 针对问题二中的第二句话，“实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”,这句话应该怎么理解？ 其实在上面的代码中，我在创建SuperType实例的时候，向它传递了一个”Allan”的字符串参数。但是我们看到后面所有的SubType的实例，无论是instance1还是instance2的name属性都是Allan，也就是说SuperType创建实例时传递的参数，影响了后面所有SubType的实例。这就是所谓“没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”。 js通过沿着作用域链还是原型链查找变量? 首先，要分清作用域链与原型链的区别，简单来说 作用域链是相对于函数的，原型链是相对于对象的 js中访问变量有多种方式 直接通过标识符访问 通过 . 或 [] 访问对象中的标识符 猜想访问方式不同，导致了查找的方式不同： 直接通过标识符访问，访问的可能是函数中的标识符，也可能是全局对象（浏览器中是 window）的标识符，也就是说，可能沿着作用域链也可能沿着原型链访问 通过 . 或 [] 访问对象中的标识符，js会沿着原型链查找 对于第二点，以下的小测试可以证明 Object.prototype.a = 1; a = 2 var o = { a: 3 } function test() { console.log(this.a) } test(); // 2 (1) test.call(o); // 3 (2) delete o.a; test.call(o); // 1 (3) delete a; test(); // 1 (4) ① 相当于调用 window.test（），this 指向 window，访问的是 window.a； ② 中 this 指向 o，访问的是 o.a； 将全局的 a， 也就是 window.a 和 o.a 删除之后，得到的结果均是 1。 因此，通过 . 或 [] 访问对象中的标识符，js会沿着原型链查找。 第一点，直接通过标识符访问，也就是访问当前执行上下文EC的作用域中的变量，这一过程称为标识符解析，依赖于作用域链。 作用域链Scope其实就是对执行上下文EC中的变量对象VO|AO有序访问的链表 关于作用域链与执行上下文 EC 的关系，请看这里 测试 Object.prototype.a = 1; Window.prototype.a = 4 a = 2 var o = { a: 3 } function test() { console.log(a) } test(); // 2 (1) test.call(o); // 2 (2) delete a; test() // 4 (3) test.call(o); // 4 (4) delete Window.prototype.a test() //1 (6) test.call(o) //1 (6) 把 this.a 改为 a，②的结果就变啦。 ① 和 ② 的执行上下文EC（即 this 的指向）分别为 window 和 o，但作用域链都是 test变量对象 + 全局变量对象。而test变量对象中没有 a，全局变量对象含有 a 。这就说明，在函数中直接通过标识符变量，js会沿着作用域中查找。 有趣的是，当删除了全局变量对象中的 a，再访问 a，浏览器并没有报错，而是输出 4；删除 Window.prototype.a 之后，输出的这是 1. 在 test 中添加一下代码 ： console.log(a === Window.prototype.a) console.log(a === Object.prototype.a) 由结果可知，访问到的a 分别为 Window.prototype 和 Object.prototype 中的变量。 为什么呢？因为在浏览器中，全局变量对象在浏览器中指向 window， window 也是对象，且位于作用域链的末尾；作用域链查找完，仍然找不到，js 就会沿着全局变量对象的原型链查找。 结论 直接通过标识符访问变量，首先沿着作用域链查找每一个变量对象，直到全局变量对象（window）仍没有，就沿着全局变量对象（window）的原型链查找 通过 . 或 [] 访问对象中的标识符，就直接沿着原型链查找 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 00:25:56 "},"Javascript/基础2.2：作用域和作用域链.html":{"url":"Javascript/基础2.2：作用域和作用域链.html","title":"基础2.2：作用域和作用域链 ✔","keywords":"","body":"2.2作用域与作用域链 https://github.com/mqyqingfeng/Blog/issues/3 1.作用域？ 变量a的作用域是什么？一会儿又问：函数a的作用域是什么？变量和函数的作用域分别是啥玩意？ 我们先来看看“作用域”是什么意思，“作用域”拆开来就是“作用”和“域” 作用：访问、操作、调用…… 域：区域、范围、空间…… 作用域: 就是变量和函数的可访问范围，或者说变量或函数起作用的区域。 1.javascript函数的作用域： 函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域。 2.javascript变量的作用域： 在源代码中变量所在的区域，就是这个变量的作用域，变量在这个区域内可以被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量。 简单地理解，JS源代码被函数{ }划分成一块一块的区域，这些区域换个身份就是某函数或某变量的作用域，变量的作用域和函数的作用域在源代码中有可能指的是同一块区域。 javascript除了全局作用域之外，只有函数可以创建的作用域。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 作用域在函数定义时就已经确定了。而不是在函数调用时确定。 一张图总结作用域： 作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。 所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 词法作用域是 作用域的一种工作模型”，作用域有两种工作模型，在JavaScript中的词法作用域是比较主流的一种，另一种动态作用域（比较少的语言在用）。词法作用域是在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了。 2.作用域链 作用域链（Scope Chain）是javascript内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域链 作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式结构，也可理解为是一个对象列表，所以我们称之为作用域链。 定义 当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链。 产生过程 函数在创建的时候同时也会创建一个包含全局变量对象的作用域链，别急，这时候这个链子上只有一个全局变量对象。 下一步，调用函数（不然创建函数干嘛~），此时会有相应的函数执行环境产生，理所当然地会产生一个该执行环境的变量对象（因为每个执行环境都有一个变量对象），那么它就会被当做活动对象被推入作用域链的前端。到这里，一个完整的作用域链产生了，它包含两个变量对象：本地活动对象和全局变量对象。 每个函数在执行时都会有一个执行环境，而每个执行环境中都有相应的变量对象，其实作用域链正是由这些变量对象连接得到。在搜索变量时，会沿着作用域链自下而上进行搜索，如果该变量存在于活动对象中则停止搜索，否则继续向上搜索，直至找到该变量。 原理 作用域链的形成原理，通过1999年的ECMAScript-262-3th第三版来说明作用域链的形成原理，将会介绍执行环境，变量对象和活动对象，arguments对象，作用域链等几个概念。2009年发布了ECMAScript-262-5th第五版，不同的是取消了变量对象和活动对象等概念，引入了词法环境（Lexical Environments）、环境记录（EnviromentRecord）等新的概念，所以两个版本的概念不要混淆了。 几个概念 自由变量 在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量,如下图： 注：自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域” [[scope]]：每个JavaScript函数都是一个对象，对象中有些属性我们可以访问，也有些不可以访问，这些属性仅供JavaScript引擎存取，[[scope]]就是其中的一个,内部属性[[scope]]指向当前的作用域对象，。 [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。 运行期上下文指的是：当函数执行时，创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文会被销毁。也就是在预编译过程的时候所产生的（上一篇文章上所说的AO）。 函数被定义的时候，就已经再[[scope]]上创建了一个GO对象（在[[scope]]上存储了一个Global Object对象，在[[scope]]的第一位），接着函数被执行的时候又在[[scope]]上创建了一个AO对象，此时AO对象会被放在[[scope]]作用域链的顶端，GO对象排在函数自身的AO对象的后面；此时AO对象的变量会覆盖同名的GO对象的变量。函数执行过程中，查找变量的时候是从作用域链的最顶端（第一个对象）开始往后查找，就是说先从自身的AO对象查找，如果没有找到的话再沿着作用域链去GO（未必是GO对象，当函数内还嵌套了其它函数的话，[[scope]]上至少存在3个对象，反正就是会继续往下一个对象查找）对象查找；如果在整个作用域链上都找不到想要的属性的话，会抛出一个引用错误异常（ReferenceError）。 var name = 'globalName'; function funcA() { //当funcA()被调用时，刚进入funcA的执行环境，其作用域链最前端的funA activation object里有name属性，值为undefined。 console.log(name); var name = 'funAName'; console.log(name); console.log(age); } funcA(); 执行环境：函数被调用时会创建一个执行环境和执行环境相应的作用域链 对于每个执行环境，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 函数对象 ​ 在一个函数定义的时候， 会创建一个这个函数对象的[[scope]]属性（内部属性,只有JS引擎可以访问, 但FireFox的几个引擎（SpiderMonkey和Rhino）提供了私有属性parent来访问它)，并将这个[[scope]]属性指向定义它的作用域链上。 在这里的问题中，因为funcA定义在全局环境, 所以此时的[[scope]]只是指向全局活动对象window active object。 变量对象：每个执行环境都有一个表示变量的对象即变量对象，全局环境的变量对象一直存在，而像函数那样的局部环境的变量对象只会在执行的过程中存在 活动对象：在一个函数对象被调用的时候，会创建一个活动对象，首先将该函数的每个形参和实参，都添加为该活动对象的属性和值；将该函数体内显示声明的变量和函数，也添加为该活动的的属性（在刚进入该函数执行环境时，未赋值，所以值为undefined，这个是JS的提前声明机制）。 ​ 然后将这个活动对象做为该函数执行环境的作用域链的最前端，并将这个函数对象的[[scope]]属性里作用域链接入到该函数执行环境作用域链的后端。 在作用域 链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，......直至作 为作用域链终点的全局执行环境。 在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。 var name = 'globalName'; function funcA() { //当funcA()被调用时，刚进入funcA的执行环境，其作用域链最前端的funA activation object里有name属性，值为undefined。 console.log(name); var name = 'funAName'; console.log(name); console.log(age); } funcA(); 延长作用域 延长作用域 有两种方法可以将作用域进行延长: ①、try-catch 语句的catch块 ②、with 语句 两个语句都是在原本的作用域最前端进行添加一个变量对象；例如： var name = \"global\"; function test(){ var name = \"sub\"; with(window){ console.log(name); } } test(); // -- \"global\" 所以检索变量时，会先在最前端的window变量对象中检索；当然，在严格模式下已经禁用了with语句，编程时，最好向后兼容，废弃使用with语句； 什么是with? 首先来看一段代码: function validate_email(field, alerttxt) { with(field) { apos = value.indexOf(\"@\") dotpos = value.lastIndexOf(\".\") if(apos Email: 这个是一个网站教程的例子,相信很多人都会有疑问,里面在with ( )中嵌套了if,这个with()是什么方法?这个with()就是和if 一起用的吗? 其实with()和if()没有关系。 with(obj)作用就是将后面的{}中的语句块中的缺省对象设置为obj，那么在其后面的{}语句块中引用obj的方法或属性时可以省略obj.的输入而直接使用方法或属性的名称。比如： 不用with()时： function validate_email(field,alerttxt){ field.apos=value.indexOf(\"@\") field.dotpos=value.lastIndexOf(\".\") if (field.apos用了with(field)后，上面函数中的field.都可以省略了，减少了输入的工作量。 with对象能够使我们很方便的使用某个对象的一些属性，而不用每次都去写 对象名.属性 的形式，直接使用对象名 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 15:07:45 "},"Javascript/基础2.3：闭包，作用域链理解闭包.html":{"url":"Javascript/基础2.3：闭包，作用域链理解闭包.html","title":"基础2.3：闭包，作用域链理解闭包 ✔","keywords":"","body":"定义 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数， MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。 简洁版：保护一个可重用的局部变量的词法结构 闭包的特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的优点 使一个变量长期驻扎在内存中 避免全局变量的污染 作为私有成员的存在 闭包的缺点 闭包的缺点，更多地是在内存性能的方面。 由于变量长期驻扎在内存中，在复杂程序中可能会出现内存不足，但这也不算非常严重，我们需要在内存使用与开发方式上做好取舍。在不需要的时候清理掉变量 在某些时候（对象与DOM存在互相引用，GC使用引用计数法）会造成内存泄漏，要记得在退出函数前清理变量 window.onload = function() { var elem = document.querySelector('.txt'); // elem的onclick指向了匿名函数，匿名函数的闭包也引用着elem elem.onclick = function() { console.log(this.innerHTML); }; // 清理 elem = null; }; 除此之外，由于闭包中的变量可以在函数外部进行修改（通过暴露出去的接口方法），所有不经意间也内部的变量会被修改，所以也要注意 只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。 1.函数作为返回值 2.函数作为参数传递 fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。 自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点 当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。 核心内容 函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。 第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。 第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。 因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。 ——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图： 第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。 执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。 这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。 使用闭包会增加内容开销！ 第五步，执行完20行就是上下文环境的销毁过程。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:58:14 "},"Javascript/基础2.4：this.html":{"url":"Javascript/基础2.4：this.html","title":"基础2.4：this ✔","keywords":"","body":"this https://blog.csdn.net/lisummit/article/details/80561758 http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html https://www.cnblogs.com/hjson/archive/2019/01/11/10254555.html 先来一道题 var a = 10;//全局变量 值为10 function foo() { console.log(this)//此处this一直指向window, 所以this.a一直是10 console.log(a); //a全局变量 打印10 } (function() {//自执行函数 此处this指代window,自执行函数其实是window对象调用它！函数分普通函数和构造函数普通函数的this指向window，构造函数的this指向它本身，谁调用它this就指向谁！ var a = 20; console.log(this.a)//10 foo();//依然打印10 })(); (function (func) {//自执行函数 此处this指代window var a = 30; console.log(this.a)//10 func();//依然打印10 })(foo) 注意：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。 再一道 var value = 1; var foo = { value: 2, bar: function () { return this.value; } } //示例1 console.log(foo.bar()); //示例2 console.log((foo.bar)()); //示例3 console.log((foo.bar = foo.bar)()); //示例4 console.log((false || foo.bar)()); //示例5 console.log((foo.bar, foo.bar)()); 情况1：构造函数(实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。) 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如： function foo(a) { this.a = a; } var bar = new foo(2); // bar和foo(..)调用中的this进行绑定 console.log( bar.a ); // 2 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个新对象。 这个新对象会被执行[[Prototype]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 使用new来调用foo(..)时，会构造一个新对象并把它（bar）绑定到foo(..)调用中的this。 情况2：函数作为对象的一个属性 如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象 var obj = { x: 10, fn: function() { console.log(this) //obj {x: 10, fn: ƒ} console.log(this.x) //10 } } obj.fn() 注意:如果fn函数不作为obj的一个属性被调用，会是什么结果呢？ var obj = { x: 10, fn: function() { console.log(this) //Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …} console.log(this.x) //undefined } } var fn = obj.fn fn() 如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。 var value = 1 var foo = { value: 2, bar: function() { return this.value } } console.log((foo.bar)()) // 2 情况3：函数用call或者apply调用 当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用看下一节 var obj = { x: 10, } var fn = function() { console.log(this) //obj {x: 10} console.log(this.x) //10 } fn.call(obj) 情况4：全局 以及 调用普通函数 在全局环境下，this永远是window console.log(this === window) //true 普通函数在调用时，其中的this也都是window。 var x = 10 var fn = function() { console.log(this) //window console.log(this.x) //10 } fn() 注意： var obj = { x: 10, fn: function() { function f(){ console.log(this) //window console.log(this.x) //undefined } f() } } obj.fn() 函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。 情况5:箭头函数绑定 箭头函数根本没有自己的this，导致内部的this就是外层代码块的this，是根据外层（函数或者全局）作用域（词法作用域）来决定this。 对于箭头函数的this总结如下： 箭头函数不绑定this，箭头函数中的this相当于普通变量。 箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。 箭头函数的this无法通过bind（直接返回一个新函数，不直接执行），call，apply来直接修改（可以间接修改）。 改变作用域中this的指向可以改变箭头函数的this。 注意： setInterval和setTimeout中传入函数时，函数中的this会指向window对象 var num = 0; function Obj (){ this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(function(){ console.log(this.num); }, 1000) } } var obj = new Obj; obj.getNum();//1　　打印的是obj.num，值为1 obj.getNumLater()//0　　打印的是window.num，值为0 原因：由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致这些代码中包含的 this 关键字会指向 window (或全局)对象。 解决方法 若想要让setTimeout中的this指向正确的值，可以使用以下三种比较常用的方法来使this指向正确的值： 将当前对象的this存为一个变量，定时器内的函数利用闭包来访问这个变量，如下： var num = 0; function Obj (){ var that = this; //将this存为一个变量，此时的this指向obj this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(function(){ console.log(that.num); //利用闭包访问that，that是一个指向obj的指针 }, 1000) } } var obj = new Obj; obj.getNum();//1　　打印的是obj.num，值为1 obj.getNumLater()//1　　打印的是obj.num，值为1 这种方法是将当前对象的引用放在一个变量里，定时器内部的函数来访问到这个变量，自然就可以得到当前的对象。 利用bind()方法 var num = 0; function Obj (){ this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(function(){ console.log(this.num); }.bind(this), 1000) //利用bind()将this绑定到这个函数上 } } var obj = new Obj; obj.getNum();//1　　打印的为obj.num，值为1 obj.getNumLater()//1　　打印的为obj.num，值为1 bind()方法是在Function.prototype上的一个方法，当被绑定函数执行时，bind方法会创建一个新函数，并将第一个参数作为新函数运行时的this。在这个例子中，在调用setTimeout中的函数时，bind方法创建了一个新的函数，并将this传进新的函数，执行的结果也就是正确的了。关于bind方法可参考 MDN bind 箭头函数 var num = 0; function Obj (){ this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(() => { console.log(this.num); }, 1000) //箭头函数中的this总是指向外层调用者，也就是Obj } } var obj = new Obj; obj.getNum();//1　　打印的是obj.num，值为1 obj.getNumLater()//1　　打印的是obj.num，值为1 ES6中的箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj，因此利用箭头函数就可以轻松解决这个问题。 练习 /** * 非严格模式 */ var name = 'window' var person1 = { name: 'person1', show1: function () { console.log(this.name) }, show2: () => console.log(this.name), show3: function () { return function () { console.log(this.name) } }, show4: function () { return () => console.log(this.name) } } var person2 = { name: 'person2' } person1.show1() person1.show1.call(person2) person1.show2() person1.show2.call(person2) person1.show3()() person1.show3().call(person2) person1.show3.call(person2)() person1.show4()() person1.show4().call(person2) person1.show4.call(person2)() 答案 person1.show1() // person1，隐式绑定，this指向调用者 person1 person1.show1.call(person2) // person2，显式绑定，this指向 person2 person1.show2() // window，箭头函数绑定，this指向外层作用域，即全局作用域 person1.show2.call(person2) // window，箭头函数绑定，this指向外层作用域，即全局作用域 person1.show3()() // window，默认绑定，这是一个高阶函数，调用者是window // 类似于`var func = person1.show3()` 执行`func()` person1.show3().call(person2) // person2，显式绑定，this指向 person2 person1.show3.call(person2)() // window，默认绑定，调用者是window person1.show4()() // person1，箭头函数绑定，this指向外层作用域，即person1函数作用域 person1.show4().call(person2) // person1，箭头函数绑定， // this指向外层作用域，即person1函数作用域 person1.show4.call(person2)() // person2 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 19:42:20 "},"Javascript/基础3.1：js内存与内存泄漏.html":{"url":"Javascript/基础3.1：js内存与内存泄漏.html","title":"基础3.1：js内存与内存泄漏 ✔","keywords":"","body":"JS内存和内存泄漏 JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。 内存回收 JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。 局部变量和全局变量的销毁 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。 以Google的V8引擎(js引擎)为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。 V8引擎对堆内存中的JS对象进行分代管理 新生代：存活周期较短的JS对象，如临时变量、字符串等。 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。 垃圾回收算法 对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。 引用计数（现代浏览器不再使用） 标记清除（常用） 引用计数 引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。 // 创建一个对象person，他有两个指向属性age和name的引用 var person = { age: 12, name: 'aaaa' }; person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收 var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收 p = null; //原person对象已经没有引用，很快会被回收 引用计数有一个致命的问题，那就是循环引用 如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。 function cycle() { var o1 = {}; var o2 = {}; o1.a = o2; o2.a = o1; return \"cycle reference!\" } cycle(); cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。 但是IE依旧使用。 var div = document.createElement(\"div\"); div.onclick = function() { console.log(\"click\"); }; 上面的写法很常见，但是上面的例子就是一个循环引用。 变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。 标记清除（常用） 标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。 无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。 所以上面的例子就可以正确被垃圾回收处理了。 所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关： email.message = document.createElement(“div”); displayList.appendChild(email.message); // 稍后从displayList中清除DOM元素 displayList.removeAllChildren(); 上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。 内存泄漏 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak） 内存泄漏识别方法 浏览器方法 打开开发者工具，选择 Memory 在右侧的Select profiling type字段里面勾选 timeline 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。 命令行方法 使用 Node 提供的 process.memoryUsage 方法。 console.log(process.memoryUsage()); // 输出 { rss: 27709440, // resident set size，所有内存占用，包括指令区和堆栈 heapTotal: 5685248, // \"堆\"占用的内存，包括用到的和没用到的 heapUsed: 3449392, // 用到的堆的部分 external: 8772 // V8 引擎内部的 C++ 对象占用的内存 } 判断内存泄漏，以heapUsed字段为准。 WeakMap ES6 新出的两种数据结构：WeakSet 和 WeakMap，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。 const wm = new WeakMap(); const element = document.getElementById('example'); wm.set(element, 'some information'); wm.get(element) // \"some information\" 先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 思考题 var a = {n: 1}; var b = a; a.x = a = {n: 2}; a.x // --> undefined b.x // --> {n: 2} 答案已经写上面了，这道题的关键在于 优先级。.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。 赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2} 四种常见的JS内存泄漏 一. 意外的全局变量 未定义的变量会在全局对象创建一个新变量，如下。 function foo(arg) { bar = \"this is a hidden global variable\"; } 函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。 function foo(arg) { window.bar = \"this is an explicit global variable\"; } 另一个意外的全局变量可能由 this 创建。 function foo() { this.variable = \"potential accidental global\"; } // Foo 调用自己，this 指向了全局对象（window） // 而不是 undefined foo(); 解决方法： 在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。 二. 被遗忘的计时器或回调函数 计时器setInterval代码很常见 var someResource = getData(); setInterval(function() { var node = document.getElementById('Node'); if(node) { // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); } }, 1000); 上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 var element = document.getElementById('button'); function onClick(event) { element.innerHTML = 'text'; } element.addEventListener('click', onClick); 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。 三.脱离 DOM 的引用 如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。 var elements = { button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text') }; function doStuff() { image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML); // 更多逻辑 } function removeButton() { // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById('button')); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 } 如果代码中保存了表格某一个 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 以外的其它节点。实际情况并非如此：此 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。 四.闭包闭包的关键是匿名函数可以访问父级作用域的变量。 var theThing = null; var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) console.log(\"hi\"); }; theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); 每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。 解决方法： 在 replaceThing 的最后添加 originalThing = null 。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 15:00:49 "},"Javascript/高性能渲染十万条数据（DocumentFragment + requestAnimationFrame）.html":{"url":"Javascript/高性能渲染十万条数据（DocumentFragment + requestAnimationFrame）.html","title":"高性能渲染十万条数据（DocumentFragment + requestAnimationFrame） ✔","keywords":"","body":"最粗暴的做法（一次性渲染） // 记录任务开始时间 let now = Date.now(); // 插入十万条数据 const total = 100000; // 获取容器 let ul = document.getElementById('container'); // 将数据插入容器中 for (let i = 0; i { console.log('总运行时间：',Date.now() - now); },0) // print: JS运行时间： 187 // print: 总运行时间： 2844 我们对十万条记录进行循环操作，JS的运行时间为187ms，还是蛮快的，但是最终渲染完成后的总时间确是2844ms。 简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单来统计JS运行时间和总渲染时间： 在 JS 的Event Loop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染 第一个console.log的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间 第二个console.log是放到 setTimeout 中的，它的触发时间是在渲染> 依照两次console.log的结果，可以得出结论： 对于大量数据渲染的时候，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段 使用定时器 从上面的例子，我们已经知道，页面的卡顿是由于同时渲染大量DOM所引起的，所以我们考虑将渲染过程分批进行 在这里，我们使用setTimeout来实现分批渲染 复制代码 //需要插入的容器 let ul = document.getElementById('container'); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //总页数 let page = total/once //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal,curIndex){ if(curTotal { for(let i = 0; i 为什么会出现闪屏现象呢 首先，理清一些概念。FPS表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS是描述帧变化速度的物理量。 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，FPS为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。 因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。 为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了， 这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。 而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁， 这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。 大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。 因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 直观感受，不同帧率的体验： 帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适； 帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异； 帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感； 帧率波动很大的动画，亦会使人感觉到卡顿。 setTimeout 和闪屏现象 setTimeout的执行时间并不是确定的。在JS中，setTimeout任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此setTimeout的实际执行时间可能会比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。 在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 requestAnimationFrame 关于requestAnimationFrame requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量。 requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。 如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。 我们使用requestAnimationFrame来进行分批渲染： 复制代码 //需要插入的容器 let ul = document.getElementById('container'); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal,curIndex){ if(curTotal 此时页面加载的速度很快，并且滚动的时候，也很流畅没有出现闪烁丢帧的现象。 DocumentFragment + requestAnimationFrame 先解释一下什么是 DocumentFragment ，文献引用自MDN DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。 可以使用document.createDocumentFragment方法或者构造函数来创建一个空的DocumentFragment 从MDN的说明中，我们得知DocumentFragments是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。 通过 DocumentFragment 的使用，减少 DOM 操作次数，降低回流对性能的影响。并且可以通过 requestAniminationFrame 保证插入新节点操作在页面重绘前执行，二者结合可以实现数据渲染优化。 最后修改代码如下： //需要插入的容器 let ul = document.getElementById('container'); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //总页数 let page = total/once //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal,curIndex){ if(curTotal requestAnimationFrame 兼容 具体看https://github.com/darius/requestAnimationFrame // requestAnimationFrame polyfill by Erik Möller. // Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavič, Darius Bacon // MIT license if (!Date.now) Date.now = function() { return new Date().getTime(); }; (function() { 'use strict'; var vendors = ['webkit', 'moz']; for (var i = 0; i 使用 (function animate(){ requestAnimationFrame(animate); //动画 })(); Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 11:58:05 "},"Javascript/多个连续的箭头函数与柯里化.html":{"url":"Javascript/多个连续的箭头函数与柯里化.html","title":"多个连续的箭头函数与柯里化 ✔","keywords":"","body":" title: 多个连续的箭头函数与柯里化 categories: \"多个连续的箭头函数与柯里化\" tags: javascript es6 高阶函数 高阶函数定义：将函数作为参数或者返回值是函数的函数。 所以高阶函数分两种： 是我们常见的 sort,reduce 等函数。 返回值是函数的函数。 一般而言，我们要理解常见的高阶函数还是很容易的。比如： function add(a) { return function(b) { return a + b } } var add3 = add(3) add3(4) === 3 + 4 //true add 函数 在 es6 里的写法等价为 let add = a => b => a + b 其实以上就是 柯里化函数 只不过用 es6 写，变了一个样子，后面详细介绍它的原理和特点。 多个连续的箭头函数 but 当一堆箭头函数在你面前的时候，你会不会有一丝犹豫，我在此之前就是一脸懵逼。。。比如我看到下面的 redux-thunk 的源码（没错整个源码只有14行）里的多个连续箭头函数的时候。。。 // 形如 a => b => c => {xxx} 那怎么轻松理解这些箭头干了啥呢，当我看了柯里化后，瞬间就懂了， 多个连续箭头函数就是 es6的多次柯里化的写法 柯里化 我们先看 stackoverflow 的关于如何理解多个箭头函数的最高票回答, 他说 这就是柯里化函数。(This is a curried function) wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术 好，现在懂没，我来简单说一下。 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x => y => x + y let add2 = add(2) 本来完成 add 这个操作，应该是 let add = (x, y) => x + y 它需要俩参数，而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y => x + y 函数 并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 回归正题 let add = x => y => x + y add 函数按照 wiki 的定义可以理解成只柯里化了一次，那么下面这种呢？ a => b => c => {xxx} n 个连续箭头组成的函数实际上就是柯里化了 n - 1次。 具体调用过程如下： 前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值。 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。 所以连续箭头函数就是多次柯里化函数的 es6 写法。 let test = a => b => c => {xxx} 调用特点 let test = a => b => c => {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c 柯里化函数的功能 可以惰性求值 可以提前传递部分参数 出自(https://www.cnblogs.com/xueandsi/p/6032578.html) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 16:46:46 "},"Javascript/函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free）.html":{"url":"Javascript/函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free）.html","title":"函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free） ✔","keywords":"","body":"主要的编程范式有三种：命令式编程(Imperative)、声明式编程(Declarative)和函数式编程(Functional) 函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free） 将电脑运算视为数学上的函数计算，并且避免使用程序状态和易变对象，又称泛函编程。 是一种编码风格，他通过书写函数式代码来解决问题,本质上它是一种数学运算，原始目的就是求值 函数式编程有两个最基本的运算：合成和柯里化。 react函数式定义 几个核心概念： 递归，尾递归，相互递归和蹦床函数见 纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free(入参不用定义变量) 纯函数（输入一定时，输出一定）：输出不受外部环境影响，同时也不影响外部环境，无副作用 函数柯里化：把一个多参数的函数，转化为单参数函数（一个低阶函数转化为高阶函数的过程）。 （合成）反柯里化：将每次传入一个参数返回一个函数的形式转回,一次性传入所有参数返回结果的形势 偏函数： 偏函数就是为了复用一些每次都传入的相同的参数,等于对原来的函数做一层封装. 有点类似于我们在调用别人封装好的组件时, 需要传入很多属性,但是有些属性在我们项目中时都是一样的,这时候就可以自己对组件再一次封装,将一些属性默认传入. 声明式和命令式 声明式就像你告诉你朋友画一幅画，你不用去管他怎么画的细节 命令式就像按照你的命令，你朋友一步步把画画出来 换言之： 命令式编程(react)：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 声明式编程(jquery)：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 函数式编程（Functional） 函数式编程是声明式编程的一部分，因为他们思想是一致的：即只关注做什么而不是怎么做。但函数式编程除了对声明式编程的相似处之外，同时他也利用了js函数能够作为参数传递的特点。函数式编程最重要的特点是“函数第一位”,即函数可以出现在任何地方。 函数式编程的特性： （a）、不可变性(Immutability)：不可变性是指函数不存在副作用，如果需要修改，需要克隆新的备份数据进行处理 （b）、纯函数(Pure Functions)：纯函数是始终接受一个或多个参数并计算参数并返回数据或函数的函数 （c）、数据转换(Data Transformations)：对传递的数据克隆备份后，进行数据的处理，最终返回新的对象，避免副作用 （d）、闭包以及高阶函数 (Higher-Order Functions)：高阶函数是将函数作为参数或返回函数的函数，闭包不做解释 （e）、递归：递归是一种函数在满足一定条件之前调用自身的技术。 （f）、组合：常用的混合函数，将多个对象混合为一个新的对象。 （g）、惰性计算：在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。 来点代码 点击一个按钮，改变颜色 命令式： const container = document.getElementById(‘container’); const btn = document.createElement(‘button’); btn.className = ‘btn red’; btn.onclick = function(event) { if (this.classList.contains(‘red’)) { this.classList.remove(‘red’); this.classList.add(‘blue’); } else { this.classList.remove(‘blue’); this.classList.add(‘red’); } }; container.appendChild(btn); 声明式（react）： class Button extends React.Component{ this.state = { color: 'red' } handleChange = () => { const color = this.state.color === 'red' ? 'blue' : 'red'; this.setState({ color }); } render() { return ( ); } } 注意到什么不一样了么？ react没有去修改dom，只是声明了页面应该是什么样子（根据不同的state）. 　　 放到整个应用层面也是一样的道理，我们更加需要关心的是整个应用和页面的框架结构。 pointfree 函数式编程中的pointfree的意思就是“无参”或“无值”，pointfree style是一种编程范式，也作tacit programming，就是“无参编程”的意思了。什么是“无参编程”？ // 这就是有参的，因为有word var snakeCase = word => word.toLowerCase().replace(/\\s+/ig, '_'); // 这是pointfree var snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase); 从另一个角度看，有参的函数的目的是得到一个数据，而pointfree的函数的目的是得到另一个函数。 高阶函数：高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回 理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的\"范畴\"（category）。 范畴 范畴：彼此之间存在某种关系的概念、事物、对象等等，都构成\"范畴\"。随便什么东西，只要能找出它们之间的关系，就能定义一个\"范畴\"。范畴的数学模型 所有成员是一个集合 变形关系是函数把\"范畴\"想象成是一个容器，里面包含两样东西。 值（value） 值的变形关系，也就是函数。 下面我们使用代码，定义一个简单的范畴。 class Category { constructor(val) { this.val = val; } addOne(x) { return x + 1; } } 上面代码中，Category是一个类，也是一个容器，里面包含一个值（this.val）和一种变形关系（addOne）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。 注意，本文后面的部分，凡是提到\"容器\"的地方，全部都是指\"范畴\"。 范畴论与函数式编程的关系 范畴论使用函数，表达范畴之间的关系。 伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的\"函数式编程\"。 本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。 所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。 总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。 二.函数的合成与柯里化.反柯里化 1.合成（反柯里化）：如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。 const compose = function (f, g) { return function (x) { return f(g(x)); }; } 必须满足结合律 compose(f, compose(g, h)) // 等同于 compose(compose(f, g), h) // 等同于 compose(f, g, h) 面试题 手动实现一个compose函数，满足以下功能： var arr = [func1, func2, func3]; function func1 (ctx, next) { ctx.index++ next(); } function func2 (ctx, next) { setTimeout(function() { ctx.index++; next(); }); } function func3 (ctx, next) { console.log(ctx.index); } compose(arr)({index: 0}); // 输出：2 解： const compose = (arr) => { return function(ctx) { [...arr].reverse().reduce((func, item) => { return function(ctx) { item(ctx, function() { func(ctx) }) } }, ()=>{})(ctx) //因为reduce在这里返回的是函数，所以传入参数 } } function func1(ctx) { ctx.index++ (function (ctx) { func2(ctx, function() { func3(ctx) }) })(ctx); } 反人类版本！ const compose = arr => ctx => [...arr].reverse().reduce((func, item) => ctx => item(ctx, () => func(ctx)), () => {})(ctx) 2. 反柯里化 function uncurry(fn) { var args = [].slice.call(arguments, 1); return function() { var arg = [].slice.call(arguments); args = args.concat(arg); return fn.apply(this, args); } } var uncurryAdd = uncurry(curryAdd); console.log(uncurryAdd(1, 2, 3, 4)); // 10 var uncurryMul = uncurry(curryMul, 2); console.log(uncurryMul(3, 4)); // 24 2 柯里化: 把一个多参数的函数，转化为单参数函数（一个低阶函数转化为高阶函数的过程）。 f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。 这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数. // 柯里化之前 function add(x, y) { return x + y; } add(1, 2) // 3 // 柯里化之后 function addX(y) { return function (x) { return x + y; }; } addX(2)(1) // 3 比较经典的例子是 实现累加 add(1)(2)(3)(4) 第一种方法即是使用回调嵌套 function add(a) { // 疯狂的回调 return function(b) { return function(c) { return function(d) { // return a + b + c + d; return [a, b, c, d].reduce((v1, v2) => v1 + v2); } } } } console.log(add(1)(2)(3)(4)); // 10 既不优雅也不好扩展 修改两下，让它支持不定的参数数量 function add() { var args = [].slice.call(arguments); // 用以存储更新参数数组 function adder() { var arg = [].slice.call(arguments); args = args.concat(arg); // 每次调用，都返回自身，取值时可以通过内部的toString取到值 return adder; } // 指定 toString的值，用以隐示取值计算 adder.toString = function() { return args.reduce((v1, v2) => v1 + v2); }; return adder; } console.log(add(1, 2), add(1, 2)(3), add(1)(2)(3)(4)); // 3 6 10 上面这段代码，就能够实现了这个“柯里化” 需要注意的两个点是 arguments并不是真正的数组，所以不能使用数组的原生方法（如 slice） 在取值时，会进行隐示的求值，即先通过内部的toString()进行取值，再通过 valueOf()进行取值，valueOf优先级更高，我们可以进行覆盖初始的方法 当然，并不是所有类型的toString和toValue都一样，Number、String、Date、Function 各种类型是不完全相同的，本文不展开 上面用到了call 方法，它的作用主要是更改执行的上下文，类似的还有apply，bind 等 我们可以试着自定义一个函数的 bind方法，比如 var obj = { num: 10, getNum: function(num) { console.log(num || this.num); } }; var o = { num: 20 }; obj.getNum(); // 10 obj.getNum.call(o, 1000); // 1000 obj.getNum.bind(o)(20); // 20 // 自定义的 bind 绑定 Function.prototype.binder = function(context) { var fn = this; var args = [].slice.call(arguments, 1); return function() { return fn.apply(context, args); }; }; obj.getNum.binder(o, 100)(); // 100 还不够完善，假如要定义一个乘法的函数，就得再写一遍长长的代码 需要定义一个通用currying函数，作为包装 // 柯里化 function curry(fn) { var args = [].slice.call(arguments, 1); function inner() { var arg = [].slice.call(arguments); args = args.concat(arg); return inner; } inner.toString = function() { return fn.apply(this, args); }; return inner; } function add() { return [].slice.call(arguments).reduce(function(v1, v2) { return v1 + v2; }); } function mul() { return [].slice.call(arguments).reduce(function(v1, v2) { return v1 * v2; }); } var curryAdd = curry(add); console.log(curryAdd(1)(2)(3)(4)(5)); // 15 var curryMul = curry(mul, 1); console.log(curryMul(2, 3)(4)(5)); // 120 看起来就好多了，便于扩展 不过实际上，柯里化的应用中，不定数量的参数场景比较少，更多的情况下的参数是固定的（常见的一般也就两三个） // 柯里化 function curry(fn) { var args = [].slice.call(arguments, 1), // 函数fn的参数长度 fnLen = fn.length; // 存储参数数组，直到参数足够多了，就调用 function inner() { var arg = [].slice.call(arguments); args = args.concat(arg); if (args.length >= fnLen) { return fn.apply(this, args); } else { return inner; } } return inner; } function add(a, b, c, d) { return a + b + c + d; } function mul(a, b, c, d) { return a * b * c * d; } var curryAdd = curry(add); console.log(curryAdd(1)(2)(3)(4)); // 10 var curryMul = curry(mul, 1); console.log(curryMul(2, 3)(4)); // 24 上面定义的 add方法中，接受4个参数 在我们currying函数中，接受这个add方法，并记住这个方法需要接受的参数数量，存储传入的参数，直到符合数量要求时，便进行调用处理。 三.函子 函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。 1 函子的概念 函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。 2 函子的代码实现 任何具有map方法的数据结构，都可以当作函子的实现。 class Functor { constructor(val) { this.val = val; } map(f) { return new Functor(f(this.val)); } } 上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。 一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。 下面是一些用法的示例。 (new Functor(2)).map(function (two) { return two + 2; }); // Functor(4) (new Functor('flamethrowers')).map(function(s) { return s.toUpperCase(); }); // Functor('FLAMETHROWERS') (new Functor('bombs')).map(_.concat(' away')).map(_.prop('length')); // Functor(10) 上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。 ==因此，学习函数式编程，实际上就是学习函子的各种运算==。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。 四、of 方法 新的函子的时候，用了new命令。这实在==太不像==函数式编程了，因为new命令是面向对象编程的标志。 函数式编程一般约定，函子有一个of方法，用来生成新的容器。 下面就用of方法替换掉new。 Functor.of = function(val) { return new Functor(val); }; 然后，前面的例子就可以改成下面这样。 Functor.of(2).map(function (two) { return two + 2; }); // Functor(4) 这就更像函数式编程了。 五、Maybe 函子 函子接受各种函数，处理容器内部的值。==这里就有一个问题，容器内部的值可能是一个空值（比如null）==，而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。 Functor.of(null).map(function (s) { return s.toUpperCase(); }); // TypeError 上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。 Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查 class Maybe extends Functor { map(f) { return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); } } 有了 Maybe 函子，处理空值就不会出错了。 Maybe.of(null).map(function (s) { return s.toUpperCase(); }); // M 六、Either 函子 条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。 Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。 class Either extends Functor { constructor(left, right) { this.left = left; this.right = right; } map(f) { return this.right ? Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right); } } Either.of = function (left, right) { return new Either(left, right); }; 下面是用法。 var addOne = function (x) { return x + 1; }; Either.of(5, 6).map(addOne); // Either(5, 7); Either.of(1, null).map(addOne); // Either(2, null); 上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。 Either 函子的常见用途是提供默认值。下面是一个例子。 Either.of({address: 'xxx'}, currentUser.address).map(updateField); 上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。 Either 函子的另一个用途是代替try...catch，使用左值表示错误。 function parseJSON(json) { try { return Either.of(null, JSON.parse(json)); } catch (e: Error) { return Either.of(e, null); } } 上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象e。一般来说，所有可能出错的运算，都可以返回一个 Either 函子 七、ap 函子 函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。 function addTwo(x) { return x + 2; } const A = Functor.of(2); const B = Functor.of(addTwo) 上面代码中，函子A内部的值是2，函子B内部的值是函数addTwo。 有时，我们想==让函子B内部的函数，可以使用函子A内部的值进行运算==。这时就需要用到 ap 函子。 ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。 class Ap extends Functor { ap(F) { return Ap.of(this.val(F.val)); } } ==注意，ap方法的参数不是函数==，而是另一个函子。 因此，前面例子可以写成下面的形式。 Ap.of(addTwo).ap(Functor.of(2)) // Ap(4) ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。 function add(x) { return function (y) { return x + y; }; } Ap.of(add).ap(Maybe.of(2)).ap(Maybe.of(3)); // Ap(5) 上面代码中，函数add是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。 Ap.of(add(2)).ap(Maybe.of(3)); 八、Monad 函子 函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。 Maybe.of( Maybe.of( Maybe.of({name: 'Mulburry', number: 8402}) ) ) 上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。 ==Monad 函子的作用是，总是返回一个单层的函子==。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。 class Monad extends Functor { join() { return this.val; } flatMap(f) { return this.map(f).join(); } } 上面代码中，如果函数f返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，==join方法保证了flatMap方法总是返回一个单层的函子==。这意味着嵌套的函子会被铺平（flatten）。 九、IO 操作 Monad 函子的重要应用，就是实现 I/O （输入输出）操作。 I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成Monad函子，通过它来完成。 var fs = require('fs'); var readFile = function(filename) { return new IO(function() { return fs.readFileSync(filename, 'utf-8'); }); }; var print = function(x) { return new IO(function() { console.log(x); return x; }); } 上面代码中，读取文件和打印本身都是不纯的操作，但是readFile和print却是纯函数，因为它们总是返回 IO 函子。 如果 IO 函子是一个Monad，具有flatMap方法，那么我们就可以像下面这样调用这两个函数。 readFile('./user.txt') .flatMap(print) 这就是神奇的地方，上面的代码完成了不纯的操作，但是因为flatMap返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。 由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，flatMap方法被改名成chain。 var tail = function(x) { return new IO(function() { return x[x.length - 1]; }); } readFile('./user.txt') .flatMap(tail) .flatMap(print) // 等同于 readFile('./user.txt') .chain(tail) .chain(print) 上面代码读取了文件user.txt，然后选取最后一行输出。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-11 10:51:21 "},"Javascript/判断数据类型.html":{"url":"Javascript/判断数据类型.html","title":"判断数据类型 ✔","keywords":"","body":"使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下： 1.判断基本类型： Object.prototype.toString.call(null);//”[object Null]” Object.prototype.toString.call(undefined);//”[object Undefined]” Object.prototype.toString.call(“abc”);//”[object String]” Object.prototype.toString.call(123);//”[object Number]” Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型： 函数类型 Function fn(){console.log(“test”);} Object.prototype.toString.call(fn);//”[object Function]” 日期类型 var date = new Date(); Object.prototype.toString.call(date);//”[object Date]” 数组类型 var arr = [1,2,3]; Object.prototype.toString.call(arr);//”[object Array]” 正则表达式 var reg = /[hbc]at/gi; Object.prototype.toString.call(arr);//”[object Array]” 自定义类型 function Person(name, age) { this.name = name; this.age = age; } var person = new Person(\"Rose\", 18); Object.prototype.toString.call(arr); //”[object Object]” 很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： console.log(person instanceof Person);//输出结果为true instanceof 操作符 通俗理解就是沿着A的原型链能不能找到B 3.判断原生JSON对象： var isNativeJSON = window.JSON && Object.prototype.toString.call(JSON); console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 注意：Object.prototype.toString()本身是允许被修改的，而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-10 10:26:57 "},"Javascript/事件绑定、事件监听、事件委托（事件代理）.html":{"url":"Javascript/事件绑定、事件监听、事件委托（事件代理）.html","title":"事件绑定、事件监听、事件委托（事件代理） ✔","keywords":"","body":"事件绑定、事件监听、事件委托（事件代理）(http://www.jb51.net/article/93752.htm) 事件绑定 要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。 在JavaScript中，有三种常用的绑定事件的方法： 在DOM元素中直接绑定； 在JavaScript代码中绑定； 绑定事件监听函数。 在DOM中直接绑定事件 我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看， DOM事件 。 function hello(){ alert(\"hello world!\"); } function hello(){ alert(\"hello world!\"); } 在JavaScript代码中绑定事件 在JavaScript代码中（即 script 标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 document.getElementById(\"btn\").onclick = function(){ alert(\"hello world!\"); } 使用事件监听绑定事件 绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。 事件监听 关于事件监听，W3C规范中定义了3个事件阶段，依次是 捕获阶段 目标阶段 冒泡阶段。 起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为 捕获阶段 目标阶段 冒泡阶段 IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。 W3C规范 语法： element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有 DOM事件 。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 注：IE8以下不支持。 document.getElementById(\"btn1\").addEventListener(\"click\",hello); function hello(){ alert(\"hello world!\"); } IE标准 语法： element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数。 document.getElementById(\"btn2\").attachEvent(\"onclick\",hello); function hello(){ alert(\"hello world!\"); } 重点理论： target: 触发事件的元素。 触发事件的某个具体对象，只会出现在事件流的目标阶段（谁触发谁命中，所以肯定是目标阶段） currentTarget:事件绑定的元素。 绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中 事件委托的情况下两者不一样 通常情况下terget和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系 那就是在父子嵌套(事件委托)的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象，如下代码和截图所示： 单击子元素 one.addEventListener('click',function(e){ console.log(e.target); //three console.log(e.currentTarget); //one },false); 事件监听的优点 1、可以绑定多个事件。 var btn3 = document.getElementById(\"btn3\"); btn3.onclick = function(){ alert(\"hello 1\"); //不执行 } btn3.onclick = function(){ alert(\"hello 2\"); //执行 } 常规的事件绑定只执行最后绑定的事件。 var btn4 = document.getElementById(\"btn4\"); btn4.addEventListener(\"click\",hello1); btn4.addEventListener(\"click\",hello2); function hello1(){ alert(\"hello 1\"); } function hello2(){ alert(\"hello 2\"); } 两个事件都执行了。 2、可以解除相应的绑定 var btn5 = document.getElementById(\"btn5\"); btn5.addEventListener(\"click\",hello1);//执行了 btn5.addEventListener(\"click\",hello2);//不执行 btn5.removeEventListener(\"click\",hello2); function hello1(){ alert(\"hello 1\"); } function hello2(){ alert(\"hello 2\"); } 封装事件监听 绑定监听事件 function addEventHandler(target,type,fn){ if(target.addEventListener){ target.addEventListener(type,fn); }else{ target.attachEvent(\"on\"+type,fn); } } 移除监听事件 function removeEventHandler(target,type,fn){ if(target.removeEventListener){ target.removeEventListener(type,fn); }else{ target.detachEvent(\"on\"+type,fn); } } 测试 var btn5 = document.getElementById(\"btn5\"); addEventHandler(btn5,\"click\",hello1);//添加事件hello1 addEventHandler(btn5,\"click\",hello2);//添加事件hello2 removeEventHandler(btn5,\"click\",hello1);//移除事件hello1 事件委托 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。 var btn6 = document.getElementById(\"btn6\"); document.onclick = function(event){ event = event || window.event; var target = event.target || event.srcElement; if(target == btn6){ alert(btn5.value); } } 上面只是个例子，代码尽可能的简化了。在实际的代码中 我们可能用到jQuery的live()、delegate()、bind()、on()等。 事件委托优点 1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。 实例分析JavaScript中的事件委托和事件绑定 传统写法 item1 item2 item3 var item1 = document.getElementById(\"item1\"); var item2 = document.getElementById(\"item2\"); var item3 = document.getElementById(\"item3\"); item1.onclick = function(){ alert(\"hello item1\"); } item2.onclick = function(){ alert(\"hello item2\"); } item3.onclick = function(){ alert(\"hello item3\"); } 事件委托写法 item1 item2 item3 var item1 = document.getElementById(\"item1\"); var item2 = document.getElementById(\"item2\"); var item3 = document.getElementById(\"item3\"); document.addEventListener(\"click\",function(event){ var target = event.target; if(target == item1){ alert(\"hello item1\"); }else if(target == item2){ alert(\"hello item2\"); }else if(target == item3){ alert(\"hello item3\"); } }) 2、动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。 传统写法 item1 item2 item3 var list = document.getElementById(\"list\"); var item = list.getElementsByTagName(\"li\"); for(var i=0;i 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托写法 item1 item2 item3 var list = document.getElementById(\"list\"); document.addEventListener(\"click\",function(event){ var target = event.target; if(target.nodeName == \"LI\"){ alert(target.innerHTML); } }) var node=document.createElement(\"li\"); var textnode=document.createTextNode(\"item4\"); node.appendChild(textnode); list.appendChild(node); Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-20 15:41:39 "},"Javascript/树形数据扁平化，扁平化数据树形化.html":{"url":"Javascript/树形数据扁平化，扁平化数据树形化.html","title":"树形数据扁平化，扁平化数据树形化 ✔","keywords":"","body":"扁平化数据树形化 ,树形数据扁平化 扁平化数据树形化 var list = [ {\"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, {\"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", },{ \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Children\": [] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\", }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\", }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\" }, { \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\", }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\", }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\", }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\", }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\", }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\", } ] function listChangeTree(data) { // 删除 所有 children,以防止多次调用 data.forEach(function (item) { delete item.child; }); // 将数据存储为 以 id 为 KEY 的 map 索引数据列 let map = {}; data.forEach(function (item) { map[item.Id] = item; }); let val = []; data.forEach(function (item) { // 以当前遍历项，的pid,去map对象中找到索引的id let parent = map[item.PId]; // 如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 if (parent) { (parent.child || (parent.child = [])).push(item); } else { //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级 val.push(item); } }); return val; } listChangeTree(list) 结果得到： [{ \"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Children\": [] }] }] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\" }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\" }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\", \"child\": [{ \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\" }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\" }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\" }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\" }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\" }] }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\" }] }] }] }] 树形数据扁平化 var list = [{ \"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }] }] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\" }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\" }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\", \"child\": [{ \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\" }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\" }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\" }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\" }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\" }] }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\" }] }] }] }] function formatConversion (parent, child, index = 0, family = [], elderIdentity = 'x') { // child如果长度等于0，则代表已经到了最低层 // let page = (this.startPage - 1) * 10 if (child&&child.length > 0) { child.map((x, i) => { // 设置 __level 标志位 用于展示区分层级 // Vue.set(x, '__level', index) // 设置 __family 为家族关系 为所有父级，包含本身在内 // Vue.set(x, '__family', [...family, elderIdentity + '_' + i]) // 本身的唯一标识 可以理解为个人的身份证咯 一定唯一。 // Vue.set(x, '__identity', elderIdentity + '_' + i) parent.push(x) // 如果仍有子集，则进行递归 if (x.child&&x.child.length > 0) this.formatConversion(parent, x.child, index + 1, [...family, elderIdentity + '_' + i], elderIdentity + '_' + i) }) } return parent } formatConversion([],list) 结果得到： var list = [ {\"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, {\"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", },{ \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Children\": [] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\", }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\", }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\" }, { \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\", }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\", }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\", }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\", }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\", }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\", } ] Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 15:27:26 "},"Javascript/图片上传.html":{"url":"Javascript/图片上传.html","title":"图片上传 ✔","keywords":"","body":"图片上传（https://blog.csdn.net/qq_29712995/article/details/78839093） 安装axios的话： 1利用npm安装npm install axios –save 2使用ES6的写法引入 import axios from 'axios' 我们可能会想，如何使用axios上传照片： 一般情况上传照片有两种方式： 1.本地图片转换成base64，然后通过普通的post请求发送到服务端。操作简单，适合小图，以及如果想兼容低版本的ie没办法用此方法，还有就是最近我想应用到微信小程序中，发现小程序目前还不可以将图片转换为base64. 以下是我的代码 HTML代码： JS代码： var file = document.getElementById(\"upload_file\").files[0]; var r = new FileReader(); //本地预览 r.onload = function(){ console.log(r.result);//图片的base64 } r.readAsDataURL(file); //Base64 2.通过form表单提交。 form表单提交图片会刷新页面，也可以是form绑定到一个隐藏的iframe上，可以实现无刷新提交数据。 HTML代码： JS代码： import axios from 'axios' var file = document.getElementById(\"upload_file\").files[0]; var formdata1=new FormData();// 创建form对象 formdata1.append('img',file,file.name);// 通过append向form对象添加数据,可以通过append继续添加数据 //或formdata1.append('img',file); let config = { headers:{'Content-Type':'multipart/form-data'} }; //添加请求头 axios.post('/xapi/upimage',formdata1,config).then(response)=>{ //这里的/xapi/upimage为接口 console.log(response.data); }) 这里注意的是，设置 的==Content-Type== 查看是否成功：按F12-network-点击对应的那个请求 可以看到 同时上传文本和文件： ``` var formData = new FormData(); formData.append('file', $('#file')[0].files[0]); formData.append('name', $('#name').val()); $.ajax({ url: url, type: 'POST', cache: false, data: formData, processData: false, contentType: false, success: function () { alert(\"文件上传成功！\") }, error: function () { } }); ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-20 16:20:03 "},"Javascript/项目中第一次向数据库连续添加多条数据.html":{"url":"Javascript/项目中第一次向数据库连续添加多条数据.html","title":"项目中第一次向数据库连续添加多条数据 ✔","keywords":"","body":" title: 项目中第一次向数据库连续添加多条数据 categories: \"项目中第一次向数据库连续添加多条数据\" tags: javascript es6 记录 toPing() { if (this.n { if (data.responseCode == \"000000\" || data.responseCode == \"900116\") { console.log(this.pinData[this.n].order_id + '\\n') ++this.n setTimeout(() => { this.toPing() }, 200) // _this.$router.push('/card/success/' + 'submit_pingan'); } else { Toast(\"操作失败\"); } }) .fail(() => { Toast(\"操作失败\"); }); } } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 23:42:41 "},"Javascript/原型和闭包.html":{"url":"Javascript/原型和闭包.html","title":"原型和闭包 ✔","keywords":"","body":"1.一切（引用类型）都是对象，对象是属性的集合。 2.函数和对象的关系 函数就是对象的一种 var fn = function () { }; console.log(fn instanceof Object); // true 函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂 对象可以通过函数来创建,也可以说对象都是通过函数创建的 function Fn() { this.name = '张三'; this.year = 1988; } var fn1 = new Fn(); // var obj = { a: 10, b: 20 }; // var arr = [5, 'x', true]; var obj = new Object(); obj.a = 10; obj.b = 20; var arr = new Array(); arr[0] = 5; arr[1] = 'x'; arr[2] = true; 而其中的 Object 和 Array 都是函数： console.log(typeof (Object)); // function console.log(typeof (Array)); // function 问题来了 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系? 3.prototype原型 函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。 javascript默认的给函数一个属性——prototype。每个函数都有一个属性叫做prototype。 这个prototype的属性值是一个对象（属性的集合，强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。 SuperType是是一个函数，右侧的方框就是它的原型,即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。 那么上图中的“Object prototype”也是一个对象，它的proto指向哪里？ 原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如 有些方法怎么似曾相似？可以在自己自定义的方法的prototype中新增自己的属性 function Fn() { } Fn.prototype.name = '张三'; Fn.prototype.getYear = function () { return 1988; }; 这样就变成了 function Fn() { } Fn.prototype.name = '张三'; Fn.prototype.getYear = function () { return 1988; }; var fn = new Fn(); console.log(fn.name); console.log(fn.getYear()); Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。 因为每个对象都有一个隐藏的属性proto，这个属性引用了创建这个对象的函数的prototype。即：fn._proto **= Fn.prototype 这里的proto_成为“隐式原型”， 4.隐式原型 上节已经提到，每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个proto，可成为隐式原型。 上面图看来，obj.proto和Object.prototype的属性一样！ obj这个对象本质上是被Object函数创建的，因此obj._proto_ = Object.prototype**我们可以用一个图来表示。 即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。 那么上图中的“Object prototype”也是一个对象，它的proto指向哪里？ 在说明“Object prototype”之前，先说一下自定义函数的prototype。**自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.prototype(prototype也是一个对象)**。 但是Object.prototype确实一个特例**——它的proto指向的是null，切记切记！ 函数也是一种对象，函数也有proto吗？ 又一个好问题！——当然有。 函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 且看如下代码。 以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建 根据上面说的一句话——对象的proto指向的是创建它的函数的prototype，就会出现：Object._proto_ **= Function.prototype。用一个图来表示。 很明显的标出了：自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，唉，怎么还有一个……Function.proto指向Function.prototype？这不成了循环引用了？ 对！是一个环形结构。 其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的proto指向了自身的Prototype。 问题：Function.prototype指向的对象，它的proto是不是也指向Object.prototype？ 答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。 5.instanceof 对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。 这个时候就需要用到instanceof。例如： 上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？ instanceof判断的规则根据以上代码看下图： Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的判断规则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 按照以上规则，“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。 通过上以规则，你可以解释很多比较怪异的现象，例如： 这些看似很混乱的东西，答案却都是true，这是为何？ 正好，这里也接上了咱们上一节说的“乱”。 上一节贴了好多的图片，其实那些图片是可以联合成一个整体的，即： 问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？ 重点就这样被这位老朋友给引出来了——继承——原型链。 即，instanceof表示的就是一种继承关系，或者原型链的结构。请看下节分解。 6.继承 继承是通过原型链来体现的 原型链： 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 上图中，访问f1.b时，f1的基本属性中没有b，于是沿着proto找到了Foo.prototype.b。 我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？——hasOwnProperty，特别是在for…in…循环中，一定要注意。 f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？ 好问题。 它是从Object.prototype中来的，请看图： 对象的原型链是沿着proto这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。 由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。 当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。 说一个函数的例子吧。 我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下： 看到了吧，有call、length等这些属性。 那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.proto是否指向Object.prototype。 8简述【执行上下文】上 “执行上下文”（也叫做“执行上下文环境”） 第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。 在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟： 下面还有。先来个简单的。 有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。 与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一 下面还有。。。第三种情况。 在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。 看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。 没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。 好了，“准备工作”介绍完毕。 我们总结一下，在“准备工作”中完成了哪些工作： 1.变量、函数表达式——变量声明，默认赋值为undefined； 2.this——赋值； 3.函数声明——赋值 这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。 细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。 其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。 这里解释一下为什么代码段分为这三种。 所谓“代码段”就是一段文本形式的代码。 首先，全局代码是一种，这个应该没有非议，本来就是手写文本到标签里面的。 其次，eval代码接收的也是一段文本形式的代码。 最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 00:08:35 "},"Javascript/指数化退避.html":{"url":"Javascript/指数化退避.html","title":"指数化退避 ✔","keywords":"","body":" 指数化退避是一种失败后重试 API 的技巧，它会在每次连续的失败之后让重试时间逐渐变长，超过最大重试次数之后就会彻底放弃。 如果使用承诺和其它跟踪 AJAX 调用的方法会非常复杂，而使用可观察对象，这非常简单： ``` import { pipe, range, timer, zip } from 'rxjs'; import { ajax } from 'rxjs/ajax'; import { retryWhen, map, mergeMap } from 'rxjs/operators'; function backoff(maxTries, ms) { return pipe( retryWhen(attempts => range(1, maxTries) .pipe( zip(attempts, (i) => i), map(i => i i), mergeMap(i => timer(i ms)) ) ) ); } ajax('/api/endpoint') .pipe(backoff(3, 250)) .subscribe(data => handleData(data)); function handleData(data) { // ... } ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 23:42:41 "},"Javascript/JavaScript常用数组操作方法，包含ES6方法.html":{"url":"Javascript/JavaScript常用数组操作方法，包含ES6方法.html","title":"JavaScript常用数组操作方法，包含ES6方法 ✔","keywords":"","body":" title: JavaScript常用数组操作方法，包含ES6方法 categories: \"JavaScript常用数组操作方法，包含ES6方法\" tags: javascript es6 一、concat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。 var arr1 = [1,2,3]; var arr2 = [4,5]; var arr3 = arr1.concat(arr2); console.log(arr1); //[1, 2, 3] console.log(arr3); //[1, 2, 3, 4, 5] 二、join() join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用','号分割，不改变原数组。 var arr = [2,3,4]; console.log(arr.join()); //2,3,4 console.log(arr); //[2, 3, 4] 三、push() push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。 var a = [2,3,4]; var b = a.push(5); console.log(a); //[2,3,4,5] console.log(b); //4 push方法可以一次添加多个元素push(data1,data2....) 四、pop() pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。 var arr = [2,3,4]; console.log(arr.pop()); //4 console.log(arr); //[2,3] 五、shift() shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。 var arr = [2,3,4]; console.log(arr.shift()); //2 console.log(arr); //[3,4] 六、unshift() unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。 var arr = [2,3,4,5]; console.log(arr.unshift(3,6)); //6 console.log(arr); //[3, 6, 2, 3, 4, 5] tip:该方法可以不传参数,不传参数就是不增加元素。 七、slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组。 var arr = [2,3,4,5]; console.log(arr.slice(1,3)); //[3,4] console.log(arr); //[2,3,4,5] 八、splice() splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。 var a = [5,6,7,8]; console.log(a.splice(1,0,9)); //[] console.log(a); // [5, 9, 6, 7, 8] var b = [5,6,7,8]; console.log(b.splice(1,2,3)); //[6, 7] console.log(b); //[5, 3, 8] 九、substring() 和 substr() 相同点：如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。 substr(startIndex); substring(startIndex); var str = '123456789'; console.log(str.substr(2)); // \"3456789\" console.log(str.substring(2)) ;// \"3456789\" 不同点：第二个参数 substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）； substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）。 console.log(\"123456789\".substr(2,5)); // \"34567\" console.log(\"123456789\".substring(2,5)) ;// \"345\" 十、sort 排序 按照 Unicode code 位置排序，默认升序 var fruit = ['cherries', 'apples', 'bananas']; fruit.sort(); // ['apples', 'bananas', 'cherries'] var scores = [1, 10, 21, 2]; scores.sort(); // [1, 10, 2, 21] 十一、reverse() reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组。 var arr = [2,3,4]; console.log(arr.reverse()); //[4, 3, 2] console.log(arr); //[4, 3, 2] 十二、indexOf 和 lastIndexOf 都接受两个参数：查找的值、查找起始位置 不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。 indexOf var a = [2, 9, 9]; a.indexOf(2); // 0 a.indexOf(7); // -1 if (a.indexOf(7) === -1) { // element doesn't exist in array } lastIndexOf var numbers = [2, 5, 9, 2]; numbers.lastIndexOf(2); // 3 numbers.lastIndexOf(7); // -1 numbers.lastIndexOf(2, 3); // 3 numbers.lastIndexOf(2, 2); // 0 numbers.lastIndexOf(2, -2); // 0 numbers.lastIndexOf(2, -1); // 3 十三、every 对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true function isBigEnough(element, index, array) { return element 十四、some 对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true function compare(element, index, array) { return element > 10; } [2, 5, 8, 1, 4].some(compare); // false [12, 5, 8, 1, 4].some(compare); // true 十五、filter 对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组 var words = [\"spray\", \"limit\", \"elite\", \"exuberant\", \"destruction\", \"present\", \"happy\"]; var longWords = words.filter(function(word){ return word.length > 6; }); // Filtered array longWords is [\"exuberant\", \"destruction\", \"present\"] 十六、map 对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组 var numbers = [1, 5, 10, 15]; var doubles = numbers.map(function(x) { return x * 2; }); // doubles is now [2, 10, 20, 30] // numbers is still [1, 5, 10, 15] 十七、forEach 数组遍历 const items = ['item1', 'item2', 'item3']; const copy = []; items.forEach(function(item){ copy.push(item) }); ES6新增新操作数组的方法 1、find()： 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。 const arr = [1, \"2\", 3, 3, \"2\"] console.log(arr.find(n => typeof n === \"number\")) // 1 2、findIndex()： 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。 const arr = [1, \"2\", 3, 3, \"2\"] console.log(arr.findIndex(n => typeof n === \"number\")) // 0 3、fill()： 用新元素替换掉数组内的元素，可以指定替换下标范围。 arr.fill(value, start, end) 4、copyWithin()： 选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。 arr.copyWithin(target, start, end) const arr = [1, 2, 3, 4, 5] console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2 const arr1 = [1, 2, 3, 4, 5] console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3 const arr2 = [1, 2, 3, 4, 5] console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2 5、from 将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组 const bar = [\"a\", \"b\", \"c\"]; Array.from(bar); // [\"a\", \"b\", \"c\"] Array.from('foo'); // [\"f\", \"o\", \"o\"] 6、of 用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3] Array(7); // [ , , , , , , ] Array(1, 2, 3); // [1, 2, 3] 7、entries() 返回迭代器：返回键值对 //数组 const arr = ['a', 'b', 'c']; for(let v of arr.entries()) { console.log(v) } // [0, 'a'] [1, 'b'] [2, 'c'] //Set const arr = new Set(['a', 'b', 'c']); for(let v of arr.entries()) { console.log(v) } // ['a', 'a'] ['b', 'b'] ['c', 'c'] //Map const arr = new Map(); arr.set('a', 'a'); arr.set('b', 'b'); for(let v of arr.entries()) { console.log(v) } // ['a', 'a'] ['b', 'b'] 8、values() 返回迭代器：返回键值对的value //数组 const arr = ['a', 'b', 'c']; for(let v of arr.values()) { console.log(v) } //'a' 'b' 'c' //Set const arr = new Set(['a', 'b', 'c']); for(let v of arr.values()) { console.log(v) } // 'a' 'b' 'c' //Map const arr = new Map(); arr.set('a', 'a'); arr.set('b', 'b'); for(let v of arr.values()) { console.log(v) } // 'a' 'b' 9、keys() 返回迭代器：返回键值对的key //数组 const arr = ['a', 'b', 'c']; for(let v of arr.keys()) { console.log(v) } // 0 1 2 //Set const arr = new Set(['a', 'b', 'c']); for(let v of arr.keys()) { console.log(v) } // 'a' 'b' 'c' //Map const arr = new Map(); arr.set('a', 'a'); arr.set('b', 'b'); for(let v of arr.keys()) { console.log(v) } // 'a' 'b' 10、includes 判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。 var a = [1, 2, 3]; a.includes(2); // true a.includes(4); // false 出自(https://segmentfault.com/a/1190000016503330) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 23:42:41 "},"Javascript/js坑点.html":{"url":"Javascript/js坑点.html","title":"js坑点 ✘","keywords":"","body":"精度丢失问题 1. 两个简单的浮点数相加 0.1 + 0.2 != 0.3 // 0.30000000000000004 2. 大整数运算 var x = 9007199254740992 x + 1 == x // ？ // 9007199254740992 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992,大于 9007199254740992 的可能会丢失精度 3. toFixed 不会四舍五入（Chrome） 1.335.toFixed(2) // 1.33 // toFixed 修复 function toFixed(num, s) { var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des + '' } 解决方案 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。如果是id和后台商量好用String 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）// 0.1 + 0.2 (0.1*10 + 0.2*10) / 10 == 0.3 // true Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:57:59 "},"Javascript/Special/":{"url":"Javascript/Special/","title":"奇技淫巧 ✔","keywords":"","body":"奇技淫巧 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 11:24:34 "},"Javascript/Special/奇技淫巧.html":{"url":"Javascript/Special/奇技淫巧.html","title":"奇技淫巧part1 ✔","keywords":"","body":"tostring() function test(x){ var sum = x; var mod = function(y) { sum = sum * y; return mod; }; mod.toString =function(){ return sum; }; return mod; } console.log(test(2)(3)(4)(5)); | 取整 console.log(0.6|0)//0 console.log(1.1|0)//1 console.log(3.65555|0)//3 console.log(5.99999|0)//5 console.log(-7.777|0)//-7 | 转为数字 typeof(\"99\" | 0 ) \"number 解构 function aa(...bb){ console.log(bb) } aa(\"ryuuo\") VM7013:2 [\"ryuuo\"] ~~常用来取整 ~是按位非，就是每一位取反， ~~常用来取整 比如 ~~10.2323=10 ~~（10/3） = 3 ~~(Math.random() * 10) //4 更多： 是一种利用符号进行的类型转换,转换成数字类型 ~~true == 1 ~~false == 0 ~~\"\" == 0 ~~[] == 0 ~~undefined ==0 ~~!undefined == 1 ~~null == 0 ~~!null == 1 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 11:26:08 "},"Framework/":{"url":"Framework/","title":"前后端框架相关","keywords":"","body":"前后端框架相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-15 16:02:44 "},"Framework/前端/":{"url":"Framework/前端/","title":"前端 ✘","keywords":"","body":"前端相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-19 18:08:03 "},"Framework/前端/Vue/":{"url":"Framework/前端/Vue/","title":"Vue ✘","keywords":"","body":"Vue相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 00:44:54 "},"Framework/前端/Vue/Interview/":{"url":"Framework/前端/Vue/Interview/","title":"Vue面试 ✘","keywords":"","body":"Vue面试相关 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 00:39:49 "},"Framework/前端/Vue/Interview/持续更新面试题.html":{"url":"Framework/前端/Vue/Interview/持续更新面试题.html","title":"持续更新面试题 ✘","keywords":"","body":"30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度） 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？ SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。2、v-show 与 v-if 有什么区别？ v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？ Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： data: { isActive: true, hasError: false } 数组语法： data: { activeClass: 'active', errorClass: 'text-danger' } Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： data: { activeColor: 'red', fontSize: 30 } 数组语法： data: { styleColor: { color: 'red' }, styleSize:{ fontSize:'23px' } } 4、怎样理解 Vue 的单向数据流？ 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： props: ['initialCounter'], data: function () { return { counter: this.initialCounter } } 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 props: ['size'], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } } 5、computed 和 watch 的区别和运用的场景？ computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？ 由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： // Vue.set Vue.set(vm.items, indexOfItem, newValue) // vm.$set，Vue.set的一个别名 vm.$set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，Vue 提供了以下操作方法： // Array.prototype.splice vm.items.splice(newLength) 7、谈谈你对 Vue 生命周期的理解？ （1）生命周期是什么？ Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 （2）各个生命周期的作用 生命周期 描述 beforeCreate 组件实例（创建前）调用，在数据观测和初始化事件还未开始 created （创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来 beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted:在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 update 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 activited keep-alive 专属，组件被激活时调用 deadctivated keep-alive 专属，组件被销毁时调用 beforeDestory 在实例销毁之前调用。实例仍然完全可用。 destoryed 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 （3）生命周期示意图 1.png 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？ Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted 子组件更新过程 父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated 父组件更新过程 父 beforeUpdate -> 父 updated 销毁过程 父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed 9、在哪个生命周期内调用异步请求？ 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；10、在什么阶段才能访问操作DOM？ 在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 1.png 11、父组件可以监听到子组件的生命周期吗？ 比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： // Parent.vue // Child.vue mounted() { this.$emit(\"mounted\"); } 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： // Parent.vue doSomething() { console.log('父组件监听到 mounted 钩子函数 ...'); }, // Child.vue mounted(){ console.log('子组件触发 mounted 钩子函数 ...'); }, // 以上输出顺序为： // 子组件触发 mounted 钩子函数 ... // 父组件监听到 mounted 钩子函数 ... 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 12、谈谈你对 keep-alive 的了解？ keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 13、组件中 data 为什么是一个函数？ 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ // data data() { return { message: \"子组件\", childName:this.name } } // new Vue new Vue({ el: '#app', router, template: '', components: {App} }) 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 14、v-model 的原理？ 我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 相当于 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 父组件： 子组件： props:{ value: String }, methods: { test1(){ this.$emit('input', '小红') }, }, 15、Vue 组件间通信有哪几种方式？ Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 $parent / $children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 -（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4）$attrs/$listeners 适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 16、你使用过 Vuex 吗？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （- 2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 - store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。17、使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。 18、vue-router 路由模式有几种？ vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： switch (mode) { case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') { assert(false, `invalid mode: ${mode}`) } } 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？ （1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'： https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。（2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： window.history.pushState(null, null, path); window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 20、什么是 MVVM？ Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示： 1.png （1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然： （1）View 层 {{message}} Click me （2）ViewModel 层 var app = new Vue({ el: '#app', data: { // 用于描述视图状态 message: 'Hello Vue!', }, methods: { // 用于描述视图行为 showMessage(){ let vm = this; alert(vm.message); } }, created(){ let vm = this; // Ajax 获取 Model 层的数据 ajax({ url: '/your/server/data/api', success(res){ vm.message = res; } }); } }) （3） Model 层 { \"url\": \"/your/server/data/api\", \"res\": { \"success\": true, \"name\": \"IoveC\", \"domain\": \"www.cnblogs.com\" } } 21、Vue 是如何实现数据双向绑定的？ 在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。 当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。 可以发现只要视图中添加监听事件，自动变更对应的数据变化时，就可以实现数据和视图的双向绑定了。 Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 1.png 即： 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。 1.png 22、Vue 框架怎么实现对象和数组的监听？ 如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： /** * Observe a list of Array items. */ observeArray (items: Array) { for (let i = 0, l = items.length; i 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 23、Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 - Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？ 受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？ 我们查看对应的 Vue 源码：vue/src/core/instance/index.js export function set (target: Array | Object, key: any, val: any): any { // target 为数组 if (Array.isArray(target) && isValidArrayIndex(key)) { // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误 target.length = Math.max(target.length, key) // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val } // key 已经存在，直接修改属性值 if (key in target && !(key in Object.prototype)) { target[key] = val return val } const ob = (target: any).__ob__ // target 本身就不是响应式数据, 直接赋值 if (!ob) { target[key] = val return val } // 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val } 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 25、虚拟 DOM 的优缺点？ 优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 26、虚拟 DOM 实现原理？ 虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 27、Vue 中的 key 有什么作用？ key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： function createKeyToOldIdx (children, beginIdx, endIdx) { let i, key const map = {} for (i = beginIdx; i 28、你有对 Vue 项目进行哪些优化？ 如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。 （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 29、对于即将到来的 vue3.0 特性你有什么了解的吗？ Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。 此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改 vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。 30. vue初始化流程 创建Vue实例对象 init过程会初始化生命周期，初始化事件中心，初始化渲染、执行beforeCreate周期函数、初始化 data、props、computed、watcher、执行created周期函数等。 初始化后，调用$mount方法对Vue实例进行挂载（挂载的核心过程包括模板编译、渲染以及更新三个过程）。 如果没有在Vue实例上定义render方法而是定义了template，那么需要经历编译阶段。需要先将template 字符串编译成 render function，template 字符串编译步骤如下 ： parse正则解析template字符串形成AST（抽象语法树，是源代码的抽象语法结构的树状表现形式） optimize标记静态节点跳过diff算法（diff算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有O(n)。如果对于时间复杂度不是很清晰的，可以查看我写的文章ziyi2/algorithms-javascript/渐进记号） generate将AST转化成render function字符串 编译成render function 后，调用$mount的mountComponent方法，先执行beforeMount钩子函数，然后核心是实例化一个渲染Watcher，在它的回调函数（初始化的时候执行，以及组件实例中监测到数据发生变化时执行）中调用updateComponent方法（此方法调用render方法生成虚拟Node，最终调用update方法更新DOM）。 调用render方法将render function渲染成虚拟的Node（真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。如果频繁的去做 DOM 更新，会产生一定的性能问题，而 Virtual DOM 就是用一个原生的 JavaScript 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多，而且修改属性也很轻松，还可以做到跨平台兼容），render方法的第一个参数是createElement(或者说是h函数)，这个在官方文档也有说明。 生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用pacth方法把虚拟DOM转换成真正的DOM节点。需要注意在图中忽略了新建真实DOM的情况（如果没有旧的虚拟Node，那么可以直接通过createElm创建真实DOM节点），这里重点分析在已有虚拟Node的情况下，会通过sameVnode判断当前需要更新的Node节点是否和旧的Node节点相同（例如我们设置的key属性发生了变化，那么节点显然不同），如果节点不同那么将旧节点采用新节点替换即可，如果相同且存在子节点，需要调用patchVNode方法执行diff算法更新DOM，从而提升DOM操作的性能。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 13:24:53 "},"Framework/前端/Vue/Interview/vue面试题.html":{"url":"Framework/前端/Vue/Interview/vue面试题.html","title":"vue面试题 ✘","keywords":"","body":"目录  1. 说一下Vue的双向绑定数据的原理  2. 解释单向数据流和双向数据绑定  3. Vue如何去除url中的 #  4. 对 MVC、MVVM的理解  5. 介绍虚拟DOM  6. vue生命周期的理解  7. 组件通信  8. 路由实现  9. v-if 和 v-show 区别  10. $route和$router的区别  11. NextTick 是做什么的  12. Vue 组件 data 为什么必须是函数  13. 计算属性computed 和事件 methods 有什么区别  14. 对比 jQuery ，Vue 有什么优缺点  15. Vue 中怎么自定义指令  16. Vue 中怎么自定义过滤器  17. 对 keep-alive 的了解  18. Vue 中 key 的作用  19. 你觉得 Vue 的核心是什么  20. vue 等单页面应用的优缺点  21. vue-router 使用params与query传参有什么区别  22. 详解vue的diff算法 1. 说一下Vue的双向绑定数据的原理 vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调 2. 解释单向数据流和双向数据绑定 单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state 双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度 3. Vue 如何去除url中的 # vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history new Router({ mode: 'history', routes: [ ] }) 需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面 4. 对 MVC、MVVM的理解 MVC 特点： View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的 MVVM 特点： 各部分之间的通信，都是双向的 采用双向绑定：View 的变动，自动反映在 ViewModel，反之亦然 具体请移步 这里 5. 介绍虚拟DOM 参考这里 6. vue生命周期的理解 vue实例有一个完整的生命周期，生命周期也就是指一个实例从开始创建到销毁的这个过程 beforeCreated() 在实例创建之间执行，数据未加载状态 created() 在实例创建、数据加载后，能初始化数据，dom渲染之前执行 beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据 mounted() 页面、数据渲染完成，真实dom挂载完成 beforeUpadate() 重新渲染之前触发 updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环 beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行 7. 组件通信 父组件向子组件通信 子组件通过 props 属性，绑定父组件数据，实现双方通信 子组件向父组件通信 将父组件的事件在子组件中通过 $emit 触发 非父子组件、兄弟组件之间的数据传递 /*新建一个Vue实例作为中央事件总嫌*/ let event = new Vue(); /*监听事件*/ event.$on('eventName', (val) => { //......do something }); /*触发事件*/ event.$emit('eventName', 'this is a message.') Vuex 数据管理 8. vue-router 路由实现 路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能 参考 这里 9. v-if 和 v-show 区别 使用了 v-if 的时候，如果值为 false ，那么页面将不会有这个 html 标签生成。 v-show 则是不管值为 true 还是 false ，html 元素都会存在，只是 CSS 中的 display 显示或隐藏 10. $route和$router的区别 $router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法 $route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等 11. NextTick 是做什么的 $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM 具体可参考官方文档 深入响应式原理 12. Vue 组件 data 为什么必须是函数 因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了 13. 计算属性computed 和事件 methods 有什么区别 我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 不同点： computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值 对于 method ，只要发生重新渲染，method 调用总会执行该函数 14. 对比 jQuery ，Vue 有什么不同 jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作 Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发 15. Vue 中怎么自定义指令 全局注册 // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 局部注册 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 参考 官方文档-自定义指令 16. Vue 中怎么自定义过滤器 可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值 Vue.filter('reverse', function (value) { return value.split('').reverse().join('') }) 'cba' --> 过滤器也同样接受全局注册和局部注册 17. 对 keep-alive 的了解 keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 可以使用API提供的props，实现组件的动态缓存 具体参考 官方API 18. Vue 中 key 的作用 key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误 具体参考 官方API 19. Vue 的核心是什么 数据驱动 组件系统 20. vue 等单页面应用的优缺点 优点： 良好的交互体验 良好的前后端工作分离模式 减轻服务器压力 缺点： SEO难度较高 前进、后退管理 初次加载耗时多 21. vue-router 使用params与query传参有什么区别 vue-router 可以通过 params 与 query 进行传参 // 传递 this.$router.push({path: './xxx', params: {xx:xxx}}) this.$router.push({path: './xxx', query: {xx:xxx}}) // 接收 this.$route.params this.$route.query params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系 params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题22. 详解vue的diff算法 详解vue的diff算法 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 16:41:35 "},"Framework/前端/Vue/Interview/vue和react对比.html":{"url":"Framework/前端/Vue/Interview/vue和react对比.html","title":"vue和react对比 ✘","keywords":"","body":"相同点 都支持服务器端渲染 都有Virtual DOM（虚拟dom）,组件化开发,都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据,都实现webComponent规范 数据驱动视图 都有支持native的方案,React的React native,Vue的weex 构建工具 React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。都有管理状态，React有redux,Vue有自己的Vuex（自适应vue，量身定做） 区别 设计思想 react 函数式思想，all in js ,jsx语法，js操控css 单项数据流 setState重新渲染 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，如果为true继续渲染、false不渲染，但Vue将此视为默认的优化。 vue 响应式思想，也就是基于数据可变的。把html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中 双向绑定，每一个属性都需要建立watch监听（页面不用，涉及到组件更新的话需要） Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树 性能 react ----大型项目 优化需要手动去做，状态可控 vue ------中小型项目 状态改变需要watch监听，数据量太大的话会卡顿 扩展性 react 1 类式写法api少，更容易结合ts 2 可以通过高阶组件来扩展 vue 1 声明式写法，结合ts比较复杂 2 需要通过mixin方式来扩展 React刚开始也有mixin的写法，通过React.createClass的api，不过现在很少用了。 Vue也不是不能实现高阶组件，只是特别麻烦，因为Vue对与组件的option做了各种处理，想实现高阶组件就要知道每一个option是怎么处理的，然后正确的设置。具体有多复杂，可以参考下面的文章。 http://hcysun.me/2018/01/05/探索Vue高阶组件/ https://segmentfault.com/a/1190000011962150 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 12:58:59 "},"Framework/前端/Vue/Interview/vue3.0为何弃用Object.defineProperty而选择Proxy.html":{"url":"Framework/前端/Vue/Interview/vue3.0为何弃用Object.defineProperty而选择Proxy.html","title":"vue3.0为何弃用Object.defineProperty而选择Proxy ✘","keywords":"","body":"vue3.0为何弃用Object.defineProperty而选择Proxy 首先这两种都是基于数据劫持实现的双向绑定 什么是数据劫持? 当访问或者设置对象的属性的时候，触发相应的函数，并且返回或者设置属性的值。vue通过Object.defineProperty来劫持对象属性的getter和setter操作，当数据发生变化时发出通知。如下代码，实现了一个Observer const data= { name: 'xiaoming', sex: '男' } // 遍历对象,对其属性值进行劫持 Object.keys(data).forEach(key => { let val = data[key] Object.defineProperty(data, key, { enumerable: true, // 该属性可被枚举 configurable: true, // 该属性可以被删除以及属性描述符可以被改变 get () { console.log(`属性值${data}当前值为${val}`) return val }, set (newValue) { console.log(`监听到属性值${data}由${val}变为${newValue}`) val = newValue } }) }); data.name // 属性值name当前值为xiaoming data.name = 'huahua' // 监听到属性值name由xiaoming变为huahua data.sex // 属性值sex当前值为男 data.sex = '女' // 监听到属性值sex由男变为女 数据劫持的优势 不需要进行显示调用，vue的双向绑定原理就是通过数据劫持+发布订阅来实现的，比如angular的脏检查需要通过显示调用markForCheck，react则需要通过setState来进行显示调用 通过属性的劫持可以精准获得变化的内容，这部分不需要额外的diff操作，减少性能消耗 vue实现双向绑定 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。这里需要注意，递归的时候由于属性的值可能也是一个对象，在递归处理对象属性值的时候 ，递归循环引用对象很容易出现递归爆栈问题，在vue中已经通过定义ob对象记录已经被设置过setter和getter方法的对象，避免了此问题，但如果需要扩展对象，必须手动给新属性设置setter和getter方法，这就是为什么不在data中预先声明好的属性无法进行双向绑定，需要通过this.$set()来设置 ``` this.$set(this.data.key, value) !注意，这是1.0的写法 this.$set(this.data,”key”,value) ！这个是2.0的写法 2. 实现一个订阅者Watcher，作为连接Observer和Compile的桥梁，可以收到属性的变化通知并执行相应的函数，从而更新视图。 3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 ## Object.defineProperty缺陷 >将上文中我们的示例代码 属性值改为数组，数组也算是一种特殊的对象，下标其实就是对象的属性，理论上是可以通过Object.defineProperty来处理的，那尤大大为什么没有采用这种方式呢，猜测源于数组的使用场景，数组的主要操作场景是遍历，如果每一个元素都挂载set和get方法，会产生巨大性能消耗，而且数组下标变化频繁，操作方法居多，一旦数组长度发生变化，在无法自动检测的状态下，手动更新会是一个相当繁琐的工作 ## 那vue中是如何实现对数组的劫持呢 >肯定不能直接篡改Array.prototype 对象，因为会影响所有的数组实例，尤大大通过原型继承得到一个新的原型对象，在此基础上，劫持了7种常用的数组操作进行了重写，分别是push() 、pop() 、shift()、 unshift() 、splice() 、sort()、 reverse()，Vue.set()对于数组的处理其实就是调用了splice方法 ## Proxy的优势 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写，可以这样认为,Proxy是Object.defineProperty的全方位加强版 1.Proxy可以直接监听对象而非属性，并返回一个新对象 2.Proxy可以直接监听数组的变化 ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 23:34:35 "},"Framework/前端/小程序面试.html":{"url":"Framework/前端/小程序面试.html","title":"小程序 ✘","keywords":"","body":"目录  1. 简单描述下微信小程序的相关文件类型  2. 简述微信小程序原理  3. 小程序的双向绑定和vue哪里不一样  4. 小程序的wxss和css有哪些不一样的地方  5. 小程序页面间有哪些传递数据的方法  6. 小程序的生命周期函数  7. 怎么封装微信小程序的数据请求  8. 哪些方法可以用来提高微信小程序的应用速度  9. 微信小程序的优劣势  10. 怎么解决小程序的异步请求问题  11. 小程序关联微信公众号如何确定用户的唯一性  12. 如何实现下拉刷新  13. bindtap和catchtap的区别是什么  14. 简述下wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别 1. 简单描述下微信小程序的相关文件类型 微信小程序项目结构主要有四个文件类型 WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式 js 逻辑处理，网络请求 json 小程序设置，如页面注册，页面标题及tabBar 主要文件 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景色，配置导航条样式，配置默认标题 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量 app.wxss 可选 2. 简述微信小程序原理 微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口 微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 小程序分为两个部分 webview 和 appService 。其中 webview 主要用来展现 UI，appService 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理 3. 小程序的双向绑定和vue哪里不一样 小程序直接 this.data 的属性是不可以同步到视图的，必须调用： this.setData({ // 这里设置 }) 4. 小程序的wxss和css有哪些不一样的地方 WXSS 和 CSS 类似，不过在 CSS 的基础上做了一些补充和修改 尺寸单位 rpx rpx 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素 使用 @import 标识符来导入外联样式。@import 后跟需要导入的外联样式表的相对路径，用;表示语句结束 /** index.wxss **/ @import './base.wxss'; .container{ color: red; } 5. 小程序页面间有哪些传递数据的方法 使用全局变量实现数据传递 在 app.js 文件中定义全局变量 globalData， 将需要存储的信息存放在里面 // app.js App({ // 全局变量 globalData: { userInfo: null } }) 使用的时候，直接使用 getApp() 拿到存储的信息 使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化 //pageA.js // Navigate wx.navigateTo({ url: '../pageD/pageD?name=raymond&gender=male', }) // Redirect wx.redirectTo({ url: '../pageD/pageD?name=raymond&gender=male', }) // pageB.js ... Page({ onLoad: function(option){ console.log(option.name + 'is' + option.gender) this.setData({ option: option }) } }) 需要注意的问题： wx.navigateTo 和 wx.redirectTo 不允许跳转到 tab 所包含的页面 onLoad 只执行一次 使用本地缓存 Storage 相关 6. 小程序的生命周期函数 onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数 onShow() 页面显示/切入前台时触发 onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互 onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等 onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时 详见 生命周期回调函数 7. 怎么封装微信小程序的数据请求 参考 这里 8. 哪些方法可以用来提高微信小程序的应用速度 1、提高页面加载速度 2、用户行为预测 3、减少默认 data 的大小 4、组件化方案 9. 微信小程序的优劣势 优势 即用即走，不用安装，省流量，省安装时间，不占用桌面 依托微信流量，天生推广传播优势 开发成本比 App 低 缺点 用户留存，即用即走是优势，也存在一些问题 入口相对传统 App 要深很多 限制较多,页面大小不能超过1M。不能打开超过5个层级的页面 10. 怎么解决小程序的异步请求问题 小程序支持 ES6 语法 在返回成功的回调里面处理逻辑 Promise 异步 async/await 11. 小程序关联微信公众号如何确定用户的唯一性 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid 是相同的 12. 如何实现下拉刷新 首先在全局 config 中的 window 配置 enablePullDownRefresh 在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法 请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新 参考 这里 13. bindtap和catchtap的区别是什么 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分 不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的 14. 简述下 `wx.navigateTo()`, `wx.redirectTo()`, `wx.switchTab()`, `wx.navigateBack()`, `wx.reLaunch()`的区别 wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面 wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面 wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 wx.reLaunch()：关闭所有页面，打开到应用内的某个页面 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-24 21:06:32 "},"Coding/":{"url":"Coding/","title":"手写代码","keywords":"","body":"手写代码 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 21:00:30 "},"Coding/js/":{"url":"Coding/js/","title":"js ✘","keywords":"","body":"js手写代码 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-10 21:00:41 "},"Coding/js/手写代码.html":{"url":"Coding/js/手写代码.html","title":"js手写代码 ✘","keywords":"","body":"js手写代码  1. 函数节流  2. 函数防抖  3. 手写promise  4. 用Promise对象实现的Ajax  5. 阶乘的实现方法（递归）  6. 实现一个JSON.stringify  7. 写一个sum函数满足无限传参的条件  8. 转换成数组的方法  9. 扁平化数组  10. 实现一个div滑动的动画，由快至慢5s结束  11. 实现一个div滑动的动画，由快至慢到500px结束  12.JSONP的实现步骤  13.数组排序（先按age升序相等则按name升序）  14.阶乘实现第一项为1，后一项是（前面所有项之和）*2  15.JS实现sleep()方法 算法相关  1. JS实现的数组全排列输出算法  2. 判断一个单词是否是回文？  3. 去掉一组整型数组重复的值  4. 随机生成指定长度的字符串  5. js中的广度优先遍历（BFS）和深度优先遍历（DF） https://www.jianshu.com/p/b4d8085e84bd https://www.jianshu.com/p/5e9ea25a1aae 基础 1. 函数节流 将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。 　　也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。 function throttle(fn,delay){ let timer = null; let startTime = +new Date() return function(...args){ let curTime = +new Date() let remaining = delay - (curTime -startTime) const context = this clearTimeout(timer) if(remaining2. 函数防抖 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间 function debounce(fn,wait=50,immediate) { let timer; return function() { if(immediate) { fn.apply(this,arguments) } if(timer) clearTimeout(timer) timer = setTimeout(()=> { fn.apply(this,arguments) },wait) } } 3. 手写promise 简化版 //简易promise实现(resolve,reject) function promise(fn) { this.value = undefined // 成功状态值 this.err = undefined // 失败状态值 this.status = 'pending' // 开始状态（就绪） var t = this // 就绪 -> 成功 function resolve(val) { if (t.status === 'pending') { t.value = val t.status = 'success' } } // 就绪 -> 失败 function reject(err) { if (t.status === 'pending') { t.err = err t.status = 'fail' } } fn(resolve, reject) } promise.prototype.then = function(isSuccess, isFail) { var t = this // 实现promise的链式调用 return new promise(function(resolve, reject) { // 用setTimeout模拟实现then方法的异步操作 setTimeout(function() { if (t.status === 'success') { // 将then1回调函数返回的值传给then2回调函数，以此类推 resolve(isSuccess(t.value)) } if (t.status === 'fail') { reject(isFail(t.err)) } }) }) } // test var p = new promise(function(resolve, reject) { if (1) { resolve(\"test resolve success\") } else { reject(\"test rejecr fail\") } }) p.then(function(val) { console.log(val) return val + \"链式调用return\" }).then(function(val) { console.log(val) }) // test resolve success // test resolve success链式调用return 升级版 const PENDING = \"pending\"; const FULFILLED = \"fulfilled\"; const REJECTED = \"rejected\"; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() => { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb => cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() => { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 => rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb => cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) => { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); } } Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value => value; onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason; }; if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) => { setTimeout(() => { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) => { setTimeout(() => { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) => { that.onFulfilledCallbacks.push((value) => { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) => { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } }; 4.用Promise对象实现的 Ajax const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); }); return promise; }; getJSON(\"/posts.json\").then(function(json) { console.log('Contents: ' + json); }, function(error) { console.error('出错了', error); }); 5.阶乘的实现方法（递归）： function factorial (num) { if (num 6.实现一个JSON.stringify Boolean | Number| String 类型会自动转换成对应的原始值。 undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = [] let arr = Array.isArray(obj) for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\") } } jsonStringify({x : 5,aa: {bb: {cc: {dd: {ee:1}}}}}) \"{\"x\":5,\"aa\":{\"bb\":{\"cc\":{\"dd\":{\"ee\":1}}}}}\" 7.写一个sum函数满足无限传参的条件 一个sum函数满足无限传参的条件 sum(1) = 1;//返回的是一个函数，此时调用函数的valueOf函数 sum(1)(2)(3) = 6; sum(1, 2, 3)(4) = 10; sum(1)(2)(3)(4)(5) = 15; 解题： function sum() { var args = Array.prototype.slice.call(arguments); //将arguments转成数组 var funName = arguments.callee; //记录函数名，以便后面递归调用函数 var fn = function () { var innerArgs = Array.prototype.slice.call(arguments); 将arguments转成数组 var finals = args.concat(innerArgs); return funName.apply(null, finals); //递归 } fn.valueOf = function () {// 当函数返回的是函数时，自动调用fn.valueOf函数 return args.reduce(function (a, b) { return a + b; }) } return fn; } 8.转换成数组的方法 方法一：var args = Array.prototype.slice.call(arguments); 方法二：var args = [].slice.call(arguments, 0); 方法三： var args = []; for (var i = 1; i 最后，附个转成数组的通用函数 var toArray = function(s){ try{ return Array.prototype.slice.call(s); } catch(e){ var arr = []; for(var i = 0,len = s.length; i 方法四：Array.from(arr); 9.扁平化数组 function flatten(arr){ return arr.reduce(function(prev,item){ return prev.concat(Array.isArray(item)?flatten(item):item); },[]); } 还可以使用ES6拓展运算符 function flatten(arr){ while(arr.some(item=>Array.isArray(item)){ arr = [].concat(...arr); } return arr; } 10.实现一个div滑动的动画，由快至慢5s结束 .sj{ width:50px; height:50px; border:1px solid red; position:absolute; left:0 } //ele为要移动的盒子，target为目标位置（像素），spd为计数器的频率 var ele = document.getElementById('sj') function animate(ele,spd){ var start = Date.now(); // remember start time var timer = setInterval(function() { var timePassed = Date.now() - start; var step = Math.ceil(Math.abs(timePassed - 5000)/10) console.log(step) if (timePassed >= 5000) { clearInterval(timer); // finish the animation after 2 seconds return; } ele.style.left = ele.offsetLeft + step + 'px' }, spd); } 11.实现一个div滑动的动画，由快至慢到500px结束 function animate1(ele,target,spd){ var timer = setInterval(function() { var step = (target-ele.offsetLeft)/10; //对步长进行二次加工(大于0向上取整,小于0向下取整) step = step>0?Math.ceil(step):Math.floor(step); //动画原理： 目标位置 = 当前位置 + 步长 ele.style.left = ele.offsetLeft + step + \"px\"; //检测缓动动画有没有停止 if(Math.abs(target-ele.offsetLeft)12.JSONP的实现步骤 客户端网页网页通过添加一个\\元素，向服务器请求JSON数据，这种做法不受同源政策限制 function addScriptTag(src) { var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script); } window.onload = function () { addScriptTag('http://example.com/ip?callback=foo'); } function foo(data) { console.log('response data: ' + JSON.stringify(data)); }; 请求时,接口地址是作为构建出的脚本标签的src的,这样,当脚本标签构建出来时,最终的src是接口返回的内容 服务端对应的接口在返回参数外面添加函数包裹层 foo({ \"test\": \"testData\" }); 由于\\元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 注意,一般的JSONP接口和普通接口返回数据是有区别的,所以接口如果要做JSONO兼容,需要进行判断是否有对应callback关键字参数,如果有则是JSONP请求,返回JSONP数据,否则返回普通数据 使用注意 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,用cors或者niginx反向代理 13.数组排序（先按age升序相等则按name升序） var arr = [ {name: \"张三\", age: 12}, {name: \"李四\", age: 13}, {name: \"\b王五\", age: 14} ] arr.sort(function(a, b) { if(a.age !== b.age ){ return a.age > b.age ? 1 : -1 } return a.name > a.name ? 1 : a.name === a.name ? 0 : -1 }) 14.阶乘实现第一项为1，后一项是（前面所有项之和）*2 1，2，6，18，54 第一种(超级慢) function num(n,sum = 0) { if(n == 1) return 1 while(n > 1) { sum += 2 * num(n -1) n-- } return sum } 第二种 function sum(n) { if(n == 1) return 1 if(n == 2) return 2 return 3*sum(n-1) } sum(n) = (sum(n-1) + sum(n-2) +++ ... sum(1))*2 sum(n-1) = (sum(n-2) + sum(n-3) +++ ... sum(1))*2 sum(n) = 3*sum(n-1) 第三种 /* 动态规划解决 function sum(n) { let val = []; for(let i =1; i待优化递归 15.JS实现sleep()方法 这种实现方式是利用一个伪死循环阻塞主线程。因为JS是单线程的。所以通过这种方式可以实现真正意义上的sleep()。 ``` function sleep(delay) { var start = (new Date()).getTime(); while ((new Date()).getTime() - start function test() { console.log('111'); sleep(2000); console.log('222'); } test() ## 算法相关 ### 1. JS实现的数组全排列输出算法 > 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。 function permute(input) { var permArr = [], usedChars = []; function main(input){ var i, ch; for (i = 0; i ### 2. 判断一个单词是否是回文？ function checkPalindrom(str) { return str == str.split('').reverse().join(''); } ### 3. 去掉一组整型数组重复的值 比如 输入: [1,13,24,11,11,14,1,2]， 输出: [1,13,24,11,14,2] ，需要去掉重复的11 和 1 这两个元素。 function(arr) { let hashTable = {}; let data = []; for(let i=0,l=arr.length;i } // 去除数组的重复成员 [...new Set(array)] 上面的方法也可以用于，去除字符串里面的重复字符。 [...new Set('ababbc')].join('') // \"abc\" ### 4. 随机生成指定长度的字符串 实现一个算法，随机生成指制定长度的字符窜。 function randomString(n) { let str = 'abcdefghijklmnopqrstuvwxyz9876543210'; let tmp = '', i = 0, l = str.length; for (i = 0; i Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 14:15:37 "},"Algorithms/":{"url":"Algorithms/","title":"数据结构和算法","keywords":"","body":"数据结构和算法 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 13:48:40 "},"Algorithms/Javascript/":{"url":"Algorithms/Javascript/","title":"Javascript实现","keywords":"","body":"Javascript实现 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 13:48:47 "},"Algorithms/Javascript/知识盲点.html":{"url":"Algorithms/Javascript/知识盲点.html","title":"知识盲点.md","keywords":"","body":"算法 斐波那契数列通项公式（爬楼梯leecode有矩阵推导） 特征方程，矩阵分解，差分方程 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-05 10:43:22 "},"Algorithms/Javascript/算法常见面试.html":{"url":"Algorithms/Javascript/算法常见面试.html","title":"面试常见","keywords":"","body":"算法 时间复杂度 通常使用最差的时间复杂度来衡量一个算法的好坏。 常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。 对于一个算法来说，可能会计算出如下操作次数 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。 位运算 位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制 33 可以看成是 32 + 1 ，并且 33 应该是六位二进制的（因为 33 近似 32，而 32 是 2 的五次方，所以是六位），那么 十进制 33 就是 100001 ，只要是 2 的次方，那么就是 1 否则都为 0 那么二进制 100001 同理，首位是 2^5 ，末位是 2^0 ，相加得出 33 左移 10 20 左移就是将二进制全部往左移动，10 在二进制中表示为 1010 ，左移一位后变成 10100 ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 a * (2 ^ b) 算数右移 >> 10 >> 1 // -> 5 算数右移就是将二进制全部往右移动并去除多余的右边，10 在二进制中表示为 1010 ，右移一位后变成 101 ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 int v = a / (2 ^ b) 右移很好用，比如可以用在二分算法中取中间值 13 >> 1 // -> 6 按位操作 按位与 每一位都为 1，结果才为 1 8 & 7 // -> 0 // 1000 & 0111 -> 0000 -> 0 按位或 其中一位为 1，结果就是 1 8 | 7 // -> 15 // 1000 | 0111 -> 1111 -> 15 按位异或 每一位都不同，结果才为 1 8 ^ 7 // -> 15 8 ^ 8 // -> 0 // 1000 ^ 0111 -> 1111 -> 15 // 1000 ^ 1000 -> 0000 -> 0 从以上代码中可以发现按位异或就是不进位加法 面试题：两个数不使用四则运算得出和 这道题中可以按位异或，因为按位异或就是不进位加法，8 ^ 8 = 0 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a & b) function sum(a, b) { if (a == 0) return b if (b == 0) return a let newA = a ^ b let newB = (a & b) 排序 以下两个函数是排序中会用到的通用函数，就不一一写了 function checkArray(array) { if (!array || array.length 冒泡排序 冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。 以下是实现该算法的代码 function bubble(array) { checkArray(array) for (let i = array.length - 1; i > 0; i--) { // 从 0 到 `length - 1` 遍历 for (let j = 0; j array[j + 1]) swap(array, j, j + 1) } } return array } ` 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 插入排序 插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。 以下是实现该算法的代码 function insertion(array) { checkArray(array) for (let i = 1; i = 0 && array[j] > array[j + 1]; j--) swap(array, j, j + 1) } return array } 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序 选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作。 以下是实现该算法的代码 function selection(array) { checkArray(array) for (let i = 0; i 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 归并排序 归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。 以下是实现该算法的代码 function sort(array) { checkArray(array) mergeSort(array, 0, array.length - 1) return array } function mergeSort(array, left, right) { // 左右索引相同说明已经只有一个数 if (left === right) return // 等同于 `left + (right - left) / 2` // 相比 `(left + right) / 2` 来说更加安全，不会溢出 // 使用位运算是因为位运算比四则运算快 let mid = parseInt(left + ((right - left) >> 1)) mergeSort(array, left, mid) mergeSort(array, mid + 1, right) let help = [] let i = 0 let p1 = left let p2 = mid + 1 while (p1 以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下 mergeSort(data, 0, 6) // mid = 3 mergeSort(data, 0, 3) // mid = 1 mergeSort(data, 0, 1) // mid = 0 mergeSort(data, 0, 0) // 遇到终止，回退到上一步 mergeSort(data, 1, 1) // 遇到终止，回退到上一步 // 排序 p1 = 0, p2 = mid + 1 = 1 // 回退到 `mergeSort(data, 0, 3)` 执行下一个递归 mergeSort(2, 3) // mid = 2 mergeSort(3, 3) // 遇到终止，回退到上一步 // 排序 p1 = 2, p2 = mid + 1 = 3 // 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑 // 排序 p1 = 0, p2 = mid + 1 = 2 // 执行完毕回退 // 左边数组排序完毕，右边也是如上轨迹 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 O(N * logN) 快速排序 快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。 以下是实现该算法的代码 function sort(array) { checkArray(array); quickSort(array, 0, array.length - 1); return array; } function quickSort(array, left, right) { if (left array[right]) { // 当前值比基准值大，将当前值和右边的值交换 // 并且不改变 `left`，因为当前换过来的值还没有判断过大小 swap(array, --more, left); } else { // 和基准值相同，只移动下标 left++; } } // 将基准值和比基准值大的第一个值交换位置 // 这样数组就变成 `[比基准值小, 基准值, 比基准值大]` swap(array, right, more); return [less, more]; } 该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。 面试题 Sort Colors：该题目来自 LeetCode，题目需要我们将 [2,0,2,1,1,0] 排序成 [0,0,1,1,2,2] ，这个问题就可以使用三路快排的思想。 以下是代码实现 var sortColors = function(nums) { let left = -1 let right = nums.length let i = 0 // 下标如果遇到 right，说明已经排序完成 while (i Kth Largest Element in an Array：该题目来自 LeetCode，题目需要找出数组中第 K 大的元素，这问题也可以使用快排的思路。并且因为是找出第 K 大元素，所以在分离数组的过程中，可以找出需要的元素在哪边，然后只需要排序相应的一边数组就好。 以下是代码实现 var findKthLargest = function(nums, k) { let l = 0 let r = nums.length - 1 // 得出第 K 大元素的索引位置 k = nums.length - k while (l k) { r = index - 1 } else { break } } return nums[k] } function part(array, left, right) { let less = left - 1 let more = right while (left array[right]) { swap(array, --more, left) } else { left++ } } swap(array, right, more) return more } 堆排序 堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。 大根堆是某个节点的所有子节点的值都比他小 小根堆是某个节点的所有子节点的值都比他大 堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i 2 + 1，右边是 i 2 + 2，父节点是 (i - 1) /2。 首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大 然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小 对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置 重复以上操作 3 - 4 直到整个数组都是大根堆。 以下是实现该算法的代码 function heap(array) { checkArray(array) // 将最大值交换到首位 for (let i = 0; i 0) { heapify(array, 0, size) swap(array, 0, --size) } return array } function heapInsert(array, index) { // 如果当前节点比父节点大，就交换 while (array[index] > array[parseInt((index - 1) / 2)]) { swap(array, index, parseInt((index - 1) / 2)) // 将索引变成父节点 index = parseInt((index - 1) / 2) } } function heapify(array, index, size) { let left = index * 2 + 1 while (left 以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。 该算法的复杂度是 O(logN) 系统自带排序实现 每个语言的排序内部实现都是不同的。 对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 源码实现 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN)相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。 对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。 链表 反转单向链表 该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题 以下是实现该算法的代码 var reverseList = function(head) { // 判断下变量边界问题 if (!head || !head.next) return head // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null let pre = null let current = head let next // 判断当前节点是否为空 // 不为空就先获取当前节点的下一节点 // 然后把当前节点的 next 设为上一个节点 // 然后把 current 设为下一个节点，pre 设为当前节点 while (current) { next = current.next current.next = pre pre = current current = next } return pre } 树 二叉树的先序，中序，后序遍历 先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。 递归实现 递归实现相当简单，代码如下 function TreeNode(val) { this.val = val this.left = this.right = null } var traversal = function(root) { if (root) { // 先序 console.log(root) traversal(root.left) // 中序 // console.log(root); traversal(root.right) // 后序 // console.log(root); } } 对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了。 非递归实现 非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。 以下是先序遍历代码实现 function pre(root) { if (root) { let stack = [] // 先将根节点 push stack.push(root) // 判断栈中是否为空 while (stack.length > 0) { // 弹出栈顶元素 root = stack.pop() console.log(root) // 因为先序遍历是先左后右，栈是先进后出结构 // 所以先 push 右边再 push 左边 if (root.right) { stack.push(root.right) } if (root.left) { stack.push(root.left) } } } } 以下是中序遍历代码实现 function mid(root) { if (root) { let stack = [] // 中序遍历是先左再根最后右 // 所以首先应该先把最左边节点遍历到底依次 push 进栈 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点 // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点 // 左边打印不出东西就把父节点拿出来打印，然后再看右节点 while (stack.length > 0 || root) { if (root) { stack.push(root) root = root.left } else { root = stack.pop() console.log(root) root = root.right } } } } 以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多 function pos(root) { if (root) { let stack1 = [] let stack2 = [] // 后序遍历是先左再右最后根 // 所以对于一个栈来说，应该先 push 根节点 // 然后 push 右节点，最后 push 左节点 stack1.push(root) while (stack1.length > 0) { root = stack1.pop() stack2.push(root) if (root.left) { stack1.push(root.left) } if (root.right) { stack1.push(root.right) } } while (stack2.length > 0) { console.log(s2.pop()) } } } 中序遍历的前驱后继节点 实现这个算法的前提是节点有一个 parent 的指针指向父节点，根节点指向 null 。 如图所示，该树的中序遍历结果是 4, 2, 5, 1, 6, 3, 7 前驱节点 对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 2 ，那么节点 2 的最右节点就是 5 如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点 如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1 ，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点 以下是算法实现 function predecessor(node) { if (!node) return // 结论 1 if (node.left) { return getRight(node.left) } else { let parent = node.parent // 结论 2 3 的判断 while (parent && parent.right === node) { node = parent parent = node.parent } return parent } } function getRight(node) { if (!node) return node = node.right while (node) node = node.right return node } 后继节点 对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6 如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点 以下是算法实现 function successor(node) { if (!node) return // 结论 1 if (node.right) { return getLeft(node.right) } else { // 结论 2 let parent = node.parent // 判断 parent 为空 while (parent && parent.left === node) { node = parent parent = node.parent } return parent } } function getLeft(node) { if (!node) return node = node.left while (node) node = node.left return node } 树的深度 树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度 以下是算法实现 var maxDepth = function(root) { if (!root) return 0 return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 } 对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到 3。 动态规划 动态规划背后的基本思想非常简单。就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。 一旦得出每个子问题的解，就存储该结果以便下次使用。 斐波那契数列 斐波那契数列就是从 0 和 1 开始，后面的数都是前两个数之和 0，1，1，2，3，5，8，13，21，34，55，89.... 那么显然易见，我们可以通过递归的方式来完成求解斐波那契数列 function fib(n) { if (n = 0) return n return fib(n - 1) + fib(n - 2) } fib(10) 尾递归优化 function Fibonacci(n, ac1 = 0, ac2 = 1) { if(n 以上第一个代码解决问题了。但是以上解法却存在很严重的性能问题，当 n 越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。 动态规划的本质其实就是两点 自底向上分解子问题 通过变量存储已经计算过的解 根据上面两点，我们的斐波那契数列的动态规划思路也就出来了 斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层 通过数组来存储每一位所对应的斐波那契数列的值 function fib(n) { let array = new Array(n + 1).fill(null) array[0] = 0 array[1] = 1 for (let i = 2; i 0 - 1 背包问题 该问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。 假设我们有以下物品 物品 ID /重量 价值 1 3 2 7 3 12 对于一个总容量为 5 的背包来说，我们可以放入重量 2 和 3 的物品来达到背包内的物品总价值最高。 对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题 物品 ID / 剩余容量 0 1 2 3 4 5 1 0 3 3 3 3 3 2 0 3 7 10 10 10 3 0 3 7 12 15 19 直接来分析能放三种物品的情况，也就是最后一行 当容量少于 3 时，只取上一行对应的数据，因为当前容量不能容纳物品 3 当容量 为 3 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，总价值为 12，所以应该放入物品 3 当容量 为 4 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 1 的价值相加，得出总价值为 15，所以应该放入物品 3 当容量 为 5 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 2 的价值相加，得出总价值为 19，所以应该放入物品 3 以下代码对照上表更容易理解 /** * @param {*} w 物品重量 * @param {*} v 物品价值 * @param {*} C 总容量 * @returns */ function knapsack(w, v, C) { let length = w.length if (length === 0) return 0 // 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量 // 第二维中的元素代表背包物品总价值 let array = new Array(length).fill(new Array(C + 1).fill(null)) // 完成底部子问题的解 for (let i = 0; i = w[0] ? v[0] : 0 } // 自底向上开始解决子问题，从物品 2 开始 for (let i = 1; i = w[i]) { // 可以放入的话，就比大小 // 放入当前物品和不放入当前物品，哪个背包总价值大 array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j - w[i]]) } } } return array[length - 1][C] } 最长递增子序列 最长递增子序列意思是在一组数字中，找出最长一串递增的数字，比如 0, 3, 4, 17, 2, 8, 6, 10 对于以上这串数字来说，最长递增子序列就是 0, 3, 4, 8, 10，可以通过以下表格更清晰的理解 数字 0 3 4 17 2 8 6 10 长度 1 2 3 4 2 4 4 5 通过以上表格可以很清晰的发现一个规律，找出刚好比当前数字小的数，并且在小的数组成的长度基础上加一。 这个问题的动态思路解法很简单，直接上代码 function lis(n) { if (n.length === 0) return 0 // 创建一个和参数相同大小的数组，并填充值为 1 let array = new Array(n.length).fill(1) // 从索引 1 开始遍历，因为数组已经所有都填充为 1 了 for (let i = 1; i n[j]) { array[i] = Math.max(array[i], 1 + array[j]) } } } let res = 1 for (let i = 0; i 字符串相关 在字符串相关算法中，Trie 树可以解决解决很多问题，同时具备良好的空间和时间复杂度，比如以下问题 词频统计 前缀匹配 如果你对于 Trie 树还不怎么了解，可以前往 这里 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 09:07:04 "},"Algorithms/Javascript/递归，尾递归，相互递归，蹦床函数.html":{"url":"Algorithms/Javascript/递归，尾递归，相互递归，蹦床函数.html","title":"递归，尾递归，相互递归，蹦床函数.md","keywords":"","body":"递归 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 我们知道，es5是没有尾递归优化的，所以在递归的时候，如果层数太多，就会报“Maximum call stack size exceeded”的错误。就连下面这个及其简单的递归函数都会报“Maximum call stack size exceeded”的错误。 function haha(a) { if(!a) return a; return haha(a-1); } haha(100); //输出0 haha(12345678); //输出“Maximum call stack size exceeded” 为什么会报“Maximum call stack size exceeded”的错误？我觉得原因是在每次递归调用的时候，会把当前作用域里面的基本类型的值推进栈中，所以一旦递归层数过多，栈就会溢出，所以会报错。 注意： js中的栈只会储存基本类型的值，比如：number, string, undefined, null, boolean。 为什么在调用下一层递归函数的时候没有释放上一层递归函数的作用域？因为在回来的时候还需要用到里面的变量。 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 尾递归（参考阮一峰） 怎么优化上面的情况呢？方法是使用尾递归。有尾递归优化的编译器会把尾递归编译成循环的形式，如果没有尾递归优化，那就自己写成循环的形式。如下面的例子所示： //尾递归函数，返回一个函数调用，并且这个函数调用是自己 function haha(a, b) { if(b) return b; return haha(a, a-1); } //优化成循环的形式 function yaya(a) { let b = a; while(b) { b = b - 1; } } 需要注意的是，看上面尾递归的代码，有一点很重要，就是用一个b变量来存上一次递归的值。这是尾递归常用的方法。另外，其实上面尾递归的代码不需要变量b，但为了便于说明，所以我加上了变量b。 // 尾递归优化阶乘 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 function restricted() { 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 尾递归优化的实现 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 function sum(x, y) { if (y > 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y > 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 trampoline(sum(1, 100000)) // 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 相互递归 但是关于递归还有一种形式，就是相互递归，如下面的代码所示： ``` function haha1(a) { if(!a) return a; return haha2(a-1); } function haha2(a) { if(!a) return a; return haha1(a-1); } haha1(100); //输出0 haha1(12345678); //输出Maximum call stack size exceeded 可以看到，当相互递归层数过多的时候，也会发生栈溢出的情况。 ## 蹦床函数 蹦床函数就是解决上面问题的方法。 **蹦床函数**（trampoline）就是将 **递归执行 转为 循环执行**。 执行的都是同样的步骤，只是反复执行，就好像在蹦床，跳上去，掉下来，在跳上去… 蹦床函数的实现： function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 首先我们改写上面的相互递归函数： function haha1(a) { if(!a) return a; return function() { return haha2(a-1); } } function haha2(a) { if(!a) return a; return function() { return haha1(a-1); } } >这个改写就是建立一个闭包来封装相互递归的函数，它的好处是由于不是直接的相互递归调用，所以不会把上一次的递归作用域推进栈中，而是把封装函数储存在堆里面，利用堆这个容量更大但读取时间更慢的储存形式来替代栈这个容量小但读取时间快的储存形式，用时间来换取空间。 我们尝试使用一下上面的函数： haha1(3)(); //输出一个函数 haha1(3)()()(); //输出0 >通过上面的示例可以看到，如果参数不是3而是很大的一个数字的时候，我们就需要写很多个括号来实现调用很多次。为了简便，我们可以把这种调用形式写成函数，这就是蹦床函数。如下所示： function trampoline(func, a) { let result = func.call(func, a); while(result && result instanceof Function) { result = result(); } return result; } >基本原理是一直调用，直到返回值不是一个函数为止。 最后来使用蹦床函数： trampoline(haha1, 12345678); //过一会儿就输出0 由于储存在堆中，所以耗时较长，过了一会儿才会输出0，但是并没有报栈溢出的错误。 ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:57:52 "},"Algorithms/Javascript/动态规划.html":{"url":"Algorithms/Javascript/动态规划.html","title":"动态规划.md","keywords":"","body":"算法 动态规划 动态规划有时被认为是一种与递归相反的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。 爬楼梯 1. 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 /** * @param {number} n * @return {number} */ var climbStairs = function(n) { let arr = []; arr[1] = 1 //1阶台阶,只有一种方式(1) arr[2] = 2 //2阶台阶,有两种方式(1+1, 2) for(let i=3;i时间复杂度：O(n) 空间复杂度：O(n) 空间复杂度优化： 滑动数组法 /** * @param {number} n * @return {number} */ var climbStairs = function(n) { if(n == 1){ return 1 } let first = 1, second = 2 for(let i = 3; i使用最小花费爬楼梯 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 class Solution { public int minCostClimbingStairs(int[] cost) { int f1 = 0,f2 = 0; for(int i = 0;i [动态规划基础问题整理](https://leetcode-cn.com/problems/edit-distance/solution/dong-tai-gui-hua-java-by-liweiwei1419/) 「动态规划」问题没有套路，请大家根据情况掌握自己需要的部分，多做一些问题或许是有用的。 第 1 部分：「动态规划」基本问题 递归 + 记忆化：记忆化递归（记忆化搜索），这是「自上而下」的思路； 掌握「自底向上」递推求解问题的方法； 理解「重复子问题」、「最优子结构」、「无后效性」； 掌握「状态定义」、「状态转移方程」 题目序号 题解 知识点 代码 509. 斐波那契数（简单） 递归做一定要加缓存。 70. 爬楼梯（简单） CSDN 和斐波拉契数是同一道问题。 第 2 部分：最优子结构 题目序号 题解 知识点 代码 279. 完全平方数（中等） 322. 零钱兑换（中等） 动态规划、使用「完全背包」问题思路、图的广度优先遍历 343. 整数拆分（中等） “贪心选择”性质的简单证明、记忆化搜索、动态规划 （Python、Java） 第 3 部分：无后效性 题目序号 题解 知识点 代码 198. 打家劫舍（简单） 二维状态消除后效性 62. 不同路径（中等） 63. 不同路径 II（中等） 第 4 部分：经典问题（1） 题目序号 题解 知识点 代码 53. 最大子序和 动态规划、分治法、CSDN 1、经典动态规划问题；2、分治 300. 最长上升子序列 动态规划 、贪心算法 + 二分 5. 最长回文子串 Manacher 算法 + 动态规划 （Java、C++、Python） 使用动态规划的方法得到子串的回文性质 72. 编辑距离 动态规划（Java）、CDSN 120. 三角形最小路径和（中等） 10. 正则表达式匹配（困难） 第 5 部分：经典问题（2）背包问题 题目序号 题解 知识点 代码 416. 分割等和子集 动态规划（0-1 背包问题） 很重要的动态规划模型，必须掌握 518. 零钱兑换 II 动态规划（套用完全背包问题模型） 322. 零钱兑换（中等） 动态规划、使用「完全背包」问题思路、图的广度优先遍历 377. 组合总和 Ⅳ 动态规划 494. 目标和 0-1 背包问题 474. 一和零 动态规划（转换为 0-1 背包问题） 第 6 部分：经典问题（3）股票问题 题目序号 题解 知识点 代码 121. 买卖股票的最佳时机（简单） 暴力枚举 + 动态规划 + 差分思想、CSDN 122. 买卖股票的最佳时机 II（简单） 暴力搜索 + 贪心算法 + 动态规划、CSDN 123. 买卖股票的最佳时机 III（困难） 动态规划、CSDN 1、从后向前写可以把状态压缩到一维；2、分解成两个 121 题。 188. 买卖股票的最佳时机 IV（困难） 动态规划 309. 最佳买卖股票时机含冷冻期（中等） 动态规划 714. 买卖股票的最佳时机含手续费（中等） 动态规划 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-01 16:47:16 "},"Algorithms/Javascript/大数据.html":{"url":"Algorithms/Javascript/大数据.html","title":"大数据处理.md","keywords":"","body":"面试-大数据 题目- 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url? 假如每个url大小为10bytes，那么可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。 Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,...,a999，每个小文件约300M); Step2:遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,...,b999); 巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0vsb0,a1vsb1,...,a999vsb999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。 Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 2.有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。 Step1：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,...,f4999)中，这样每个文件大概是200k左右，如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M; Step2：对每个小文件，统计每个文件中出现的词以及相应的频率(可以采用trie树/hash_map等)，并取出出现频率最大的100个词(可以用含100个结点的最小堆)，并把100词及相应的频率存入文件，这样又得到了5000个文件; Step3：把这5000个文件进行归并(类似与归并排序); 3.现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。 Step1：从这一天的日志数据中把访问百度的IP取出来，逐个写入到一个大文件中; Step2：注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件; Step3：找出每个小文中出现频率最大的IP(可以采用hash_map进行频率统计，然后再找出频率最大的几个)及相应的频率; Step4：在这1000个最大的IP中，找出那个频率最大的IP，即为所求。 4.一亿个数据选取其中最大1000条？ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 17:48:51 "},"Algorithms/Java/":{"url":"Algorithms/Java/","title":"Java实现","keywords":"","body":"Java实现 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 13:49:11 "},"Algorithms/知识点/树.html":{"url":"Algorithms/知识点/树.html","title":"知识点","keywords":"","body":"二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定 义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值， 在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。 几个概念 深度优先遍历 中序遍历 先序遍历 后序遍历 广度优先遍历（层次遍历） 第一步构建一个BinarySearchTree类function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; } 第二步(实现一些方法) insert(key)：向树中插入一个新的键。 inOrderTraverse：通过中序遍历方式遍历所有节点。 preOrderTraverse：通过先序遍历方式遍历所有节点。 postOrderTraverse：通过后序遍历方式遍历所有节点。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。 remove(key)：从树中移除某个键。insert function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key inOrderTraverse和中序遍历 function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key 先序遍历 function BinarySearchTree(arr) { ... // 先序遍历 this.preOrderTraverse = function (callBack) { preOrderTraverseNode(root, callBack); }; var preOrderTraverseNode = function(node,callBack) { if(!!node) { callBack(node.key); preOrderTraverseNode(node.left, callBack); preOrderTraverseNode(node.right, callBack); } } } function printNode(val) { console.log(val); } ... 后序遍历 function BinarySearchTree(arr) { ... // 后序遍历 this.postOrderTraverse = function (callBack) { postOrderTraverseNode(root, callBack); }; var postOrderTraverseNode = function(node,callBack) { if(!!node) { postOrderTraverseNode(node.left, callBack); postOrderTraverseNode(node.right, callBack); callBack(node.key); } } } function printNode(val) { console.log(val); } ... 广度优先（层次遍历） function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key 最小值和最大值 function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key 最难的删除值 function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key node.key) { node.right = removeNode(node.right, key); return node; } else { // 找到node // 第一种情况node是一个叶节点 if (node.right == null && node.left == null) { node = null return node; } // 第二种情况node只有一个叶节点 if (node.left == null) { node = node.right return node } else if(node.right == null){ node = node.left return node } // 第三种node有两个子节点 var minNode = findMinNode(node) node.key = minNode.key node.right = removeNode(node.right, minNode.key); return node } }; var findMinNode = function (node) { while(node.left && node.key !== null) { node = node.left; } return node } } function printNode(val) { console.log(val); } var tree = new BinarySearchTree(); tree.insert(1); tree.insert(2); tree.insert(3); tree.insert(6); tree.insert(5); tree.insert(3); tree.insert(7); tree.insert(8); tree.insert(9); tree.wideTraversal(printNode) tree.remove(9) tree.wideTraversal(printNode) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 17:17:20 "},"UseInJob/":{"url":"UseInJob/","title":"工作常用代码","keywords":"","body":"工作中常用到的代码 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-08 10:26:29 "},"UseInJob/Js.html":{"url":"UseInJob/Js.html","title":"Js ✘","keywords":"","body":"/* * 移动端rem适配，px:rem = 100:1 * 该适配兼容UC竖屏转横屏出现的BUG * 自定义设计稿的宽度：designWidth * 最大宽度:maxWidth * 这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(1000, 1000); babel-plugin-proposal-optional-chaining 遍历一个深层的树状结构数据时，总要去判断该中间节点的数据是否存在，之后再去取值或者对应的操作， 最常见的场景就是在对接后端的api了，假设现在有这么一个api返回obj ``` let person = { name: 'a', owner: { token: '54163sdf', permission: { usecar: true } } }, let usecar = person.owner.permission.usecar() >我们需要取到person下面的owner下面的permission权限中用车权限usecar，上面的代码是我们大部分时候的做法，问题来了，我们怎么能够保证对象的中间节点数据都存在的呢，保不齐就是一个error. ### 常规办法 大部分时候我们的做法是判断取值或者引入带三方库像lodash等 if (person && person.owner && person.owner.permission) { let usecar = person.owner.permission.usecar, } _.get(person, 'owner.permission.usecar'); ### 应运而生 可选链(Optionalchaining)，在此背景下，目前已经进入了草案stage2阶段，相信很快就会大规模使用了，它使我们能检查一个对象上面的某属性是否为null或者undefined，如果是在则返回undefined，而不会报错。 // 使用示例 let usecar = person?.owner?.permission?.usecar ?? true; 有没有很酷，再也不用为了解决容错而写过多重复代码了，简单说下工作原理, 操作符检查 ?. 会检查操作符左边的值是否为 null 或 undefined。如果是，这个表达式就终止然后返回 undefined。否则，这个表达式继续执行检查通过! 另外配合stage2中的另一新特性 Nullish coalescing operator（??运算符），我们可以很方便的处理类似取值默认值的情况。 语法 // Optional Chaining 的语法有三种使用场景： obj?.prop // optional static property access obj?.[expr] // optional dynamic property access func?.(...args) // optional function or method call 至于为什么语法不是 obj?prop， 这种简洁一点的表达方式，在 FAQ 中有提到这个例子： obj?[expr].filter(fun):0 引擎难以判断 obj?[expr] 是 Optional Chaning，亦或这是一个普通的三元运算语句. 详细对于该提议（Optional Chaining）的分析，推荐阅读下面这篇文章： 可选链草案分析 ### 使用问题 因为现在还是提案，浏览器还没有很好的支持，现在想在项目中使用是不可能的，不过总有大牛默默的帮我们铺平了道路，对应的babel插件已经存在， babel-plugin-proposal-optional-chaining, 下面我们简单看看该插件转义后的代码时啥样的? const babel = require('@babel/core'); const code = 'const obj = {}; const baz = obj?.foo?.foo1'; const output = babel.transformSync(code, { plugins: [\"@babel/plugin-proposal-optional-chaining\"], }); console.log(output.code); 下面是编译后的代码： var _obj$foo; const obj = {}; const baz = obj === null || obj === void 0 ? void 0 : (_obj$foo = obj.foo) === null || _obj$foo === void 0 ? void 0 : _obj$foo.foo1; ``` 这样看上去是不是可以更好的理解该特性了，注意: 该bebel插件并不支持Nullish coalescing operator（?? 运算符）。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-26 14:48:08 "},"Database/":{"url":"Database/","title":"数据库","keywords":"","body":"数据库 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-08 16:48:18 "},"Database/InterView/查询学生成绩相关.html":{"url":"Database/InterView/查询学生成绩相关.html","title":"面试 ✘","keywords":"","body":"如图有这样一张成绩表： 首先要理解group by 含义：“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。 先来看这样一条sql语句：select subject,max(score) from grade GROUP BY subject 这样正确的得出了每一科的最高分以及科目的名称。那是不是再在后面加个name就可以得出对应的学生的名字呢？我们可以试试：select subject,max(score),name from grade GROUP BY subject 一看有结果以为成功了，但是对比数据后发现是错的，学生姓名和分数没对应上。如果你认为是成功的是因为对group by理解的不够，我也不知道这样查询为什么能出来结果，我使用的mysql数据库，如果是oracle的话就会报错。 注意：因为在select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。 所以这样是错误的。 group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中，常见的聚合函数如下表： 函数 作用 支持性 sum(列名) 求和 max(列名) 最大值 min(列名) 最小值 avg(列名) 平均值 first(列名) 第一条记录 仅Access支持 last(列名) 最后一条记录 仅Access支持 count(列名) 统计记录数 注意和count(*)的区别 我们还是分析要求，通过要求来写sql语句。 这里提供几种方法： 我们已经通过group by分组来获得每一科的最高分以及科目名称，把它作为第一句sql，，然后再查询一下score表，找到学科和分数都相同的记录:（子sql语句作为主sql语句的一部分） 注：a. 表示a表中所有的字段，b.表示b表中所有的字段 select b.* from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 结果如下： 对比发现数据是对的。 拓展问法：用一句SQL查出所有课程成绩最高和最低的学生及其分数。 首先，通过分组获得每个学科的最高分以及最低分： select subject,max(score),MIN(score) from grade GROUP BY subject 结果如下： 那我们如何把最高分对应的学生名字和最低分对应的名字放入呢，而且要求的数据展示是最高分一行，最低分一行。所以这样行不通。 通过上面的第一个问题得出的思路： select b.* from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 这样既然能得到每个学科的最高分，学生名字，学科名，那同样把max（score）改成min（score）不就可以获得最低分，学生名字，学科名字了吗？现在重点是如何把两条sql语句查询出来的结果整合到一起。 select b.* from (select subject,min(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 此时想到了sql的关键字 : UNION的定义 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 所以得出的sql是这样的： select b.* from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score UNION select b.* from (select subject,min(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 得出的结果是： 这样就ok了。如果还想添加一些东西。例如添加一列说明这个分数是最低分或者最高分。 select b.*,\"最高分\" from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score UNION select b.*,\"最低分\" from (select subject,min(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 原文链接：https://blog.csdn.net/u010827070/article/details/79712303 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-08 17:09:48 "},"Database/InterView/优化相关.html":{"url":"Database/InterView/优化相关.html","title":"优化相关 ✘","keywords":"","body":"1.索引优化 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 问：select * from t where b = ? order by a如何索引优化？ MySQL索引通常是被用于提高WHERE条件的数据行匹配或者执行联结操作时匹配其它表的数据行的搜索速度。 MySQL也能利用索引来快速地执行ORDER BY和GROUP BY语句的排序和分组操作。 通过索引优化来实现MySQL的ORDER BY语句优化： ORDER BY的索引优化。如果一个SQL语句形如： SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort]; 在[sort]这个栏位上建立索引就可以实现利用索引进行order by 优化。 WHERE + ORDER BY的索引优化，形如： SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort]; 建立一个联合索引(columnX,sort)来实现order by 优化。 注意：如果columnX对应多个值，如下面语句就无法利用索引来实现order by的优化 SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort]; WHERE+ 多个字段ORDER BY SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10; 建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。 MySQL Order By不能使用索引来优化排序的情况 对不同的索引键做 ORDER BY ：(key1,key2分别建立索引) SELECT * FROM t1 ORDER BY key1, key2; 在非连续的索引键部分上做 ORDER BY：(key_part1,key_part2建立联合索引;key2建立索引) SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2; 同时使用了 ASC 和 DESC：(key_part1,key_part2建立联合索引) SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC; 用于搜索记录的索引键和做 ORDER BY 的不是同一个：(key1,key2分别建立索引) SELECT * FROM t1 WHERE key2=constant ORDER BY key1; 如果在WHERE和ORDER BY的栏位上应用表达式(函数)时，则无法利用索引来实现order by的优化 SELECT * FROM t1 ORDER BY YEAR(logindate) LIMIT 0,10; 特别提示: 1>mysql一次查询只能使用一个索引。如果要对多个字段使用索引，建立复合索引。 2>在ORDER BY操作中，MySQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5.in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 6.下面的查询也将导致全表扫描： select id from t where name like '李%' 若要提高效率，可以考虑全文检索。 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)='abc' name以abc开头的id，应改为: select id from t where name like 'abc%' 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12.不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 13.很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19.任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21.避免频繁创建和删除临时表，以减少系统表资源的消耗。 22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。 29.尽量避免大事务操作，提高系统并发能力。 30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-08 17:46:17 "}}