{"./":{"url":"./","title":"Introduction","keywords":"","body":"杂项涉及到技术，面试的gitbook Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-02 22:00:57 "},"webpack/原理分析/插件原理分析.html":{"url":"webpack/原理分析/插件原理分析.html","title":"webpack插件原理分析 ✘","keywords":"","body":"webpack版本号为4.35.0 创建一个最基础的Plugin 首先我们不来扯别的原理，先来看看一个最为基本的webpack plugin结构。 // 声明一个js函数 function ExamplePlugin(option) { this.option = option } // 在函数的原型上声明一个apply方法 ExamplePlugin.prototype.apply = function(compiler) {} 你也可以采用ES6来进行编写 // 采用ES6 class ExamplePlugin { constructor(option) { this.option = option } apply(compiler) {} } 以上就是一个最为基本的plugin结构。webpack plugin最为核心的便是这个apply方法。 webpack执行时，先生成了插件的实例对象，之后会调用插件上的apply方法，并将compiler对象(webpack实例对象，包含了webpack的各种配置信息...)作为参数传递给apply。 之后我们便可以在apply方法中使用compiler对象去监听webpack在不同时刻触发的各种事件来进行我们想要的操作了。 接下来看一个简单的示例 class plugin1 { constructor(option) { this.option = option console.log(option.name + '初始化') } apply(compiler) { console.log(this.option.name + ' apply被调用') //在webpack的emit生命周期上添加一个方法 compiler.hooks.emit.tap('plugin1', (compilation) => { console.log('生成资源到 output 目录之前执行的生命周期') }) } } class plugin2 { constructor(option) { this.option = option console.log(option.name + '初始化') } apply(compiler) { console.log(this.option.name + ' apply被调用') //在webpack的afterPlugins生命周期上添加一个方法 compiler.hooks.afterPlugins.tap('plugin2', (compilation) => { console.log('webpack设置完初始插件之后执行的生命周期') }) } } module.exports = { entry: './index.js', output: { filename: 'bundle.js' }, plugins: [ new plugin1({ name: 'plugin1' }), new plugin2({ name: 'plugin2' }) ] } //执行webpack命令后输出结果如下: /* plugin1初始化 plugin2初始化 plugin1 apply被调用 plugin2 apply被调用 webpack设置完初始插件之后执行的生命周期 生成资源到 output 目录之前执行的生命周期 */ 首先webpack会按顺序实例化plugin对象，之后再依次调用plugin对象上的apply方法。 也就是对应输出 plugin1初始化、plugin2初始化、 plugin1 apply被调用、plugin2 apply被调用。 在webpack源代码中我们也可以看到这么一行，options.plugins便是配置文件中的被实例化的plugin数组。 之前我们也提到了，webpack在运行过程中会触发各种事件，而在apply方法中我们能接收一个compiler对象，我们可以通过这个对象监听到webpack触发各种事件的时刻，然后执行对应的操作函数。这套机制类似于Node.js的EventEmitter，总的来说就是一个发布订阅模式。 compiler.hooks中定义了各式各样的事件钩子，这些钩子会在不同的时机被执行。而上文中的compiler.hooks.emit和compiler.hooks.afterPlugin这两个生命周期钩子，分别对应了设置完初始插件以及生成资源到 output 目录之前这两个时间节点，afterPlugin是在emit之前被触发的，所以输出顺序更靠前。 compiler对象上具体的钩子也可以查看官方文档 compiler钩子。 在继续记下来的内容之前，我们先来对compiler和compilation做一个更为详细的介绍。 compiler和compilation介绍 webpack的compiler模块是其核心部分。其包含了webpack配置文件传递的所有选项，包含了诸如loader、plugins等信息。 我们可以看看Compiler类中定义的一些核心方法。 //继承自Tapable类，使得自身拥有发布订阅的能力 class Compiler extends Tapable { //构造函数，context实际传入值为process.cwd()，代表当前的工作目录 constructor(context) { super(); // 定义了一系列的事件钩子，分别在不同的时刻触发 this.hooks = { shouldEmit: new SyncBailHook([\"compilation\"]), done: new AsyncSeriesHook([\"stats\"]), //....更多钩子 }; this.running = true; //其他一些变量声明 } //调用该方法之后会监听文件变更，一旦变更则重新执行编译 watch(watchOptions, handler) { this.running = true; return new Watching(this, watchOptions, handler) } //用于触发编译时所有的工作 run(callback) { //编译之后的处理，省略了部分代码 const onCompiled = (err, compilation) => { this.emitAssets(compilation, err => {...}) } } //负责将编译输出的文件写入本地 emitAssets(compilation, callback) {} //创建一个compilation对象，并将compiler自身作为参数传递 createCompilation() { return new Compilation(this); } //触发编译，在内部创建compilation实例并执行相应操作 compile() {} //以上核心方法中很多会通过this.hooks.someHooks.call来触发指定的事件 } 可以看到，compiler中设置了一系列的事件钩子和各种配置参数，并定义了webpack诸如启动编译、观测文件变动、将编译结果文件写入本地等一系列核心方法。在plugin执行的相应工作中我们肯定会需要通过compiler拿到webpack的各种信息。 接下来看看compilation 如果把compiler算作是总控制台，那么compilation则专注于编译处理这件事上。 在启用Watch模式后，webpack将会监听文件是否发生变化，每当检测到文件发生变化，将会执行一次新的编译，并同时生成新的编译资源和新的compilation对象。 compilation对象中包含了模块资源、编译生成资源以及变化的文件和被跟踪依赖的状态信息等等，以供插件工作时使用。如果我们在插件中需要完成一个自定义的编译过程，那么必然会用到这个对象。 注意: 在webpack-dev-server和webpack-dev-middleware里Watch模式默认开启 插件编写示例 首先看一个插件示例，这个插件在我们构建完相关的文件后，会输出一个记录所有构建文件名的filelist.md文件。 class myPlugin { constructor(option) { this.option = option } apply(compiler) { compiler.hooks.emit.tap('myPlugin', compilation => { let filelist = '构建后的文件: \\n' for (var filename in compilation.assets) { filelist += '- ' + filename + '\\n'; } compilation.assets['filelist.md'] = { source: function() { return filelist }, size: function() { return filelist.length } } }) } } 在webpack的emit事件被触发之后，我们的插件会执行指定的工作，并将包含了编译生成资源的compilation作为参数传入了函数。我们可以通过compilation.assets拿到生成的文件，并获取其中的filename值。 同样的，我们也可以获取到构建后的文件内容。 接下来我们编写一个插件，将编译后的.js和.css文件进行gzip压缩。 const zlib = require('zlib') class gzipPlugin { constructor(option) { this.option = option } apply(compiler) { compiler.hooks.emit.tap('myPlugin', compilation => { for (var filename in compilation.assets) { if (/(.js|.css)/.test(filename)) { const gzipFile = zlib.gzipSync(compilation.assets[filename]._value, { //压缩等级 level: this.option.level || 7 }) compilation.assets[filename + '.gz'] = { source: function () { return gzipFile }, size: function () { return gzipFile.length } } } } }) } } //webpack.config.js中调用 { ... plugins: [ new gzipPlugin({ //设置压缩等级 level: 9 }) ] } 在这个插件中，我们同样监听compiler的emit事件，通过compilation.assets[filename]._value拿到文件内容，之后通过node自带的zlib库便可生成gzip文件了。 压缩后结果如下： 关于gzip的更多实践内容，可以去这篇文章查看 gzip压缩实践 异步事件钩子 webpack有些事件钩子是支持异步的。 具体可以通过tapAsync或者tapPromise来实现，接下来看分别看一个示例。 class AsyncPlugin { apply(compiler) { compiler.hooks.emit.tapAsync('asyncEmit', (compilation, callback) => { console.log('asyncEmit') setTimeout(() => { //异步完成后调用callback函数以继续流程 callback() }, 2000) }) } } class LogPlugin { apply(compiler) { compiler.hooks.emit.tapAsync('log', (compilation, callback) => { console.log('LogPlugin') }) compiler.hooks.done.tap('done', () => { console.log('done') }) } } //webpack.config.js中调用 { //... plugins: [ new AsyncPlugin(), new LogPlugin() ] } 以上代码输出顺序如下：asyncEmit，2秒后输出LogPlugin，紧跟着输出done。 使用tapPromise也同理，只需稍稍改变一下写法即可： class AsyncPlugin { apply(compiler) { compiler.hooks.emit.tapPromise('asyncEmit', compilation => { // 返回一个 Promise，在我们的异步任务完成时 resolve…… return new Promise((resolve, reject) => { setTimeout(function() { console.log('异步工作完成……') resolve() }, 1000); }) }) } } 结合Tapable在插件中使用自定义事件 Tapable是一个小型的库，类似于Node.js的EventEmitter类，负责自定义事件的注册和触发。 const {SyncHook} = require('tapable') class MainPlugin { apply(compiler) { //在hooks上自定义一个名为mainPlugin的钩子 compiler.hooks.mainPlugin = new SyncHook(['data']) //在webpack的environment事件触发时，广播自定义的mainPlugin事件，并传参 compiler.hooks.environment.tap('mainPlugin', (compilation) => { compiler.hooks.mainPlugin.call({ text: 'MainPlugin Call' }) }) } } class ListenPlugin { apply(compiler) { //监听自定义的mainPlugin被触发后，执行对应的函数，输出data.text compiler.hooks.mainPlugin.tap('listenPlugin', (data) => { console.log(data.text) }) } } //在webpack.config.js中引用 { // ... plugins: [ new MainPlugin(), new ListenPlugin() ] } 可以看到，借助tapable我们可以在webpack插件中自定义一些事件，用来进行特定的操作。插件之间也可以通过自定义事件互相调用部分逻辑。 注意：webpack自身的compiler、complation类也是继承自tapable来实现自身事件的注册和触发的。 通过以上的学习，我们接下来对上面的内容进行一个小小的总结。 webpack插件本质上是一个函数，它的原型上存在一个名为apply函数。webpack在初始化时 (在最早触发的environment事件之前) 会执行这个函数，并将一个包含了webpack所有配置信息的compiler作为参数传递给apply函数。 插件可以通过监听webpack本身触发的事件，在不同的时间阶段介入进行你想做的操作。 通过获取到的compiler对象，我们可以结合tapable在插件中自定义事件并将其广播。 在插件中监听一些特定的事件 (thisCompilation到afterEmit这个阶段的事件)，你可以拿到一个compilation对象，里面包含了各种编译资源，你可以通过操作这个对象对生成的资源进行添加和修改等操作。 通过上面的学习，相信大家插件的编写和大致原理有了一定的了解和认识。 webpack执行流程 最后我们来对webpack本身的执行流程进行一个概述，并将其和compiler事件钩子的触发时机进行一个对照。 webpack首先会读取配置文件，创建compiler对象，之后调用所有插件中的apply方法，并将参数传入其中。 在完成之后会广播environment这个事件钩子。然后读取配置文件的entry属性，遍历所有入口js文件。 接下来compiler对象会调用run方法，正式开始启动各方面的工作。 webpack开始为创建compilation对象做准备工作，首先会调用一个newCompilationParams方法，创建compilation对象所需的参数，紧接着立刻广播beforeCompile和compile这两个事件。之后compilation对象被创建，并广播compilation和make事件。 webpack接下来就开始了编译相关的工作。调用loader处理各模块之间的依赖，对每一个require调用对应的loader进行加工，再将加工后的文件处理生成AST抽象语法树并遍历这颗抽象语法树，构建该模块所依赖的模块。最后再将所有模块中的require语法转换成 webpack_require。 以上步骤完成之后webpack会触发emit事件，你可以在这个事件中通过compilation.assets拿到生成的各种资源。最后，webpack通过compiler的emitAssets方法将文件输出到对应的构建目录中，操作完成。 本文篇幅有限，对webpack流程只是进行了一个简单的介绍，但通过对流程的学习和了解，你能够更合理地运用、编写插件。 Webpack揭秘——走向高阶前端的必经之路 细说 webpack 之流程篇 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-28 14:01:20 "},"webpack/原理分析/souremap原理.html":{"url":"webpack/原理分析/souremap原理.html","title":"souremap原理 ✘","keywords":"","body":"https://segmentfault.com/a/1190000020213957 为啥用sourceMap 这几天在搞前端错误日志，做过线上发布的都知道，我们发布到生产环境的代码，一般都有如下步骤： 压缩混淆，减小体积 多个文件合并，减少HTTP请求数 通过编译或者转译，将其他语言编译成JavaScript 这三个步骤，都使得实际运行的代码不同于开发代码，不管是 debug 还是捕获线上的报错，都会变得困难重重。 解决这个问题的方法，就是使用sourceMap。 啥是sourceMap 简单说，sourceMap就是一个文件，里面储存着位置信息。 仔细点说，这个文件里保存的，是转换后代码的位置，和对应的转换前的位置。 有了它，出错的时候，通过断点工具可以直接显示原始代码，而不是转换后的代码。 sourceMap长啥样 通过webpack等工具，我们可以使用 sourceMap，这里不细说配置方法，可以看这里 sourceMap是一个map文件，与源码在同一个目录下。 在压缩代码的最后一行，会有这样的一个引用： //# sourceMappingURL=app.js.map 指向的就是我们的map文件。 sourceMap的格式如下： { version : 3, //SourceMap的版本，目前为3 sources: [\"foo.js\", \"bar.js\"], //转换前的文件，该项是一个数组，表示可能存在多个文件合并 names: [\"src\", \"maps\", \"are\", \"fun\"], //转换前的所有变量名和属性名 mappings: \"AACvB,gBAAgB,EAAE;AAClB;\", //记录位置信息的字符串 file: \"out.js\", //转换后的文件名 sourcesContent: [\"\\t// The module cache\\n\", \"xxx\"], //转换前的文件内容列表，与sources列表依次对应 sourceRoot : \"\" //转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空 } 其他的都很好解释，我们详细说一下mappings属性。 mappings 以\"AACvB,gBAAgB,EAAE;AAClB;\"为例: 每个分号对应转换后源码的一行； 每个逗号对应转换后源码的一个位置； AACvB代表该位置转换前的源码位置，以VLQ编码表示； 位置对应的原理 位置关系的保存经历了诸多步骤和优化，这个不详细说了，想看的可以看这里，我们只说最后的结果。 在每个位置中： 第一位，表示这个位置在【转换后代码】的第几列。 第二位，表示这个位置属于【sources属性】中的哪一个文件。 第三位，表示这个位置属于【转换前代码】的第几行。 第四位，表示这个位置属于【转换前代码】的第几列。 第五位，表示这个位置属于【names属性】的哪一个变量。 举例 假设现在有a.js，内容为feel the force，处理后为b.js，内容为the force feel 以the为例，它在输出中的位置是(0,0)，a.js是sources的第1个(这里只是举例)，输入中的位置是(0,5)，the是names的第2个(这里只是举例)。 那么映射关系为： 0 1 0 5 2 最后将 01052 表示为 Base64 VLQ 即可。 说明： 所有的值都是以0作为基数 第五位不是必需的，如果该位置没有对应names属性中的变量，可以省略第五位 每一位都采用VLQ编码表示，由于VLQ编码是可变长的，所以每一位可以由多个字符构成 为什么不保存转换后代码的行号，因为我们输出的文件总是一行，这样输出的行号就可以省略，因为都是0，没必要写出来 对于输出后的位置来说，到后边会发现它的列号特别大，为了避免这个问题，采用相对位置进行描述 相对位置是啥呢，看示意图： 第一次记录的输入位置和输出位置是绝对的，往后的输入位置和输出位置都是相对上一次的位置移动了多少，例如the的输出位置为(0,-10),因为the在feel的左边数10下才能到这个位置。 VLQ编码 VLQ是Variable-length quantity 的缩写，是一种通用的、使用任意位数的二进制来表示一个任意大的数字的一种编码方式。这种编码最早用于MIDI文件，后来被多种格式采用，它的特点就是可以非常精简地表示很大的数值，用来节省空间。 这种编码需要用最高位表示连续性，如果是1，代表这组字节后面的一组字节也属于同一个数；如果是0，表示该数值到这就结束了。 这样干巴巴说不太容易懂，还是举个栗子说明一下吧。 如何对数值137进行VLQ编码： 步骤 结果 将137改写成二进制形式 10001001 七位一组做分组，不足的补0 0000001 0001001 最后一组开头补0，其余补1 10000001 00001001 所以，137的VLQ编码形式为10000001 00001001 Base64 VLQ 与一般的VLQ的区别： 一个Base64字符只能表示 6bit(2^6)的数据 Base64 VLQ需要能够表示负数，于是用最后一位来作为符号标志位。 由于只能用6位进行存储，而第一位表示是否连续的标志，最后一位表示正数/负数。中间只有4位，因此一个单元表示的范围为[-15,15]，如果超过了就要用连续标识位了。 表示正负的方式： 如果这组数是某个数值的VLQ编码的第一组字节，那它的最后一位代表\"符号\"，0为正，1为负； 如果不是，这个位没有特殊含义，被算作数值的一部分。 我们再来举个栗子说明下使用方法。 如何对数值137进行Base64 VLQ编码： 步骤 结果 将137改写成二进制形式 10001001 127是正数，末位补0 100010010 五位一组做分组，不足的补0 01000 10010 将组倒序排序 10010 01000 最后一组开头补0，其余补1 110010 001000 转64进制 y和I 所以 137 通过Base64 VLQ表示为yl 可以看出： 在Base64 VLQ中，编码顺序是从低位到高位 而在VLQ中，编码顺序是从高位到低位 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-10-25 23:52:29 "},"webpack/webpack面试题.html":{"url":"webpack/webpack面试题.html","title":"面试必问 ✘","keywords":"","body":"目录  1.对webpack的构建流程原理  2.webpack，里面的webpack.config.js怎么配置  3.webpack本地开发怎么解决跨域的  4.如何配置多入口文件  5. webpack与grunt、gulp的不同  6. 有哪些常见的Loader？他们是解决什么问题的  7. 有哪些常见的Plugin？他们是解决什么问题的  8. Loader和Plugin的不同  9. webpack的构建流程是什么  10. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路  11. webpack的热更新是如何做到的？说明其原理  12. 如何利用webpack来优化前端性能  13. 如何提高webpack的构建速度  14. 怎么配置单页应用？怎么配置多页应用  15. 什么是bundle,什么是chunk，什么是module  16. 你的 import 被 webpack 编译成了什么？  17. tree shaking？  18. Babel 工作流程  19. Webpack和Rollup对比?  20. webpack的resolve.modules和 resolve.alias有什么区别?怎么回事哈啊?  21. webpack4 抽离公共代码和 webpack3的区别 1. 对webpack的了解 官方文档 2、webpack构建流程（原理） 从启动构建到输出结果一系列过程： （1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。 （2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。 （3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。 （4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。 （5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。 （6）输出完成：输出所有的chunk到文件系统。 注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，将项目当作一个整体，通过一个给定的的主文件，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包成一个或多个浏览器可识别的js文件 核心概念： 入口(entry) 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点） module.exports = { entry: './path/to/my/entry/file.js' }; 输出(output) output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist loader loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript） 插件(plugins) loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量 模式 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 module.exports = { mode: 'production' }; 2. webpack，里面的webpack.config.js怎么配置 let webpack = require('webpack'); module.exports = { entry:'./entry.js', //入口文件 output:{ //node.js中__dirname变量获取当前模块文件所在目录的完整绝对路径 path:__dirname, //输出位置 filename:'build.js' //输入文件 }, module:{ // 关于模块的加载相关，我们就定义在module.loaders中 // 这里通过正则表达式去匹配不同后缀的文件名，然后给它们定义不同的加载器。 // 比如说给less文件定义串联的三个加载器（！用来定义级联关系）： rules:[ { test:/\\.css$/, //支持正则 loader:'style-loader!css-loader' } ] }, //配置服务 devServer:{ hot:true, //启用热模块替换 inline:true //此模式支持热模块替换：热模块替换的好处是只替换更新的部分,而不是页面重载. }, //其他解决方案配置 resolve:{ extensions:['','.js','.json','.css','.scss'] }, //插件 plugins:[ new webpack.BannerPlugin('This file is create by baibai') ] } 3. webpack本地开发怎么解决跨域的 下载 webpack-dev-server 插件 配置 webpack.config.js 文件 // webpack.config.js var WebpackDevServer = require(\"webpack-dev-server\"); module.exports = { ... devServer: { ... port: '8088', //设置端口号 // 代理设置 proxy: { '/api': { target: 'http://localhost:80/index.php', // 目标代理 pathRewrite: {'^/api' : ''}, // 重写路径 secure: false, // 是否接受运行在 HTTPS 上 } } } } 4. 如何配置多入口文件 配置多个入口文件 entry: { home: resolve(__dirname, \"src/home/index.js\"), about: resolve(__dirname, \"src/about/index.js\") } 5. webpack与grunt、gulp的不同 三者都是前端构建工具 grunt 和 gulp 是基于任务和流的。找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程 webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能 webpack 与前者最大的不同就是支持代码分割，模块化（AMD,CommonJ,ES2015），全局分析 为什么选择webpack 6. 有哪些常见的Loader？他们是解决什么问题的 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS slint-loader：通过 SLint 检查 JavaScript 代码 babel-loader：把 ES6 转换成 ES5 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader 加载额外的 Source Map 文件，以方便断点调试 7. 有哪些常见的Plugin？他们是解决什么问题的 define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 AutoWebPlugin: 管理多个单页应用, 8. Loader和Plugin的不同 loader 加载器 Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件. Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力 在 module.rules 中配置，也就是说他作为模块的解析规则而存在，类型为数组 Plugin 插件 扩展 webpack 的功能，让 webpack 具有更多的灵活性 在 plugins 中单独配置。类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入 9. webpack的构建流程是什么 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果 初始化阶段 事件名 解释 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。 实例化 Compiler 用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。 加载插件 依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。 environment 开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。 entry-option 读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。 after-plugins 调用完所有内置的和配置的插件的 apply 方法。 after-resolvers 根据配置初始化完 resolver，resolver 负责在文件系统中寻找指定路径的文件。编译阶段 事件名 解释 run 启动一次新的编译 watch-run 和run类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译 compile 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上compiler对象。 compilation 当webpack以开发模式运行时，每当检测到文件变化，一次新的Compilation将被创建。一个Compilation对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation对象也提供了很多时间回调供插件做扩展。 make 一个新的Comilation创建完毕，即将从Entry开始读取文件，根据文件类型和配置的Loader对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。 after-compile 一次Compilation执行完成 invalid 当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致Webpack退出。 在编译阶段中，最重要的要数compilation事件了，因为在compilation阶段调用了Loader完成了每个模块的转换操作，在compilation阶段又包括很多小的事件，它们分别是： 事件名 解释 build-module 使用对应的Loader去转换一个模块 normal-module-loader 在用Loader对一个模块转换完后，使用acorn解析转换后的内容，输出对应的抽象语法树（AST），以方便Webpack后面对代码的分析 program 从配置的入口模块开始，分析其AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。 seal 所有模块及其依赖的模块都通过Loader转换完成后，根据依赖关系开始生成Chunk输出阶段 事件名 解释 should-emit 所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要 emit 确定好要输出哪些文件，执行文件输出，可以在这里获取和修改输出内容 after-emit 文件输出完毕 done 成功完成一次玩的编译和输出流程 failed 如果在编译和输出流程中遇到异常导致webpack退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因 在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个Chunk。在输出阶段会根据Chunk的类型，使用对应模板生成最终要输出的文件内容。 10. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路 编写 Loader 时要遵循单一原则，每个 Loader 只做一种\"转义\"工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback() 方法，将内容返回给 webpack 。 还可以通过 this.async()生成一个 callback 函数，再用这个 `callback`` 将处理后的内容输出出去 相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果 11. webpack的热更新是如何做到的？说明其原理 webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理： 首先要知道server端和client端都做了处理工作 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 具体可以参考 这里 12. 如何利用webpack来优化前端性能 压缩代码。删除多余的代码、注释、简化代码的写法等等方式 利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径 删除死代码 Tree Shaking）。将代码中永远不会走到的片段删除掉 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载，提取公共代码 给打包出来的文件名添加哈希，实现浏览器缓存文件 13. 如何提高webpack的构建速度 - 多入口情况下，使用CommonsChunkPlugin来提取公共代码 - 通过externals配置来提取常用库 - 利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。 - 使用Happypack 实现多线程加速编译 - 使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度 - 使用Tree-shaking和Scope Hoisting来剔除多余代码 参考 [这里](https://gaodaqian.com/webpack4/11%E6%8F%90%E5%8D%87%20webpack%20%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6.html) 14. 怎么配置单页应用？怎么配置多页应用 单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可 多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范 15. 什么是bundle,什么是chunk，什么是module bundle 是由 webpack 打包出来的文件， chunk 是指 webpack 在进行模块的依赖分析的时候，代码分割出来的代码块。 module是开发中的单个模块 16. 你的 import 被 webpack 编译成了什么？ import moduleName from 'xxModule'和import('xxModule')经过webpack编译打包后最终变成了什么？在浏览器中是怎么运行的？ import经过webpack打包以后变成一些Map对象，key为模块路径，value为模块的可执行函数； 代码加载到浏览器以后从入口模块开始执行，其中执行的过程中，最重要的就是webpack定义的c，负责实际的模块加载并执行这些模块内容，返回执行结果，其实就是读取Map对象，然后执行相应的函数； 当然其中的异步方法（import('xxModule')）比较特殊一些，它会单独打成一个包，采用动态加载的方式，具体过程：当用户触发其加载的动作时，会动态的在head标签中创建一个script标签，然后发送一个http请求，加载模块，模块加载完成以后自动执行其中的代码，主要的工作有两个，更改缓存中模块的状态，另一个就是执行模块代码。 17. tree shaking? 什么是 tree shaking，即 webpack 在打包的过程中会将没用的代码进行清除(dead code)。一般 dead code 具有一下的特征： 代码不会被执行，不可到达 代码执行的结果不会被用到 代码只会影响死变量（只写不读） 是不是很神奇，那么需要怎么做才能使 tree shaking 生效呢? 18. Babel 工作流程? > Babel 其实就是一个纯粹的 JavaScript 的编译器，任何一个编译器工作流程大致都可以分为如下三步： - Parser 解析源文件 - Transfrom 转换 - Generator 生成新文件 Babel 也不例外，如下图所示： ![img](img/aHR0cHM6Ly9vc2NpbWcub3NjaGluYS5uZXQvb3NjbmV0L3VwLWRiYjUxNDliNWU4NDQ4NjJmYjAzNTFjOGMzZjUwMGRiZDM2LkpQRUc.jpeg) > 因为 Babel 使用是 acorn 这个引擎来做解析，这个库会先将源码转化为抽象语法树 (AST)，再对 AST 作转换，最后将转化后的 AST 输出，便得到了被 Babel 编译后的文件。 那 Babel 是如何知道该怎么转化的呢？答案是通过插件，Babel 为每一个新的语法提供了一个插件，在 Babel 的配置中配置了哪些插件，就会把插件对应的语法给转化掉。插件被命名为 @babel/plugin-xxx 的格式。 19. Webpack和Rollup对比? Webpack和Rollup在不同场景下，都能发挥自身优势作用。Webpack对于代码分割和静态资源导入有着“先天优势”，并且支持热模块替换(HMR)，而Rollup并不支持，所以当项目需要用到以上，则可以考虑选择Webpack。但是，Rollup对于代码的Tree-shaking和ES6模块有着算法优势上的支持，若你项目只需要打包出一个简单的bundle包，并是基于ES6模块开发的，可以考虑使用Rollup。 其实Webpack从2.0开始支持Tree-shaking，并在使用babel-loader的情况下支持了es6 module的打包了，实际上，Rollup已经在渐渐地失去了当初的优势了。但是它并没有被抛弃，反而因其简单的API、使用方式被许多库开发者青睐，如React、Vue等，都是使用Rollup作为构建工具的。而Webpack目前在中大型项目中使用得非常广泛。 最后，用一句话概括就是：在开发应用时使用 Webpack，开发库时使用 Rollup。 21. webpack4 抽离公共代码和 webpack3的区别 从webpack4开始官方移除了commonchunk插件，改用了optimization属性进行更加灵活的配置，这也应该是从V3升级到V4的代码修改过程中最为复杂的一部分 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-10-26 10:39:03 "},"webpack/webpack4.html":{"url":"webpack/webpack4.html","title":"webpack4","keywords":"","body":" 安装前先npm初始化 本地服务 复制html 处理css 处理less 抽离css文件，通过link引入 压缩css和js 给css加上兼容浏览器的前缀 es6 转 es5 es 7的语法 全局变量引入 webpack图片打包 当图片小于多少，用base64 打包文件分类 希望输出的时候，给这些css\\img加上前缀，传到服务器也能访问 如果只希望处理图片 打包多页应用 配置source-map watch 改完代表重新打包实体 webpack的其他三个小插件 webpack 跨域 如果后端给的请求没有API 「跨域」 前端只想单纯mock数据 「跨域」 有服务端，不用代理, 服务端启动webpack 「跨域」 webpack解析resolve 但是每次引入都很长，如何优雅引入 省略扩展名 定义环境变量 区分两个不同的环境 webpack 优化 优化：当某些包是独立的个体没有依赖 优化：规则匹配设置范围 优化：忽略依赖中不必要的语言包 动态链接库 多线程打包happypack webpack 自带的优化 抽取公共代码 懒加载(延迟加载) 热更新(当页面改变只更新改变的部分，不重新打包) tapable介绍 - SyncHook tapable介绍 - SyncBailHook tapable介绍 - SyncWaterfallHook tapable介绍 - SyncLoopHook AsyncParallelHook 与 AsyncParallelBailHook AsyncParallelHook AsyncParallelBailHook 异步串行 —— AsyncSeriesHook 异步串行 —— AsyncSeriesWaterfallHook 手写webpack webpack分析及处理 创建依赖关系 ast递归解析 生成打包工具 增加loader 增加plugins loader 配置多个loader babel-loader实现 banner-loader实现(自创) 实现file-loader和url-loader less-loader和css-loader css-loader webpack 中的插件 文件列表插件 内联的webpack插件 打包后自动发布 安装前先npm初始化 npm init -y npm i webpack webpack-cli -D let path = require('path') // 相对路径变绝对路径 module.exports = { mode: 'production', // 模式 默认 production development entry: './src/index', // 入口 output: { filename: 'bundle.[hash:8].js', // hash: 8只显示8位 path: path.resolve(__dirname, 'dist'), publicPath: '' // // 给所有打包文件引入时加前缀，包括css，js，img，如果只想处理图片可以单独在url-loader配置中加publicPath } } 本地服务 npm i webpack-dev-server -D devServer: { port: 3000, progress: true // 滚动条 contentBase: './build' // 起服务的地址 open: true // 自动打开浏览器 compress： true // gzip压缩 } 复制html npm i html-webpack-plugin -D let HtmlWebpackPlugin = require('html-webpack-plugin') plugins: [ // 放着所有webpack插件 new HtmlWebpackPlugin({ // 用于使用模板打包时生成index.html文件，并且在run dev时会将模板文件也打包到内存中 template: './index.html', // 模板文件 filename: 'index.html', // 打包后生成文件 hash: true, // 添加hash值解决缓存问题 minify: { // 对打包的html模板进行压缩 removeAttributeQuotes: true, // 删除属性双引号 collapseWhitespace: true // 折叠空行变成一行 } }) ] html-webpack-plugin#options 处理css npm i css-loader style-loader -D // css-loader 作用：用来解析@import这种语法 // style-loader 作用：把 css 插入到head标签中 // loader的执行顺序： 默认是从右向左（从下向上） module: { // 模块 rules: [ // 规则 // style-loader 把css插入head标签中 // loader 功能单一 // 多个loader 需要 [] // 顺便默认从右到左 // 也可以写成对象方式 { test: /\\.css$/, // css 处理 // use: 'css-loader' // use: ['style-loader', 'css-loader'], use: [ // { // loader: 'style-loader', // options: { // insertAt: 'top' // 将css标签插入最顶头 这样可以自定义style不被覆盖 // } // }, MiniCssExtractPlugin.loader, 'css-loader', // css-loader 用来解析@import这种语法, 'postcss-loader' ] } ] } 处理less npm i less-loader { test: /\\.less$/, // less 处理 // use: 'css-loader' // use: ['style-loader', 'css-loader'], use: [ // { // loader: 'style-loader', // options: { // insertAt: 'top' // 将css标签插入最顶头 这样可以自定义style不被覆盖 // } // }, MiniCssExtractPlugin.loader, // 这样相当于抽离成一个css文件， 如果希望抽离成分别不同的css, 需要再引入MiniCssExtractPlugin，再配置 'css-loader', // css-loader 用来解析@import这种语法 'postcss-loader', 'less-loader' // less-loader less -> css // sass node-sass sass-loader // stylus stylus-loader ] } less-loader 抽离css文件，通过link引入 yarn add mini-css-extract-plugin -D mini-css-extract-plugin let MiniCssExtractPlugin = require('mini-css-extract-plugin') // 压缩css plugins: [ new MiniCssExtractPlugin({ filename: 'css/main.css' }) ] { test: /\\.css$/, // css 处理 // use: 'css-loader' // use: ['style-loader', 'css-loader'], use: [ // { // loader: 'style-loader', // options: { // insertAt: 'top' // 将css标签插入最顶头 这样可以自定义style不被覆盖 // } // }, // 此时不需要style-loader MiniCssExtractPlugin.loader, // 抽离 'css-loader', // css-loader 用来解析@import这种语法, 'postcss-loader' ] } 抽离css插件文件时可使用optimize-css-assets-webpack-plugin优化压缩css以及js文件 压缩css和js // 用了`mini-css-extract-plugin`抽离css为link需使用`optimize-css-assets-webpack-plugin`进行压缩css,使用此方法压缩了css需要`uglifyjs-webpack-plugin`压缩js const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\") const UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\") module.exports = { optimization: { // 优化项 minimizer: [ new UglifyJsPlugin({ // 优化js cache: true, // 是否缓存 parallel: true, // 是否并发打包 // sourceMap: true // 源码映射 set to true if you want JS source maps }), new OptimizeCSSAssetsPlugin({}) // css 的优化 ] }, mode: 'production', entry: '', output: {}, } 给css加上兼容浏览器的前缀 yarn add postcss-loader autoprefixer -D // css { test: /\\.css$/, // css 处理 // use: 'css-loader' // use: ['style-loader', 'css-loader'], use: [ // { // loader: 'style-loader', // options: { // insertAt: 'top' // 将css标签插入最顶头 这样可以自定义style不被覆盖 // } // }, MiniCssExtractPlugin.loader, 'css-loader', // css-loader 用来解析@import这种语法, 'postcss-loader' ] } // less { test: /\\.less$/, // less 处理 // use: 'css-loader' // use: ['style-loader', 'css-loader'], use: [ // { // loader: 'style-loader', // options: { // insertAt: 'top' // 将css标签插入最顶头 这样可以自定义style不被覆盖 // } // }, MiniCssExtractPlugin.loader, // 这样相当于抽离成一个css文件， 如果希望抽离成分别不同的css, 需要再引入MiniCssExtractPlugin，再配置 'css-loader', // css-loader 用来解析@import这种语法 'postcss-loader', 'less-loader' // less-loader less -> css // sass node-sass sass-loader // stylus stylus-loader ] }, postcss 需要配置文档 postcss.config1.js postcss-loader module.exports = { plugins: [ require('autoprefixer') ] } es6 转 es5 npm i babel-loader @babel/core @babel/preset-env -D module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ //预设 '@babel/preset-env' ], plugins:[ // 转es7的语法 [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], [\"@babel/plugin-proposal-class-properties\", { \"loose\" : true }] ] } }, exclude: /node_modules/ } ] } } 转es7的语法 // 转class npm i @babel/plugin-proposal-class-properties -D // 转装饰器 npm i @babel/plugin-proposal-decorators -D 配置如上 其他不兼容的高级语法 使用 @babel/polyfill 语法检查 eslint npm i eslint eslint-loader -S 根目录添加 .eslintrc.json 配置文件 module.exports = { module: { rules: [ { test: /\\.js$/, use: { loader: 'eslint-loader', options: { enforce: 'pre' // previous优先执行 post-普通loader之后执行 } } }, { test: /\\.js$/, // mormal 普通的loader use: { loader: 'babel-loader', options: { presets: [ //预设 '@babel/preset-env' ] } }, exclude: /node_modules/ } ] } } 全局变量引入 jquery的引入 npm i jquery -S let webpack = require('webpack') new webpack.ProvidePlugin({ $: 'jquery' }) 其他情况 暴露全局 npm i expose-loader -D 暴露全局的loader 法1： 可以在js中 import $ from 'expose-loader?$!jquery' // 全局暴露jquery为$符号 可以调用window.$ 法2： 也可在webpack.config.js 中配置 rules module.exports = { module: { rules: [ { test: require.resolve('jquery'), use: 'expose-loader?$' } ] } } 以后在.js文件中引入 import $ from 'jquery' 法3. 如何在每个模块中注入： let webpack = require('webpack') module.exports = { plugins: [ new webpack.ProvidePlugin({ $: 'jquery' }) ] } 之后代码内直接使用 $ 法4： 在index.html中通过script标签引入jquery, 但是在js中，用import会重新打包jquery,如何避免 从输出的bundle 中排除依赖 module.exports = { externals: { // 告知webpack是外部引入的，不需要打包 jquery: 'jQuery' } } 此时在index.js上 import $ from 'jquery' console.log($) webpack图片打包 js中创建 css中引入 yarn add file-loader -D 适合一二情况 module.export={ module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: 'file-loader' } ] } } 默认会内部生成一张图片到build,生成图片的路径返回回来 第一种情况: 图片地址要import引入，直接写图片的地址，会默认为字符串 import logo from './logo.png' let image = new Image() image.src = logo document.body.appendChild(image) 第二种情况: css-loader会将css里面的图片转为require的格式 div { background: url(\"./logo.png\"); } 第三种情况: 解析html中的image yarn add html-withimg-loader -D { test: /\\.html$/, use: 'html-withimg-loader' } 当图片小于多少，用base64 yarn add url-loader -D 如果过大，才用file-loader { test: /\\.(png|jpg|gif)$/, // 当图片小于多少，用base64,否则用file-loader产生真实的图片 use: { loader: 'url-loader', options: { limit: 200 * 1024, // 小于200k变成base64 // outputPath: '/img/', // 打包后输出地址 // publicPath: '' // 给资源加上域名路径 } } } 打包文件分类 1.图片: { test: /\\.(png|jpg|gif)$/, // 当图片小于多少，用base64,否则用file-loader产生真实的图片 use: { loader: 'url-loader', options: { limit: 1, // 200k 200 * 1024 outputPath: 'img/' // 打包后输出地址 在dist/img } } }, 2.css: plugins: [ new MiniCssExtractPlugin({ filename: 'css/main.css' }), ] 希望输出的时候，给这些css\\img加上前缀，传到服务器也能访问 output: { filename: 'bundle.[hash:8].js', // hash: 8只显示8位 path: path.resolve(__dirname, 'dist'), publicPath: 'http://www.mayufo.cn' // 给静态资源统一加 }, 如果只希望处理图片 { test: /\\.(png|jpg|gif)$/, // 当图片小于多少，用base64,否则用file-loader产生真实的图片 use: { loader: 'url-loader', options: { limit: 1, // 200k 200 * 1024 outputPath: '/img/', // 打包后输出地址 publicPath: 'http://www.mayufo.cn' } } } 打包多页应用 // 多入口 let path = require('path') let HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: { home: './src/index.js', other: './src/other.js' }, output: { filename: \"[name].js\", path: path.resolve(__dirname, 'dist2') }, plugins: [ new HtmlWebpackPlugin({ template: './index.html', filename: 'home.html', chunks: ['home'] }), new HtmlWebpackPlugin({ template: './index.html', filename: 'other.html', chunks: ['other', 'home'] // other.html 里面有 other.js & home.js }), ] } 配置source-map yarn add @babel/core @babel/preset-env babel-loader webpack-dev-server -D module.exports = { devtool: 'source-map' // 增加映射文件调试源代码 } 源码映射 会标识错误的代码 打包后生成独立的文件 大而全 「source-map」 不会陈胜单独的文件 但是可以显示行和列 「eval-source-map」 不会产生列有行，产生单独的映射文件 「cheap-module-source-map」 不会产生文件 集成在打包后的文件中 不会产生列有行 「cheap-module-eval-source-map」 watch 改完代表重新打包实体 module.exports = { watch: true, watchOptions: { poll: 1000, // 每秒监听1000次 aggregateTimeout: 300, // 防抖，当第一个文件更改，会在重新构建前增加延迟 ignored: /node_modules/ // 对于某些系统，监听大量文件系统会导致大量的 CPU 或内存占用。这个选项可以排除一些巨大的文件夹， }, } webpack的其他三个小插件 cleanWebpackPlugin 每次打包之前删掉dist目录 yarn add clean-webpack-plugin -D clean-webpack-plugin const CleanWebpackPlugin = require('clean-webpack-plugin'); module.exports = { output: { path: path.resolve(process.cwd(), 'dist'), }, plugins: [ new CleanWebpackPlugin('./dist') ] } copyWebpackPlugin 一些静态资源也希望拷贝的dist中 yarn add copy-webpack-plugin -D const CopyWebpackPlugin = require('copy-webpack-plugin') module.exports = { plugins: [ new CopyWebpackPlugin([ {from: 'doc', to: './dist'} ]) ] } bannerPlugin内置模块 版权声明 const webpack = require('webpack'); new webpack.BannerPlugin('hello world') // or new webpack.BannerPlugin({ banner: 'hello world'}) webpack 跨域 设置一个服务,由于webpack-dev-server内含express express server.js // express let express = require('express') let app = express(); app.get('/api/user', (res) => { res.json({name: 'mayufo'}) }) app.listen(3000) // 服务端口在3000 写完后记得node server.js 访问 http://localhost:3000/api/user 可见内容 index.js // 发送一个请求 let xhr = new XMLHttpRequest(); // 默认访问 http://localhost:8080 webpack-dev-server 的服务 再转发给3000 xhr.open('GET', '/api/user', true); xhr.onload = function () { console.log(xhr.response) } xhr.send(); webpack.config.js module.exports = { devServer: { proxy: { '/api': 'http://localhost:3000' } }, } 1.如果后端给的请求没有API 「跨域」 // express let express = require('express') let app = express(); app.get('/user', (res) => { res.json({name: 'mayufo'}) }) app.listen(3000) // 服务端口在3000 请求已api开头, 转发的时候再删掉api devServer: { proxy: { '/api': { target: 'http://localhost:3000', pathRewrite: {'^/api': ''} } } } 2.前端只想单纯mock数据 「跨域」 devServer: { // proxy: { // '/api': 'http://localhost:3000' // 配置一个代理 // } // proxy: { // 重写方式 把请求代理到express 上 // '/api': { // target: 'http://localhost:3000', // pathRewrite: {'^/api': ''} // } // } before: function (app) { // 勾子 app.get('/api/user', (req, res) => { res.json({name: 'tigerHee'}) }) } }, 3.有服务端，不用代理, 服务端启动webpack 「跨域」 server.js中启动webpack yarn add webpack-dev-middleware -D server.js // express let express = require('express') let webpack = require('webpack') let app = express(); // 中间件 let middle = require('webpack-dev-middleware') let config = require('./webpack.config') let compiler = webpack(config) app.use(middle(compiler)) app.get('/user', (req, res) => { res.json({name: 'mayufo'}) }) app.listen(3000) webpack解析resolve 以bootstrap为例 npm install bootstrap -D index.js import 'bootstrap/dist/css/bootstrap.css' 报错 ERROR in ./node_modules/bootstrap/dist/css/bootstrap.css 7:0 Module parse failed: Unexpected token (7:0) You may need an appropriate loader to handle this file type. | * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) | */ > :root { | --blue: #007bff; | --indigo: #6610f2; @ ./src/index.js 22:0-42 @ multi (webpack)-dev-server/client?http://localhost:8081 ./src/index.js 这是因为bootstrap 4.0的css引入了新的特性，CSS Variables 安装 npm install postcss-custom-properties --save-dev 配置webpack.config.js { test: /\\.css$/, use: ['style-loader', 'css-loader', { loader: 'postcss-loader', options: { plugins: (loader) => [ require(\"postcss-custom-properties\") ] } }] } 但是每次引入都很长，如何优雅引入 resolve: { // 在当前目录查找 modules: [path.resolve('node_modules')], alias: { 'bootstrapCss': 'bootstrap/dist/css/bootstrap.css' } }, import 'bootstrapCss' // 在node_modules查找 省略扩展名 extensions: resolve: { // 在当前目录查找 modules: [path.resolve('node_modules')], // alias: { // 'bootstrapCss': 'bootstrap/dist/css/bootstrap.css' // }, mainFields: ['style', 'main'], // 先用bootstrap中在package中的style,没有在用main // mainFiles: [] // 入口文件的名字 默认index extensions: ['.js', '.css', '.json'] // 当没有拓展命的时候，先默认js、次之css、再次之json }, 定义环境变量 DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。 let url = '' if (DEV === 'dev') { // 开发环境 url = 'http://localhost:3000' } else { // 生成环境 url = 'http://www.mayufo.cn' } webpack.config.js new webpack.DefinePlugin({ // DEV: '\"production\"', DEV: JSON.stringify('production'), FLAG: 'true', // 布尔 EXPRESSION: '1 + 1' // 字符串 如果希望是字符串 JSON.stringify('1 + 1') }) 区分两个不同的环境 分别配置不同的环境 webpack.base4.js 基础配置 webpack.dev4.js 开发环境 webpack.prod4.js 生产环境 yarn add webpack-merge -D npm run build -- -- config webpack.dev4.js npm run build -- -- config webpack.build.js 官方文档 webpack.base4.js let path = require('path') let HtmlWebpackPlugin = require('html-webpack-plugin') let CleanWebpackPlugin = require('clean-webpack-plugin') module.exports = { entry: { home: './src/index.js' }, output: { filename: \"[name].js\", path: path.resolve(process.cwd(), 'dist3') }, module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ] } } }, { test: /\\.css$/, use: ['style-loader', 'css-loader', { loader: 'postcss-loader', options: { plugins: (loader) => [ require(\"postcss-custom-properties\") ] } }] } ] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html' }) ] } webpack.dev4.js let merge = require('webpack-merge') let base = require('./webpack.base4.js') module.exports = merge(base, { mode: 'development', devServer: {}, devtool: 'source-map' }) webpack.prod4.js let merge = require('webpack-merge') let base = require('./webpack.base4.js') module.exports = merge(base, { mode: 'production' }) package.json \"scripts\": { \"build\": \"webpack --config webpack.prod4.js\", \"dev\": \"webpack-dev-server --config webpack.dev4.js\" }, webpack 优化 yarn add webpack webpack-cli html-webpack-plugin @babel/core babel-loader @babel/preset-env @babel/preset-react -D webpack.config.js let path = require('path') let HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'main.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } } }, ] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html' }), ] } 优化：当某些包是独立的个体没有依赖 以jquery为例，yarn add jquery -D,它是一个独立的包没有依赖，可以在webpack配置中，配置它不再查找依赖 module: { noParse: /jquery/, // 不用解析某些包的依赖 rules: [ { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } } }, ] } 运行npx webpack 从2057ms -> 1946 ms 优化：规则匹配设置范围 rules: [ { test: /\\.js$/, exclude: '/node_modules/', // 排除 include: path.resolve('src'), // 在这个范围内 use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } } } 尽量实用include,不使用exclude,使用绝对路径 优化：忽略依赖中不必要的语言包 yarn add moment webpack-dev-server -D 忽略掉moment的其他语言包 let webpack = require('webpack') plugins: [ new webpack.IgnorePlugin(/\\.\\/locale/, /moment/) ] index.js import moment from 'moment' let r = moment().endOf('day').fromNow() // 距离现在多少天 console.log(r); 从 1.2MB 到 800kb 动态链接库 yarn add react react-dom 正常使用 webpack.config.js { test: /\\.js$/, exclude: '/node_modules/', include: path.resolve('src'), use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } } } index.js import React from 'react' import {render} from 'react-dom' render(111111, window.root) index.html 独立的将react react-dom 打包好, 打包好再引用，从而减少webpack每次都要打包react 创建webpack.config.react.js let path = require('path') let webpack = require('webpack') module.exports = { mode: 'development', entry: { // test: './src/test.js' react: ['react', 'react-dom'] }, output: { filename: '_dll_[name].js', // 产生的文件名 path: path.resolve(__dirname, 'dist'), library: '_dll_[name]', // 给输出的结果加个名字 // libraryTarget: 'var' // 配置如何暴露 library // commonjs 结果放在export属性上， umd统一资源模块, 默认是var }, plugins: [ new webpack.DllPlugin({ name: '_dll_[name]', // name === library path: path.resolve(__dirname, 'dist', 'manifest.json') // manifest.json 定义了各个模块的路径 }) ] } libraryTarget manifest.json就是一个任务清单or动态链接库，在这个清单里面查找react npx webpack --config webpack.config.react.js 在index.html增加引用 在webpack.config.js 中配置，现在动态链接库manifest.json中查找,如果没有再打包react plugins: [ new webpack.DllReferencePlugin({ manifest: path.resolve(__dirname, 'dist', 'manifest.json') }) ] DLLPlugin 和 DLLReferencePlugin npm run build 打包后的bunle.js文件变小 npm run dev 可以理解为先把react打包，后面每次都直接使用react打包后的结果 多线程打包happypack yarn add happypack webpack.config.js let Happypack = require('happypack') rules: [ { test: /\\.js$/, exclude: '/node_modules/', include: path.resolve('src'), use: 'happypack/loader?id=js' }, ] plugins: [ new Happypack({ id: 'js', use: [{ loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } }] }) ] js启用多线程，由于启用多线程也会浪费时间，因此当项目比较大的时候启用效果更好 css启用多线程 { test: /\\.css$/, use: 'happypack/loader?id=css' } new Happypack({ id: 'css', use: ['style-loader', 'css-loader'] }), webpack 自带的优化 test.js let sum = (a, b) => { return a + b + 'sum' } let minus = (a, b) => { return a - b + 'minus'; } export default { sum, minus } 使用import index.js import calc from './test' console.log(calc.sum(1, 2)); import在生产环境下会自动去除没有用的代码minus，这叫tree-shaking，将没有用的代码自动删除掉 index.js let calc = require('./test') console.log(calc); // es 6导出，是一个default的对象 console.log(calc.default.sum(1, 2)); require引入es6 模块会把结果放在default上,打包build后并不会把多余minus代码删除掉，不支持tree-shaking 作用域的提升 index.js let a = 1 let b = 2 let c = 3 let d = a + b + c console.log(d, '---------'); 打包出来的文件 console.log(r.default.sum(1,2));console.log(6,\"---------\") 在webpack中可以省略一些可以简化的代码 抽取公共代码 抽离自有模块 webpack.config.js module.exports = { optimization: { splitChunks: { // 分割代码块，针对多入口 cacheGroups: { // 缓存组 common: { // 公共模块 minSize: 0, // 大于多少抽离 minChunks: 2, // 使用多少次以上抽离抽离 chunks: 'initial' // 从什么地方开始, 从入口开始 } } } }, } SplitChunksPlugin 分别有a.js和b.js, index.js和other.js分别引入a和b两个js index.js import './a' import './b' console.log('index.js'); other.js import './a' import './b' console.log('other.js'); webpack.config.js module.exports = { optimization: { splitChunks: { // 分割代码块，针对多入口 cacheGroups: { // 缓存组 common: { // 公共模块 minSize: 0, // 大于多少抽离 minChunks: 2, // 使用多少次以上抽离抽离 chunks: 'initial' // 从什么地方开始, 从入口开始 } } } }, } 抽离第三方模块 比如jquery index.js 和 other.js分别引入 import $ from 'jquery' console.log($); 修改webpack.config.js配置： optimization: { splitChunks: { // 分割代码块，针对多入口 cacheGroups: { // 缓存组 common: { // 公共模块 minSize: 0, // 大于多少抽离 minChunks: 2, // 使用多少次以上抽离抽离 chunks: 'initial' // 从什么地方开始,刚开始 }, vendor: { priority: 1, // 增加权重, (先抽离第三方) test: /node_modules/, // 把此目录下的抽离 minSize: 0, // 大于多少抽离 minChunks: 2, // 使用多少次以上抽离抽离 chunks: 'initial' // 从什么地方开始,刚开始 } } }, }, 懒加载(延迟加载) yarn add @babel/plugin-syntax-dynamic-import -D source.js export default 'mayufo' index.js let button = document.createElement('button') button.innerHTML = 'hello' button.addEventListener('click', function () { console.log('click') // es6草案中的语法，jsonp实现动态加载文件 import('./source.js').then(data => { console.log(data.default) }) }) document.body.appendChild(button) webpack.config.js { test: /\\.js$/, exclude: '/node_modules/', include: path.resolve('src'), use: [{ loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ], plugins: [ '@babel/plugin-syntax-dynamic-import' ] } }] } 热更新(当页面改变只更新改变的部分，不重新打包) webpack.config.js plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html' }), new webpack.NameModulesPlugin(), // 打印更新的模块路径 new webpack.HotModuleReplacementPlugin() // 热更新插件 ] index.js import str from './source' console.log(str); if (module.hot) { module.hot.accept('./source', () => { console.log('文件更新了'); require('./source') console.log(str); }) } tapable介绍 - SyncHook tapable webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable，webpack中最核心的负责编译的Compiler和负责创建bundles的Compilation都是Tapable的实例。 SyncHook 不关心监听函数的返回值 yarn add tabable 1.use.js let {SyncHook} = require('tapable') // 结构同步勾子 class Lesson { constructor () { this.hooks = { // 订阅勾子 arch: new SyncHook(['name']), } } start () { this.hooks.arch.call('may') } tap () { // 注册监听函数 this.hooks.arch.tap('node', function (name) { console.log('node', name) }) this.hooks.arch.tap('react', function (name) { console.log('react', name) }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start() // 启动勾子 1.theory.js class SyncHook { // 勾子是同步的 constructor(args) { // args => ['name'] this.tasks = [] } tap (name, task) { this.tasks.push(task) } call (...args) { this.tasks.forEach((task) => task(...args)) } } let hook = new SyncHook(['name']) hook.tap('react', function (name) { console.log('react', name); }) hook.tap('node', function (name) { console.log('node', name); }) hook.call('jw') tapable介绍 - SyncBailHook SyncBailHook为勾子加了个保险，当return返回不是undefine就会停止 2.use.js let {SyncBailHook} = require('tapable') // 解构同步勾子 class Lesson { constructor () { this.hooks = { // 订阅勾子 arch: new SyncBailHook(['name']), } } start () { // 发布 this.hooks.arch.call('may') } tap () { // 注册监听函数,订阅 this.hooks.arch.tap('node', function (name) { console.log('node', name) return '停止学习' // 会停止 // return undefined }) this.hooks.arch.tap('react', function (name) { console.log('react', name) }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start() // 启动勾子 2.theory.js class SyncBailHook { // 勾子是同步的 constructor(args) { // args => ['name'] this.tasks = [] } tap (name, task) { this.tasks.push(task) } call (...args) { let ret; // 当前函数的返回值 let index = 0; // 当前要执行的第一个 do { ret = this.tasks[index](...args) } while (ret === undefined && index tapable介绍 - SyncWaterfallHook SyncWaterfallHook上一个监听函数的返回值可以传给下一个监听函数 3.use.js let {SyncWaterfallHook} = require('tapable') // 解构同步勾子 // waterfall 瀑布 class Lesson { constructor () { this.hooks = { // 订阅勾子 arch: new SyncWaterfallHook(['name']), } } start () { // 发布 this.hooks.arch.call('may') } tap () { // 注册监听函数,订阅 this.hooks.arch.tap('node', function (name) { console.log('node', name) return '学的不错' }) this.hooks.arch.tap('react', function (name) { console.log('react', name) }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start() // 启动勾子 3.theory.js class SyncWaterfallHook { // 勾子是同步的 - 瀑布 constructor(args) { // args => ['name'] this.tasks = [] } tap (name, task) { this.tasks.push(task) } call (...args) { let [first, ...others] = this.tasks; let ret = first(...args) others.reduce((a, b) => { return b(a); }, ret); } } let hook = new SyncWaterfallHook(['name']) hook.tap('react', function (name) { console.log('react', name); return 'react Ok' // return undefined }) hook.tap('node', function (name) { console.log('node', name); return 'node Ok' }) hook.tap('webpack', function (data) { console.log('webpack', data); }) hook.call('jw') tapable介绍 - SyncLoopHook SyncLoopHook当监听函数被触发的时候，如果该监听函数返回true时则这个监听函数会反复执行，如果返回 undefined 则表示退出循环 4.use.js let {SyncLoopHook} = require('tapable') // 解构同步勾子 // 不返回undefined 会多次执行 class Lesson { constructor () { this.index = 0 this.hooks = { // 订阅勾子 arch: new SyncLoopHook(['name']), } } start () { // 发布 this.hooks.arch.call('may') } tap () { // 注册监听函数,订阅 this.hooks.arch.tap('node', (name) => { console.log('node', name) return ++this.index === 3 ? undefined : '继续学' }) this.hooks.arch.tap('react', (name) => { console.log('react', name) }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start() // 启动勾子 4.theory.js class SyncLoopHook { // 勾子是同步的 - 瀑布 constructor(args) { // args => ['name'] this.tasks = [] } tap (name, task) { this.tasks.push(task) } call (...args) { this.tasks.forEach(task => { let ret do { ret = task(...args); } while(ret !== undefined) }) } } let hook = new SyncLoopHook(['name']) let total = 0 hook.tap('react', function (name) { console.log('react', name); return ++total === 3 ? undefined: '继续学' }) hook.tap('node', function (name) { console.log('node', name); }) hook.tap('webpack', function (data) { console.log('webpack', data); }) hook.call('jw') AsyncParallelHook 与 AsyncParallelBailHook 异步的勾子分两种串行和并行 并行等待所有并发的异步事件执行后执行回调 注册的三种方法 异步的注册方法tap 异步的注册方法tapAsync， 还有个回调参数 topPromise,注册promise 调用的三种 call (同步) callAsync （异步） promise （异步） 这里介绍的是异步并行的 AsyncParallelHook 不关心监听函数的返回值。 5.use.js let {AsyncParallelHook} = require('tapable') // 解构同步勾子 // 不返回undefined 会多次执行 class Lesson { constructor() { this.index = 0 this.hooks = { // 订阅勾子 arch: new AsyncParallelHook(['name']), } } start() { // 发布callAsync // this.hooks.arch.callAsync('may', function () { // console.log('end'); // }) // 另一种发布promise this.hooks.arch.promise('may').then(function () { console.log('end'); } ) } tap() { // 注册监听函数,订阅 // 注册tapAsync // this.hooks.arch.tapAsync('node', (name, callback) => { // setTimeout(() => { // console.log('node', name) // callback() // }, 1000) // }) // this.hooks.arch.tapAsync('react', (name, callback) => { // setTimeout(() => { // console.log('react', name) // callback() // }, 1000) // }) // 另一种订阅 tapPromise this.hooks.arch.tapPromise('node', (name) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('node', name) resolve() }, 1000) }) }) this.hooks.arch.tapPromise('react', (name) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('react', name) resolve() }, 1000) }) }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start() // 启动勾子 5.theory.js class AsyncParallelHook { // 勾子是同步的 - 瀑布 constructor(args) { // args => ['name'] this.tasks = [] } tapAsync(name, task) { this.tasks.push(task) } tapPromise(name, task) { this.tasks.push(task) } callAsync(...args) { let finalCallback = args.pop() // 拿出最终的函数 let index = 0 let done = () => { // 类似promise.all的实现 index++; if (index === this.tasks.length) { finalCallback(); } } this.tasks.forEach(task => { task(...args, done) // 这里的args 已经把最后一个参数删掉 }) } promise(...args) { let tasks = this.tasks.map(task => task(...args)) return Promise.all(tasks) } } let hook = new AsyncParallelHook(['name']) // hook.tapAsync('react', function (name, callback) { // setTimeout(() => { // console.log('react', name); // callback() // }, 1000) // }) // // hook.tapAsync('node', function (name, callback) { // setTimeout(() => { // console.log('node', name); // callback() // }, 1000) // }) // hook.tapAsync('webpack', function (name, callback) { // setTimeout(() => { // console.log('webpack', name); // callback() // }, 1000) // }) hook.tapPromise('react', function (name, callback) { return new Promise((resolve, reject) => { setTimeout(() => { console.log('react', name); resolve() }, 1000) }) }) hook.tapPromise('node', function (name, callback) { return new Promise((resolve, reject) => { setTimeout(() => { console.log('node', name); resolve() }, 1000) }) }) // // hook.callAsync('jw', function () { // console.log('end'); // }) hook.promise('jw').then(function () { console.log('end'); }) AsyncParallelBailHook 只要监听函数的返回值不为 null，就会忽略后面的监听函数执行，直接跳跃到callAsync等触发函数绑定的回调函数，然后执行这个被绑定的回调函数。 使用和原理与SyncBailHook相似 异步串行 —— AsyncSeriesHook 串行one by one 6.use.js let {AsyncSeriesHook} = require('tapable') // 解构同步勾子 class Lesson { constructor() { this.index = 0 this.hooks = { // 订阅勾子 arch: new AsyncSeriesHook(['name']), } } start() { // 发布 // this.hooks.arch.callAsync('may', function () { // console.log('end'); // }) // 另一种发布 this.hooks.arch.promise('may').then(function () { console.log('end'); } ) } tap() { // 注册监听函数,订阅 // this.hooks.arch.tapAsync('node', (name, callback) => { // setTimeout(() => { // console.log('node', name) // callback() // }, 1000) // }) // this.hooks.arch.tapAsync('react', (name, callback) => { // setTimeout(() => { // console.log('react', name) // callback() // }, 1000) // }) // 另一种订阅 this.hooks.arch.tapPromise('node', (name) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('node', name) resolve() }, 1000) }) }) this.hooks.arch.tapPromise('react', (name) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('react', name) resolve() }, 1000) }) }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start(); // 启动勾子 6.theory.js class AsyncSeriesHook { // constructor(args) { // args => ['name'] this.tasks = [] } tapAsync(name, task) { this.tasks.push(task) } tapPromise(name, task) { this.tasks.push(task) } callAsync(...args) { let finalCallback = args.pop() let index = 0; let next = () => { if (this.tasks.length === index) return finalCallback(); let task = this.tasks[index++]; task(...args, next); } next(); } promise(...args) { // 将promise串联起来 let [first, ...other] = this.tasks return other.reduce((p, n) => { return p.then(() => n (...args)) }, first(...args)) } } let hook = new AsyncSeriesHook(['name']) // hook.tapAsync('react', function (name, callback) { // setTimeout(() => { // console.log('react', name); // callback() // }, 1000) // }) // // hook.tapAsync('node', function (name, callback) { // setTimeout(() => { // console.log('node', name); // callback() // }, 1000) // }) // // hook.tapAsync('webpack', function (name, callback) { // setTimeout(() => { // console.log('webpack', name); // callback() // }, 1000) // }) hook.tapPromise('react', function (name, callback) { return new Promise((resolve, reject) => { setTimeout(() => { console.log('react', name); resolve() }, 1000) }) }) hook.tapPromise('node', function (name, callback) { return new Promise((resolve, reject) => { setTimeout(() => { console.log('node', name); resolve() }, 1000) }) }) // hook.callAsync('jw', function () { // console.log('end'); // }) hook.promise('jw').then(function () { console.log('end'); }) 异步串行 —— AsyncSeriesWaterfallHook 上一个监听函数的中的callback(err, data)的第二个参数,可以作为下一个监听函数的参数 7.use.js let {AsyncSeriesWaterfallHook} = require('tapable') // 解构同步勾子 class Lesson { constructor() { this.index = 0 this.hooks = { // 订阅勾子 arch: new AsyncSeriesWaterfallHook(['name']), } } start() { // 发布 this.hooks.arch.callAsync('may', function () { console.log('end'); }) // 另一种发布 // this.hooks.arch.promise('may').then(function () { // console.log('end'); // } // ) } tap() { // 注册监听函数,订阅 this.hooks.arch.tapAsync('node', (name, callback) => { setTimeout(() => { console.log('node', name) // callback(null, 'result') callback('error', 'result') // 如果放error, 会跳过直接后面的勾子，直接走到最终的 }, 1000) }) this.hooks.arch.tapAsync('react', (name, callback) => { setTimeout(() => { console.log('react', name) callback() }, 1000) }) // 另一种订阅 // this.hooks.arch.tapPromise('node', (name) => { // return new Promise((resolve, reject) => { // setTimeout(() => { // console.log('node', name) // resolve() // }, 1000) // }) // }) // this.hooks.arch.tapPromise('react', (name) => { // return new Promise((resolve, reject) => { // setTimeout(() => { // console.log('react', name) // resolve() // }, 1000) // }) // }) } } let l = new Lesson() l.tap(); //注册两个函数 l.start(); // 启动勾子 7.theory.js class AsyncSeriesWaterfallHook { // constructor(args) { // args => ['name'] this.tasks = [] } tapAsync(name, task) { this.tasks.push(task) } tapPromise(name, task) { this.tasks.push(task) } callAsync(...args) { let finalCallback = args.pop() let index = 0; let next = (err, data) => { let task = this.tasks[index] if(!task) return finalCallback(); if (index === 0) { // 执行的第一个 task(...args, next) } else { task(data, next) } index ++ } next(); } promise(...args) { // 将promise串联起来 let [first, ...other] = this.tasks return other.reduce((p, n) => { return p.then((data) => n(data)) }, first(...args)) } } let hook = new AsyncSeriesWaterfallHook(['name']) // hook.tapAsync('react', function (name, callback) { // setTimeout(() => { // console.log('react', name); // callback(null, '结果1') // }, 1000) // }) // // hook.tapAsync('node', function (name, callback) { // setTimeout(() => { // console.log('node', name); // callback(null, '结果2') // }, 1000) // }) // // hook.tapAsync('webpack', function (name, callback) { // setTimeout(() => { // console.log('webpack', name); // callback() // }, 1000) // }) // hook.tapPromise('react', function (name, callback) { return new Promise((resolve, reject) => { setTimeout(() => { console.log('react', name); resolve('result') }, 1000) }) }) hook.tapPromise('node', function (name, callback) { return new Promise((resolve, reject) => { setTimeout(() => { console.log('node', name); resolve() }, 1000) }) }) // // // hook.callAsync('jw', function () { // console.log('end'); // }) hook.promise('jw').then(function () { console.log('end'); }) 手写webpack 对应的may-pack项目 yarn add webpack webpack-cli -D webpack.config.js let path = require('path') module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } } npx webpack 生成文件bundle.js (function (modules) { var installedModules = {}; function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } // Load entry module and return exports return __webpack_require__(__webpack_require__.s = \"./src/index.js\"); }) ({ \"./src/a.js\": (function (module, exports, __webpack_require__) { eval(\"let b = __webpack_require__(/*! ./base/b */ \\\"./src/base/b.js\\\")\\n\\nmodule.exports = 'a'+ b\\n\\n\\n\\n//# sourceURL=webpack:///./src/a.js?\"); }), \"./src/base/b.js\": (function (module, exports) { eval(\"module.exports = 'b'\\n\\n\\n//# sourceURL=webpack:///./src/base/b.js?\"); }), \"./src/index.js\": (function (module, exports, __webpack_require__) { eval(\" let str = __webpack_require__(/*! ./a.js */ \\\"./src/a.js\\\")\\n\\n console.log(str);\\n\\n\\n//# sourceURL=webpack:///./src/index.js?\"); }) }); 新建项目用于自己的webpack,这里叫may-pack yarn init 如果在node里想执行命令，创建bin文件,再创建may-pack.js 配置package.json { \"name\": \"may-pack\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"bin\": { \"may-pack\": \"./bin/may-pack.js\" } } may-pack.js #! /usr/bin/env node // node环境 console.log('start'); 运行npm link将npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试 在想运行may-pack的项目中运行，npm link may-pack 得到 start webpack分析及处理 may-pack.js #! /usr/bin/env node // node环境 console.log('start'); let path = require('path') // 拿到配置文件webpack.config.js let config = require(path.resolve('webpack.config.js')); let Compiler = require('../lib/Compiler.js'); let compiler = new Compiler(config); // 标识运行编译 compiler.run() 创建lib文件Compiler.js let path = require('path') let fs = require('fs') class Compiler { constructor(config) { // entry output this.config = config // 需要保存入口文件的路径 this.entryId = ''; // './src/index.js' // 需要保存所有的模块依赖 this.modules = {}; this.entry = config.entry // 入口文件 // 工作目录 this.root = process.cwd(); // 当前运行npx的路径 } // 构建模块 buildModule(modulePath, isEntry) { } // 发射文件 emitFile() { // 用数据 渲染想要的 } run() { // 执行 创建模块的依赖关系 this.buildModule(path.resolve(this.root, this.entry), true) // path.resolve(this.root, this.entry) 得到入口文件的绝对路径 // 发射打包后的文件 this.emitFile() } } module.exports = Compiler 主要两个任务 拿到入口Id 解析模块，也就是实现buildModule方法 创建依赖关系 may-pack中Compiler.js let path = require('path') let fs = require('fs') // babylon 主要把源码转成ast Babylon 是 Babel 中使用的 JavaScript 解析器。 // @babel/traverse 对ast解析遍历语法树 负责替换，删除和添加节点 // @babel/types 用于AST节点的Lodash-esque实用程序库 // @babel/generator 结果生成 let babylon = require('babylon') let traverse = require('@babel/traverse').default; let type = require('@babel/types'); let generator = require('@babel/generator').default class Compiler { constructor(config) { // entry output this.config = config // 需要保存入口文件的路径 this.entryId = ''; // './src/index.js' // 需要保存所有的模块依赖 this.modules = {}; this.entry = config.entry // 入口文件 // 工作目录 this.root = process.cwd(); // 当前运行npx的路径 } // 拿到模块内容 getSource (modulePath) { let content = fs.readFileSync(modulePath, 'utf8') return content } parse (source, parentPath) { console.log(source, parentPath) } // 构建模块 buildModule(modulePath, isEntry) { // 拿到模块内容 let source = this.getSource(modulePath) // 得到入口文件的内容 // 模块id modulePath(需要相对路径) = modulePath(模块路径) - this.root(项目工作路径) src/index.js let moduleName = './' + path.relative(this.root, modulePath) console.log(source, moduleName); // 拿到代码 和相对路径 ./src/index.js if (isEntry) { this.entryId = moduleName } let {sourceCode, dependencies} = this.parse(source, path.dirname(moduleName)) // ./src // 把相对路径和模块中的内容对应起来 this.modules[moduleName] = sourceCode } // 发射文件 emitFile() { // 用数据 渲染想要的 } run() { // 执行 创建模块的依赖关系 this.buildModule(path.resolve(this.root, this.entry), true) // path.resolve(this.root, this.entry) 得到入口文件的绝对路径 console.log(this.modules, this.entryId); // 发射打包后的文件 this.emitFile() } } module.exports = Compiler ast递归解析 parse方法主要靠解析语法树来进行转义 babylon 主要把源码转成ast Babylon 是 Babel 中使用的 JavaScript 解析器。 @babel/traverse 对ast解析遍历语法树 负责替换，删除和添加节点 @babel/types 用于AST节点的Lodash-esque实用程序库 @babel/generator 结果生成 yarn add babylon @babel/traverse @babel/types @babel/generator may-pack中Compiler.js let path = require('path') let fs = require('fs') // babylon 主要把源码转成ast Babylon 是 Babel 中使用的 JavaScript 解析器。 // @babel/traverse 对ast解析遍历语法树 负责替换，删除和添加节点 // @babel/types 用于AST节点的Lodash-esque实用程序库 // @babel/generator 结果生成 let babylon = require('babylon') let traverse = require('@babel/traverse').default; let type = require('@babel/types'); let generator = require('@babel/generator').default class Compiler { constructor(config) { // entry output this.config = config // 需要保存入口文件的路径 this.entryId = ''; // './src/index.js' // 需要保存所有的模块依赖 this.modules = {}; this.entry = config.entry // 入口文件 // 工作目录 this.root = process.cwd(); // 当前运行npx的路径 } // 拿到模块内容 getSource (modulePath) { let content = fs.readFileSync(modulePath, 'utf8') return content } parse (source, parentPath) { // AST解析语法树 let ast = babylon.parse(source) let dependencies = []; // 依赖的数组 // https://astexplorer.net/ traverse(ast, { // 调用表达式 CallExpression(p) { let node = p.node; //对应的节点 if(node.callee.name === 'require') { node.callee.name = '__webpack_require__' let moduledName = node.arguments[0].value // 取到模块的引用名字 moduledName = moduledName + (path.extname(moduledName) ? '': '.js'); // ./a.js moduledName = './' + path.join(parentPath, moduledName) // './src/a.js' dependencies.push(moduledName) node.arguments = [type.stringLiteral(moduledName)] // 改掉源码 } } }) let sourceCode = generator(ast).code return { sourceCode, dependencies } } // 构建模块 buildModule(modulePath, isEntry) { // 拿到模块内容 let source = this.getSource(modulePath) // 得到入口文件的内容 // 模块id modulePath(需要相对路径) = modulePath(模块路径) - this.root(项目工作路径) src/index.js let moduleName = './' + path.relative(this.root, modulePath) // console.log(source, moduleName); // 拿到代码 和相对路径 ./src/index.js if (isEntry) { this.entryId = moduleName } // 解析把source源码进行改造， 返回一个依赖列表 let {sourceCode, dependencies} = this.parse(source, path.dirname(moduleName)) // ./src // 把相对路径和模块中的内容对应起来 this.modules[moduleName] = sourceCode dependencies.forEach(dep => { // 附模块的加载 递归加载 this.buildModule(path.join(this.root, dep), false) }) } // 发射文件 emitFile() { // 用数据 渲染想要的 } run() { // 执行 创建模块的依赖关系 this.buildModule(path.resolve(this.root, this.entry), true) // path.resolve(this.root, this.entry) 得到入口文件的绝对路径 console.log(this.modules, this.entryId); // 发射打包后的文件 this.emitFile() } } module.exports = Compiler 生成打包工具 使用ejs模板 may-pack中main.ejs (function (modules) { var installedModules = {}; function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } // Load entry module and return exports return __webpack_require__(__webpack_require__.s = \"\"); })({ \"\": (function (module, exports,__webpack_require__) { eval(``); }), }); ejs入门 yarn add ejs may-pack中Compiler.js let ejs = require('ejs') // 发射文件 emitFile() { // 用数据 渲染想要的 // 输出到那个目录下 let main = path.join(this.config.output.path, this.config.output.filename) let templateStr = this.getSource(path.join(__dirname, 'main.ejs')) let code = ejs.render(templateStr, { entryId: this.entryId, modules: this.modules}) this.assets = {} // 路径对应的代码 this.assets[main] = code fs.writeFileSync(main, this.assets[main]) } 在webpack-training项目中运行npx may-pack, 得到bundle.js,运行得到结果 增加loader 创建loader文件夹，创建less-loader1.js和style-loader1.js yarn add less less使用 less-loader1.js // 将less转为css let less = require('less') function loader(source) { let css = '' less.render(source, function (err, output) { css = output.css }) css = css.replace(/\\n/g, '\\\\n'); return css } module.exports = loader style-loader1.js // 将css插入到html头部 function loader(source) { console.log(111); let style = ` let style = document.createElement('style') style.innerHTML = ${JSON.stringify(source)} document.head.appendChild(style) ` return style } module.exports = loader // JSON.stringify(source) 可以将代码转为一行 webpack.config.js let path = require('path') module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.less$/, use: [ path.resolve(__dirname, 'loader', 'style-loader1'), path.resolve(__dirname, 'loader', 'less-loader1') ] } ] } } 创建index.less body { background: red } index.js let str = require('./a.js') require('./index.less') console.log(str); may-pack中Compiler.js // 拿到模块内容 getSource (modulePath) { // 匹配各种文件的规则 let rules= this.config.module.rules; // webpack.config.js 中rules的数组 let content = fs.readFileSync(modulePath, 'utf8') for (let i = 0; i = 0) { normalLoader() } } normalLoader() } } return content } 运行npx may-pack 增加plugins yarn add tapable may-pack中Compiler.js constructor(config) { // entry output this.config = config // 需要保存入口文件的路径 this.entryId = ''; // './src/index.js' // 需要保存所有的模块依赖 this.modules = {}; this.entry = config.entry // 入口文件 // 工作目录 this.root = process.cwd(); // 当前运行npx的路径 this.hooks = { entryOption: new SyncHook(), // 入口选项 compile: new SyncHook(), // 编译 afterCompile: new SyncHook(), // 编译完成 afterPlugins: new SyncHook(), // 编译完插件 run: new SyncHook(), // 运行 emit: new SyncHook(), // 发射 done: new SyncHook() // 完成 } // 如果传递了plugins参数 let plugins = this.config.plugins if (Array.isArray(plugins)) { plugins.forEach(plugin => { plugin.apply(this); // 这里只是appLy方法不是改变this指向 }) } this.hooks.afterPlugins.call() } 在webpack.config.js中写插件方法 class P { apply(compiler) { // 这里只是appLy方法不是改变this指向 // 绑定 compiler.hooks.emit.tap('emit', function () { console.log('emit'); }) } } class P1 { apply(compiler) { // 这里只是appLy方法不是改变this指向 // 绑定 compiler.hooks.afterPlugins.tap('emit', function () { console.log('afterPlugins'); }) } } module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.less$/, use: [ path.resolve(__dirname, 'loader', 'style-loader'), path.resolve(__dirname, 'loader', 'less-loader') ] } ] }, plugins: [ new P(), new P1() ] } 然后在各个地方调用 may-pack中may-pack.js ..... // 调用 compiler.hooks.entryOption.call() // 标识运行编译 compiler.run() may-pack中Compiler.js run() { this.hooks.run.call() this.hooks.compile.call() // 执行 创建模块的依赖关系 this.buildModule(path.resolve(this.root, this.entry), true) // path.resolve(this.root, this.entry) 得到入口文件的绝对路径 // console.log(this.modules, this.entryId); this.hooks.afterCompile.call() // 发射打包后的文件 this.emitFile() this.hooks.emit.call() this.hooks.done.call() } 运行npx may-pack loader 手写loader webapck.config.js let path = require('path') module.exports = { mode: 'development', entry: './src/index', output: { filename: 'build.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.js/, use: 'loader1' // 如何找到这个loader1 } ] }, } 创建loader文件loader1.js console.log(22); function loader(source) { // loader的参数就是源代码 return source } module.exports = loader webpack.config.js let path = require('path') module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'build.js', path: path.resolve(__dirname, 'dist') }, resolveLoader: { // 别名 // alias: { // loader1: path.resolve(__dirname, 'loader', 'loader1') // } modules: ['node_modules', path.resolve(__dirname, 'loader')] // 先找node_modules, 再去loader中去找 }, module: { rules: [ { test: /\\.js$/, // use: [path.resolve(__dirname, 'loader', 'loader1')] use: 'loader1' // 如何找到这个loader1 }, // { // test: /\\.less$/, // use: [ // path.resolve(__dirname, 'loader', 'style-loader'), // path.resolve(__dirname, 'loader', 'less-loader') // ] // } ] }, } 如何找到这个loader1 通过配别名alias 通过modules npx webpack 配置多个loader 数组方式 先分别在loader文件下创建，loader2.js和loader3.js function loader(source) { // loader的参数就是源代码 console.log('loader2'); // loader3.js 类似 return source } module.exports = loader webpack.config.js rules: [ { test: /\\.js$/, use: ['loader3', 'loader2', 'loader1'] }, ] 运行npx webpack,分别打出 loader1 loader2 loader3 对象方式 rules: [ { test: /\\.js$/, use: ['loader3'] }, { test: /\\.js$/, use: ['loader2'] }, { test: /\\.js$/, use: ['loader1'] } ] 运行npx webpack,分别打出 loader1 loader2 loader3 loader的顺序: 从右到左, 从下到上 也可以通过配置不同的参数改变loader的执行顺序，pre 前面的， post在后面的， normal正常 { test: /\\.js$/, use: ['loader1'], enforce: \"pre\" }, { test: /\\.js$/, use: ['loader2'] }, { test: /\\.js$/, use: ['loader3'], enforce: \"post\" }, loader 带参数执行的顺序: pre -> normal -> inline -> post inline为行内loader 在loader文件中新建inlin-loader function loader(source) { // loader的参数就是源代码 console.log('inline'); return source } module.exports = loader src/a.js module.exports = 'may' src/index console.log('hello') let srt = require('-!inline-loader!./a') -!禁用pre-loader和 normal-loader来处理了 loader1 loader2 loader3 inline loader3 !禁用normal-loader loader1 loader2 loader3 loader1 inline loader3 !! 禁用pre-loader、normal-loader、post-loader,只能行内处理 loader1 loader2 loader3 inline loader 默认由两部分组成pitch和normal user: [loader3, loader2, loader1] 无返回值: 先执行pitch方法,从左到右，再获取资源 pitch loader - 无返回值 pitch loader3 → loader2 → loader1 ↘ 资源 ↙ normal loader3 ← loader2 ← loader1 有返回值: 直接跳过后续所有的loader包括自己的,跳到之前的loader, 可用于阻断 loader user: [loader3, loader2, loader1] pitch loader - 有返回值 pitch loader3 → loader2 loader1 ↙ 有返回值 资源 ↙ normal loader3 loader2 loader1 loadeer2.js function loader(source) { // loader的参数就是源代码 console.log('loader2'); return source } loader.pitch = function () { return '111' } module.exports = loader 结果 loader3 babel-loader实现 yarn add @babel/core @babel/preset-env webpack.config.js { test: '\\.js$/', use: { loader: 'babel-loader2', options: { presets: [ '@babel/preset-env' ] } } } 在loader文件创建babel-loader2.js(如果你已经装过babel-loader) 拿到babel的参数 yarn add loader-utils // 需要在webpack.config.js拿到babel的预设, 通过预设转换模块, 先引入babel let babel = require('@babel/core') // 拿到babel的参数 需要工具 loaderUtils let loaderUtils =require('loader-utils') function loader(source) { // loader的参数就是源代码 这里的this就是loader的上下文 let options = loaderUtils.getOptions(this) console.log(this.resourcePath, 444); // [./src/index.js] let callback = this.async(); // babel的转换是异步的,同步的返回是不行的， 不能用return 同步就是直接掉用 异步会在async中 babel.transform(source, { ...options, sourceMap: true, // 是否设置sourceMap 还需要再webpack.config.js 中配置 devtool: 'source-map' filename: this.resourcePath.split('/').pop() // 给生成的`source-map`指定名字 }, function (err, result) { callback(err, result.code, result.map) // 异步 参数分别是「错误 转化后的代码 和 sourceMap」 }) console.log(options); // return source 失效 } module.exports = loader index.js class May { constructor () { this.name = 'may' } getName () { return this.name } } let may = new May() console.log(may.getName()); npx webpack banner-loader实现(自创) 给所有匹配的js加一个注释 webpack.config.js { // 给所有匹配的`js`加一个注释 test: /\\.js$/, use: { loader: 'banner-loader', options: { text: 'may', filename: path.resolve(__dirname, 'banner.js') } } } banner.js 二次星球中毒 在loader文件创建banner-loader.js yarn add schema-utils 校验自己写的loader格式是否正确 schema-utils banner-loader.js // 拿到loader的配置 let loaderUtils = require('loader-utils') // 校验loader let validateOptions = require('schema-utils') // 读取文件 let fs = require('fs') // 异步 function loader(source) { // loader的参数就是源代码 let options = loaderUtils.getOptions(this) let callback = this.async() // 读取文件是异步 let schema = { type: 'object', properties: { text: { type: 'string' }, filename: { type: 'string' } } } validateOptions(schema, options, 'banner-loader') // 自己的校验格式， 自己的写的配置， 对应的loader名字 if (options.filename) { this.cacheable(false) // 不要缓存 如果有大量计算 推荐缓存 // this.cacheable && this.cacheable() this.addDependency(options.filename) // 自动增加依赖 fs.readFile(options.filename, 'utf8', function (err, data) { callback(err, `/**${data}**/${source}`) }) } else { callback(null, `/**${options.text}**/${source}`) } return source } module.exports = loader 优化: 修改banner.js的内容后, webpack进行监控，打包webapck.config.js配置watch: true loader缓存 实现file-loader和url-loader yarn add mime 其主要用途是设置某种扩展名的文件的响应程序类型 mime 创建file-loader.js1 // 拿到babel的参数 需要工具 loaderUtils let loaderUtils = require('loader-utils') function loader(source) { // loader的参数就是源代码 // file-loader需要返回路径 let filename = loaderUtils.interpolateName(this, '[hash].[ext]', {content: source }) this.emitFile(filename, source) // 发射文件 console.log('loader1'); return `module.exports=\"${filename}\"` } loader.raw = true // 二进制 module.exports = loader 创建url-loader1.js // 拿到babel的参数 需要工具 loaderUtils let loaderUtils = require('loader-utils') let mime = require('mime') // 途是设置某种扩展名的文件的响应程序类型 function loader(source) { // loader的参数就是源代码 let {limit} = loaderUtils.getOptions(this) console.log(this.resourcePath); if (limit && limit > source.length) { return `module.exports=\"data:${mime.getType(this.resourcePath)};base64,${source.toString('base64')}\"` } else { return require('./file-loader1').call(this, source) } } loader.raw = true // 二进制 module.exports = loader webpack.config.js { test: /\\.png$/, // 目的是根据图片生成md5 发射到dist目录下，file-loader 返回当前图片路径 // use: 'file-loader' // 处理路径 use: { loader: 'url-loader1', options: { limit: 200 * 1024 } } } index.js引入图片 import p from './photo.png' let img = document.createElement('img') img.src = p document.body.appendChild(img); less-loader和css-loader 先安装less 分别创建style-loader2 css-loader2 less-loader2 style-loader1 与 less-loader1 同之前的 css-loader 主要用来处理css中的图片链接，需要把url转换成require webpack.config.js { test: /\\.png$/, // 目的是根据图片生成md5 发射到dist目录下，file-loader 返回当前图片路径 // use: 'file-loader' // 处理路径 use: { loader: 'url-loader1', options: { limit: 200 * 1024 } } }, { test: /\\.less$/, use: ['style-loader2', 'css-loader2', 'less-loader2'] } 创建index.less @base: #f938ab; body { background: @base; background: url(\"./photo.png\"); } less-loader2.js // 将less转为css let less = require('less') function loader(source) { let css = '' // console.log(source, 2222); less.render(source, function (err, output) { // console.log(output); css = output.css }) // css = css.replace(/\\n/g, '\\\\n'); return css } module.exports = loader css-loader2.js // css-loader 用来解析@import这种语法,包括css中引入的图片 function loader(source) { let reg = /url\\((.+?)\\)/g // 匹配括号 let pos = 0; let current; let arr = ['let list = []'] while (current = reg.exec(source)) { let [matchUrl, g] = current // matchUrl -> 'url(\"./photo.png\")', g -> '\"./photo.png\"' // console.log(matchUrl, g, 88); let lastIndex = reg.lastIndex - matchUrl.length // 拿到css从开通到地址链接之前的index arr.push(`list.push(${JSON.stringify(source.slice(pos, lastIndex))})`) // 拼入开始和地址之前的代码 pos = reg.lastIndex arr.push(`list.push('url('+ require(${g}) +')')`) // 拼入图片地址 } arr.push(`list.push(${JSON.stringify(source.slice(pos))})`) // 拼入地址到结尾的代码 arr.push(`module.exports = list.join('')`) console.log(arr.join('\\r\\n')); // let list = [] // list.push(\"body {\\\\n background: #f938ab;\\\\n background: \") // list.push('url('+ require(\"./photo.png\") +')') // list.push(\";\\\\n}\\\\n\") // module.exports = list.join('') return arr.join('\\r\\n') } module.exports = loader style-loader2.js let loaderUtils = require('loader-utils') // 将css插入到html头部 function loader(source) { let str = ` let style = document.createElement('style') style.innerHTML = ${JSON.stringify(source)} document.head.appendChild(style) ` return str } // style-loader写了pitch,有返回后面的跳过，自己的写不会走 loader.pitch = function (remainingRequest) { // 剩余的请求 console.log(loaderUtils.stringifyRequest(this, '!!' + remainingRequest, 99999999)) // 让style-loader 处理 less-loader 和css-loader拼接的结果 // 得到 /Users/liuhuimin/work/webpack/loader/css-loader2.js!/Users/liuhuimin/work/webpack/loader/less-loader2.js!/Users/liuhuimin/work/webpack/src/index.less // 剩余的请求 less-loader!css-loader!./index.less // console.log(remainingRequest, 1223); // require返回的就是css-loader处理好的结果require('!!css-loader!less-loader!./index.less') let str = ` let style = document.createElement('style') style.innerHTML = require(${loaderUtils.stringifyRequest(this, '!!' + remainingRequest)}) document.head.appendChild(style) ` // stringifyRequest 绝对路径转相对路径 return str } module.exports = loader user: ['style-loader2', 'css-loader2', 'less-loader2'] pitch loader - 有返回值 pitch style-loader2 → css-loader2 less-loader2 ↙ 有返回值 资源 ↙ normal style-loader2 css-loader2 less-loader2 在style-loader2中 引用了less-loader css-loader 和less文件 webpack 中的插件 yarn add webpack webpack-cil -D webpack.config.js let path = require('path') let DonePlugin = require('./plugins/DonePlugins') let AsyncPlugins = require('./plugins/AsyncPlugins') module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'build.js', path: path.resolve(__dirname, 'dist') }, plugins: [ new DonePlugin(), // 同步 new AsyncPlugins() // 异步 ] } node_modules/webpack/lib中查看Compiler.js 同步plugins/DonePlugins 打包完成 class DonePlugins { apply (compiler) { console.log(1); compiler.hooks.done.tap('DonePlugin', (stats) => { console.log('编译完成'); }) } } module.exports = DonePlugins 异步plugins/AsyncPlugins class AsyncPlugins { apply (compiler) { console.log(2); compiler.hooks.emit.tapAsync('AsyncPlugin', (complete, callback) => { setTimeout(() => { console.log('文件发射出来'); callback() }, 1000) }) compiler.hooks.emit.tapPromise('AsyncPlugin', (complete, callback) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log('文件发射出来 222'); resolve() }, 1000) }) }) } } module.exports = AsyncPlugins 文件列表插件 希望生成一个文件描述打包出来的文件 在plugins中新建FileListPlugin class FileListPlugin { constructor ({filename}) { this.filename = filename } apply (compiler) { // 文件已经准备好了 要进行发射 // emit compiler.hooks.emit.tap('FileListPlugin', (compilation) => { let assets = compilation.assets; console.log(assets, 55); let content = `## 文件名 资源大小\\r\\n` // [ [bundls.js, {}], [index.html, {}]] Object.entries(assets).forEach(([filename, stateObj]) => { content += `- ${filename} ${stateObj.size()}\\r\\n` }) // 资源对象 assets[this.filename] = { source () { return content; }, size () { return content.length } } }) } } module.exports = FileListPlugin let path = require('path') let DonePlugin = require('./plugins/DonePlugins') let AsyncPlugins = require('./plugins/AsyncPlugins') let HtmlWebpackPlugin = require('html-webpack-plugin') let FileListPlugin = require('./plugins/FileListPlugin') module.exports = { mode: 'development', entry: './src/index.js', output: { filename: 'build.js', path: path.resolve(__dirname, 'dist') }, plugins: [ new DonePlugin(), new AsyncPlugins(), new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html' }), new FileListPlugin({ filename: 'list.md' }) ] } 生成list.md 内联的webpack插件 新建index.css引入index.js yarn add css-loader mini-css-extract-plugin -D 希望打包后css、js内联在index.html文件中 创建plugins中InlineSourcePlugins.js yarn add --dev html-webpack-plugin@next HTML Webpack Plugin webpack.config.js let path = require('path') let DonePlugin = require('./plugins/DonePlugins') let AsyncPlugins = require('./plugins/AsyncPlugins') let HtmlWebpackPlugin = require('html-webpack-plugin') let FileListPlugin = require('./plugins/FileListPlugin') let InlineSourcePlugins = require('./plugins/InlineSourcePlugins') let MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { mode: 'production', entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] } ] }, plugins: [ // new DonePlugin(), // new AsyncPlugins(), new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html' }), new MiniCssExtractPlugin({ filename: 'index.css' }), new InlineSourcePlugins({ match: /\\.(js|css)/ }), // new FileListPlugin({ // filename: 'list.md' // }) ] } InlineSourcePlugins.js const HtmlWebpackPlugin = require('html-webpack-plugin') // 把外链的标签编程内联的标签 class InlineSourcePlugins { constructor({match}) { this.reg = match // 正则 } // 处理某一个标签 processTag(tag, compilation) { let newTag = {} let url = '' if (tag.tagName === 'link' && this.reg.test(tag.attributes.href)) { newTag = { tagName: 'style', attributes: {type: 'text/css'} } url = tag.attributes.href } else if (tag.tagName === 'script' && this.reg.test(tag.attributes.src)) { newTag = { tagName: 'script', attributes: {type: 'application/javascript'} } url = tag.attributes.src } if (url) { newTag.innerHTML = compilation.assets[url].source(); // 文件内容放到innerHTML属性中 delete compilation.assets[url] // 删除原有的资源 return newTag // console.log(compilation.assets[url].source()); } return tag } // 处理引入标签的数据 processTags(data, compilation) { let headTags = [] let bodyTags = [] data.headTags.forEach(headTag => { headTags.push(this.processTag(headTag, compilation)) }) data.bodyTags.forEach(bodyTag => { bodyTags.push(this.processTag(bodyTag, compilation)) }) console.log({...data, headTags, bodyTags}) return {...data, headTags, bodyTags} } apply(compiler) { // 通过webpackPlugin来实现 npm搜索 html-webpack-plugin compiler.hooks.compilation.tap('InlineSourcePlugins', (compilation) => { HtmlWebpackPlugin.getHooks(compilation).alterAssetTagGroups.tapAsync( 'alertPlugin', (data, callback) => { // console.log('======'); // console.log(data) // 插入html标签的数据 // console.log('======'); data = this.processTags(data, compilation) // compilation.assets 资源的链接 callback(null, data) }) }) } } module.exports = InlineSourcePlugins 打包后自动发布 打包好的文件自动上传致七牛 需要这几个参数 bucket: '' // 七牛的存储空间 domain: '', accessKey: '', // 七牛云的两对密匙 secretKey: '' // 七牛云的两对密匙 注册七牛，并在对象存储里面,新建存储空间列表test,bucket: 'test' 内容管理外链接默认域名 domain: 'xxxxxxxx' 右上角个人面板里面个人中心,密钥管理分别对应accessKey和secretKey 进入开发者中心 -> SDK&工具 -> 官方SDK -> Node服务端文档 —> 文件上传 node文件上传 npm install qiniu compiler-hooks webpack.config.js plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html' }), new MiniCssExtractPlugin({ filename: 'index.css' }), new UploadPlugin({ bucket: 'test', // 七牛的存储空间 domain: 'poyrjyh1b.bkt.clouddn.com', accessKey: 'xxxxxx', // 七牛云的两对密匙 secretKey: 'yyyyyy' // 七牛云的两对密匙 }) ] UploadPlugin.js let qiniu = require('qiniu') let path = require('path') class UploadPlugin { constructor (options = {}) { // 参考 https://developer.qiniu.com/kodo/sdk/1289/nodejs let { bucket = '', domain = '', accessKey = '', secretKey = ''} = options let mac = new qiniu.auth.digest.Mac(accessKey, secretKey) let putPolicy = new qiniu.rs.PutPolicy({ scope: bucket }); this.uploadToken = putPolicy.uploadToken(mac) let config = new qiniu.conf.Config(); this.formUploader = new qiniu.form_up.FormUploader(config) this.putExtra = new qiniu.form_up.PutExtra() } apply (compiler) { compiler.hooks.afterEmit.tapPromise('UploadPlugin', (complication) => { let assets = complication.assets let promise = [] Object.keys(assets).forEach(filename => { promise.push(this.upload(filename)) }) return Promise.all(promise) }) } upload (filename) { return new Promise((resolve, reject) => { let localFile = path.resolve(__dirname, '../dist', filename) this.formUploader.putFile(this.uploadToken, filename, localFile, this.putExtra, function(respErr, respBody, respInfo) { if (respErr) { reject(respErr) } if (respInfo.statusCode == 200) { resolve(respBody) } else { console.log(respInfo.statusCode) console.log(respBody) } }); }) } } module.exports = UploadPlugin Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-14 21:03:37 "},"webpack/webpack4AndReact脚手架.html":{"url":"webpack/webpack4AndReact脚手架.html","title":"webpack4AndReact脚手架","keywords":"","body":"webpack4AndReact 基本概念 plugin、loader: plugin: 扩张webpack功能的 loader: 转换文件（js, css, 图片） npm install XX --save-dev 是你开发时候依赖的东西，--save 是你发布之后还依赖的东西。 yarn add XX yarn add [package]@[version] 这将安装您的dependencies中的一个或多个包。 用 --dev 或 -D 会在 devDependencies 里安装一个或多个包。 yarn global add 全局安装依赖。 model: 模式配置 可设置的值为mode：none，development或production（默认值） 只需mode在配置中提供选项： module.exports = { mode: 'production' }; 或者将其作为CLI参数传递： webpack --mode=production init项目 创建文件夹并进入 mkdir webpack4+react && cd webpack4+react mkdir src && touch ./src/index.js src/index.js 添加内容 /*使用es6的箭头函数*/ var func = str => { document.getElementById('app').innerHTML = str; }; func('使用Babel!'); dist文件夹下面新建一个index.html touch ./dist/index.html dist/index.html填写内容 Document Getting Start 现在项目中装两个插件 npm install webpack webpack-cli --save-dev 全局安装webapck的问题 The following NPM installation will make webpack available globally: npm install --global webpack Note that this is not a recommended practice. Installing globally locks you down to a specific version of webpack and could fail in projects that use a different version. 命令来指定打包文件到指定文件夹 加--config 可以查看详细的报错信息，便于排查错误 webpack --mode=development ./src/hello.js --output ./build/main.js 命令很麻烦，所以需要配置文件package.json npm init -y(-y的意思是不需要回车) 全局安装webpack会锁定webpack版本，当我们运行不同版本的webpack项目时会有问题 两种方法 自定义命令 devnow**\"scripts\": { \"devnow\": \"./node_modules/webpack/bin/webpack.js --mode=development\", } 安装npx解决这个问题 ** 只要是可执行文件前面都可以加npx,他首先会在当前项目里找不到就去全局找 npm install -g npx \"scripts\": { \"devnpx\": \"npx webpack --mode=development\" }, webpack默认的配制文件（webpack.config.js）（全部自定义命令配置的话很长，不好看）， 直接建个 webpack.config.js,因为webpack会默认去找这个文件。moduls.exports = { mode: \"development\", entry: \"./src/index.js\", output: { path: path.resolve(__dirname, 'dist'), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 filename: \"app.bundle.js\" } } 然后自定义的命令就可以删了（删了devnpx命令里的--mode=development）\"scripts\": { \"devnpx\": \"npx webpack\", \"dev\": \"webpack --mode=development\", \"build\": \"webpack --mode=production\" }, 配置多入口文件 编译多个js文件 const path = require('path') module.exports = { mode: \"development\", entry:{ app: \"./src/index.js\", hello: './src/hello.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: \"[name].bundle.js\" // name是入口文件的名字作为key } } 基础的babel相关 安装babel(js转换插件为了解决低版本的浏览器不支持新的js语法) @babel/core babel核心插件调用Babel的API进行转码 babel-loader webpack和babel结合插件 @babel/preset-react 用于解析 JSX @babel/preset-env 用于解析 JSX 根据配置的目标浏览器或者运行环境来自动将ES2015+的代码转换为es5。 @babel/polifill bable能转换一些语法，但是一些新的api不能处理（Promise，，，） 原理： 往windows全局对象导入一些内容 @babel/runtime 解决polifill全局污染的问题 @babel/plugin-transform-runtime 作用是避免重复的问题 @babel/runtime-corejs2 依赖corejs需在babel里指定版本 npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-react @babel/polifil @babel/runtime @babel/plugin-transform-runtime @babel/runtime-corejs2 babel的插件介绍（plugin） arrow-functions block-scoped-functions block-scoping classes computed-properties destructuring duplicate-keys for-of function-name instanceof babel插件两种使用方法举例说明 .babelrc（项目根目录新建此文件，然后复制进去） Without options: { \"plugins\": [\"@babel/plugin-transform-arrow-functions\"] } With options: （在webpack配置文件里加） module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { plugins: ['@babel/plugin-proposal-object-rest-spread'] } } } ] } @babel/preset-env babel (preset)预设 作用： 解决每写一个js新语法都装一个插件比如箭头函数，class, bable-env// 不包含装饰器插件，所以es6装饰器可能要加装 module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env',{debug: true}], //预设,包含某些es6常用插件,debug可以看到预设了那些插件 } } } ] } @babel/polifill bable能转换一些语法，但是一些新的api不能处理（Promise，，，） 原理： 往windows全局对象导入一些内容 // 安装略 { \"presets\": [[\"@babel/preset-env\",{\"debug\": true, \"useBuiltIns\": \"usage\",\"corejs\": \"3.0.0\"}]], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], ] } 注意 1.\"useBuiltIns\": \"usage\" //按需编译 [/Users/qinlin/Desktop/webpack/hello-webpack-4/src/index.js] Added following core-js polyfills: es.array.from {} es.object.assign {} es.object.to-string {} es.promise {} es.string.iterator {} \"corejs\": \"3.0.0\"它依赖corejs需指定版本不然会报错 @babel/runtime 解决polifill全局污染的问题 polifill: ar process = global.process; var Promise = global.Promise; 所以不太好 用法： npm install --save @babel/runtime npm install --save-dev @babel/plugin-transform-runtime npm install --save @babel/runtime-corejs2 @babel/plugin-transform-runtime的作用是避免重复的问题 比如： function _classCallCheck(instance, Constructor) { //... } var Circle = function Circle() { _classCallCheck(this, Circle); }; 变为 var _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\"); var Circle = function Circle() { _classCallCheck(this, Circle); }; 配置一下.babelrc { \"presets\": [ [ \"@babel/preset-env\",{\"debug\": true} ], [ \"@babel/preset-react\" ] ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ], [ \"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false } ] ] } plugin(插件作用扩展webpack功能) html-webpack-plugin 可以自动生成html,可以解决浏览器缓存问题，因为每次文件名都会更新，自动把js插入到你的模板html里面去 npm i --save-dev html-webpack-plugin 新建模板index.html cd src touch index.html src/index.html Document webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { .... plugins: [ new HtmlWebpackPlugin() ] } 可以加参数 new HtmlWebpackPlugin({ title: 'app', filename: 'app/index.html', // 放在dist/app目录下 template: path.join(__dirname, 'src/index.html'), // 模板文件 }) 配资多个html webpack.config.js entry:{ app: \"./src/index.js\", more: \"./src/moreIndex.js\", }, output: { path: path.resolve(__dirname, 'dist'), filename: \"[name]/[name].bundle.js\" // name是入口文件的名字作为key,生成dist/name/nameXX.JS }, .... plugins: [ new HtmlWebpackPlugin({ title: 'app', filename: 'app/index.html', template: 'public/index.html', chunks: [\"app\",\"more\"] }), new HtmlWebpackPlugin({ title: 'index', filename: 'app/index.html', template: 'public/index.html', chunks: [\"more\"] }) ] 生成的app Document 删除注释 minify: { removeComments: true // 删除注释 } css相关处理 npm install css-loader sass-loader node-sass style-loader postcss-loader postcss-cssnext --save-dev less等略 PostCSS 他有很多很多的插件，比如： Autoprefixer这个插件,可以自动给css属性加浏览器前缀。 /*编译前*/ .container{ display: flex; } /*编译后*/ .container{ display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; } postcss-cssnext 允许你使用未来的 CSS 特性（包括 autoprefixer） 当然，它有很多很多的插件可以用，你可以去官网详细了解。我们今天只用postcss-cssnext。（它包含了autoprefixer） webapck.config.js const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { // mode: \"development\", entry:{ // app: [\"@babel/polyfill\",\"./src/index.js\"], app: \"./src/index.js\", app: './src/hello.js' }, devtool: false, output: { path: path.resolve(__dirname, 'dist'), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 filename: \"[name]/[hash].bundle.js\", // name是入口文件的名字作为key // chunkFilename: \"[name]-[hash].[id].bundle.js\", // name是入口文件的名字作为key }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', // options: { // presets: [['@babel/preset-env',{debug: true}]], //预设,包含某些es6常用插件,debug可以看到预设了那些插件 // } } }, { test: /\\.css$/, use: ['style-loader', 'css-loader'], // 右边到左边执行css => style }, { test: /\\.(scss|sass)$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: 'app', filename: 'app/index.html', template: 'public/index.html', chunks: [\"app\"] }), new HtmlWebpackPlugin({ title: 'index', filename: 'app/index.html', template: 'public/index.html', chunks: [\"app\"] }) ] } mini-css-extract-plugin把js释放css文件 npm install --save-dev mini-css-extract-plugin webpack.config.js const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const devMode = process.env.NODE_ENV !== 'production' module.exports = { plugins: [ new MiniCssExtractPlugin({ // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? '[name].css' : '[name].[hash].css', chunkFilename: devMode ? '[id].css' : '[id].[hash].css', }) ], module: { rules: [ { test: /\\.(sa|sc|c)ss$/, use: [ devMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader', ], } ] } } webpack-dev-server(开启一个本地服务器，热加载，自动打开浏览器) npm install webpack-dev-server --save-dev \"devnpx\": \"npx webpack-dev-server --open\", clean-webpack-plugin(清空之前生成的hash文件) npm install --save-dev clean-webpack-plugin npm install -g serve let pathToClean = ['dist'] .... new CleanWebpackPlugin({pathToClean:pathToClean}) 执行命令 serve -s dist 处理图片 npm install file-loader --save-dev 压缩图片 npm install image-webpack-loader --save-dev 查看文件体积命令 ls -lh src 最终webpack.config.js const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin') const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const devMode = process.env.NODE_ENV !== 'production' const CleanWebpackPlugin = require('clean-webpack-plugin'); let pathToClean = ['dist'] module.exports = { // mode: \"development\", entry:{ // app: [\"@babel/polyfill\",\"./src/index.js\"], app: \"./src/index.js\", app: './src/hello.js' }, devtool: false, output: { path: path.resolve(__dirname, 'dist'), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 // filename: \"[name]/[hash].bundle.js\", // name是入口文件的名字作为key filename: \"js/[name]-[hash].bundle.js\", // name是入口文件的名字作为key }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', // options: { // presets: [['@babel/preset-env',{debug: true}]], //预设,包含某些es6常用插件,debug可以看到预设了那些插件 // } } }, { test: /\\.css$/, use: [ devMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader' ], // 右边到左边执行css => style }, { test: /\\.(scss|sass)$/, use: [ devMode ? 'style-loader' : MiniCssExtractPlugin.loader, // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] }, { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: { name: '[name].[ext]', outputPath: 'images/', } }, { loader: 'image-webpack-loader', } ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: 'app', filename: 'app.html', template: 'public/index.html', chunks: [\"app\"] }), new HtmlWebpackPlugin({ title: 'index', filename: 'index.html', template: 'public/index.html', chunks: [\"app\"] }), new HtmlWebpackPlugin({ title: 'index', filename: 'index.html', template: 'public/index.html', chunks: [\"app\"] }), new MiniCssExtractPlugin({ // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? 'css/[name].css' : 'css/[name].[hash].css', chunkFilename: devMode ? 'css/[id].css' : 'css/[id].[hash].css', }), new CleanWebpackPlugin({pathToClean:pathToClean}) ] } .babelrc { \"presets\": [ [ \"@babel/preset-env\",{\"debug\": true} ], [ \"@babel/preset-react\" ] ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ], [ \"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false } ] ] } 搭建react环境 @babel/preset-react前面已经安装过了。.babelrc也配置过了 npm install react react-dom 修改 src/index.js使用react import React from 'react'; import ReactDom from 'react-dom'; ReactDom.render( Hello React!, document.getElementById('app')); 执行打包命令npm run build 打开index.html 看效果。 我们简单做下改进，把Hello React放到组件里面。体现组件化~ cd src mkdir component cd component mkdir Hello cd Hello touch Hello.js 按照React语法，写一个Hello组件 import React, {Component} from 'react'; export default class Hello extends Component { render() { return ( Hello,React! ) } } 然后让我们修改src/index.js，引用Hello组件！ src/index.js import React from 'react'; import ReactDom from 'react-dom'; import Hello from './component/Hello/Hello'; ReactDom.render( , document.getElementById('app')); 在根目录执行打包命令 yarn build 打开index.html看效果 react-router react-router-dom中package.json依赖: \"dependencies\": { \"history\": \"^4.7.2\", \"invariant\": \"^2.2.2\", \"loose-envify\": \"^1.3.1\", \"prop-types\": \"^15.5.4\", \"react-router\": \"^4.2.0\", \"warning\": \"^3.0.0\" } 安装了react-router-dom，npm会解析并安装上述依赖包。可以看到，其中包括react-router。 npm install --save react-router-dom cd src mkdir router && touch router/router.js 按照react-router文档编辑一个最基本的router.js。包含两个页面home和page1。 src/router/router.js import React from 'react'; import {BrowserRouter as Router, Route, Switch, Link} from 'react-router-dom'; import Home from '../pages/Home/Home'; import Page1 from '../pages/Page1/Page1'; const getRouter = () => ( 首页 Page1 ); export default getRouter; 新建页面文件夹 cd src mkdir pages 新建两个页面 Home,Page1 cd src/pages mkdir Home && touch Home/Home.js mkdir Page1 && touch Page1/Page1.js 填充内容： src/pages/Home/Home.js import React, {Component} from 'react'; export default class Home extends Component { render() { return ( this is home~ ) } } Page1.js import React, {Component} from 'react'; export default class Page1 extends Component { render() { return ( this is Page1~ ) } } 现在路由和页面建好了，我们在入口文件src/index.js引用Router。 修改src/index.js import React from 'react'; import ReactDom from 'react-dom'; import getRouter from './router/router'; ReactDom.render( getRouter(), document.getElementById('app')); 现在执行打包命令npm run dev-build。打开index.html查看效果啦！ 那么问题来了~我们发现点击‘首页’和‘Page1’没有反应。不要惊慌，这是正常的。 我们之前一直用这个路径访问index.html，类似这样：file:///F:/react/react-family/dist/index.html。 这种路径了，不是我们想象中的路由那样的路径http://localhost:3000~我们需要配置一个简单的WEB服务器，指向 index.html~有下面两种方法来实现 Nginx, Apache, IIS等配置启动一个简单的的WEB服务器。 使用webpack-dev-server来配置启动WEB服务器。webpack-dev-server 简单来说，webpack-dev-server就是一个小型的静态文件服务器。使用它，可以为webpack打包生成的资源文件提供Web服务。 npm install webpack-dev-server -g 修改webpack.config.js,增加webpack-dev-server的配置。 webpack.config.js devServer: { contentBase: path.join(__dirname, './dist/app') } 现在执行 webpack-dev-server --config webpack.config.js 浏览器打开http://localhost:8080，OK,现在我们可以点击首页,Page1了， 看URL地址变化啦！我们看到react-router已经成功了哦。 Q: --content-base是什么？ A：URL的根目录。如果不设定的话，默认指向项目根目录。 重要提示：webpack-dev-server编译后的文件，都存储在内存中，我们并不能看见的。你可以删除之前遗留的文件dist/bundle.js， 仍然能正常打开网站！ 每次执行webpack-dev-server webpack.config.js,要打很长的命令，我们修改package.json，增加script->start: \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack\", \"start\": \"webpack-dev-server\" } 下次执行npm start就可以了。 既然用到了webpack-dev-server，我们就看看它的其他的配置项。 看了之后，发现有几个我们可以用的。 color（CLI only） console中打印彩色日志 historyApiFallback 任意的404响应都被替代为index.html。有什么用呢？你现在运行 npm start，然后打开浏览器，访问http://localhost:8080,然后点击Page1到链接http://localhost:8080/page1， 然后刷新页面试试。是不是发现刷新后404了。为什么？dist文件夹里面并没有page1.html,当然会404了，所以我们需要配置 historyApiFallback，让所有的404定位到index.html。 host 指定一个host,默认是localhost。如果你希望服务器外部可以访问，指定如下：host: \"0.0.0.0\"。比如你用手机通过IP访问。 hot 启用Webpack的模块热替换特性。关于热模块替换，我下一小节专门讲解一下。 port 配置要监听的端口。默认就是我们现在使用的8080端口。 proxy 代理。比如在 localhost:3000 上有后端服务的话，你可以这样启用代理： proxy: { \"/api\": \"http://localhost:3000\" } progress（CLI only） 将编译进度输出到控制台。 根据这几个配置，修改下我们的webpack-dev-server的配置~ webpack.config.js devServer: { port: 8080, contentBase: path.join(__dirname, './dist'), historyApiFallback: true, host: '0.0.0.0' } CLI ONLY的需要在命令行中配置 package.json \"start\": \"webpack-dev-server --color --progress\" 现在我们执行npm start 看看效果。是不是看到打包的时候有百分比进度？在http://localhost:8080/page1页面刷新是不是没问题了？ 用手机通过局域网IP是否可以访问到网站？ Entrypoint undefined = app/index.html 在module.exports加 stats: { children: false }, 参考地址： https://segmentfault.com/a/1190000006670084 https://webpack.js.org/guides/development/#using-webpack-dev-server 全局变量.env https://blog.csdn.net/weixin_43206949/article/details/99460759 模块热替换（Hot Module Replacement） 模块热替换（Hot Module Replacement） 到目前，当我们修改代码的时候，浏览器会自动刷新，不信你可以去试试。（如果你的不会刷新，看看这个调整文本编辑器） 我相信看这个教程的人，应该用过别人的框架。我们在修改代码的时候，浏览器不会刷新，只会更新自己修改的那一块。我们也要实现这个效果。 我们看下webpack模块热替换教程。 我们接下来要这么修改 package.json 增加 --hot \"start\": \"webpack-dev-server --config webpack.dev.config.js --color --progress --hot\" src/index.js 增加module.hot.accept(),如下。当模块更新的时候，通知index.js。 src/index.js import React from 'react'; import ReactDom from 'react-dom'; import getRouter from './router/router'; if (module.hot) { module.hot.accept(); } ReactDom.render( getRouter(), document.getElementById('app')); 现在我们执行npm start，打开浏览器，修改Home.js,看是不是不刷新页面的情况下，内容更新了？惊不惊喜？意不意外？ 做模块热替换，我们只改了几行代码，非常简单的。纸老虎一个~ 现在我需要说明下我们命令行使用的--hot，可以通过配置webpack.dev.config.js来替换， 向文档上那样,修改下面三处。但我们还是用--hot吧。下面的方式我们知道一下就行，我们不用。同样的效果。 const webpack = require('webpack'); devServer: { hot: true } plugins:[ new webpack.HotModuleReplacementPlugin() ] HRM配置其实有两种方式，一种CLI方式，一种Node.js API方式。我们用到的就是CLI方式，比较简单。 Node.js API方式，就是建一个server.js等等，网上大部分教程都是这种方式，这里不做讲解了。 你以为模块热替换到这里就结束了？nonono~ 上面的配置对react模块的支持不是很好哦。 例如下面的demo，当模块热替换的时候，state会重置，这不是我们想要的。 修改Home.js,增加计数state src/pages/Home/Home.js import React, {Component} from 'react'; export default class Home extends Component { constructor(props) { super(props); this.state = { count: 0 } } _handleClick() { this.setState({ count: ++this.state.count }); } render() { return ( this is home~ 当前计数：{this.state.count} this._handleClick()}>自增 ) } } 你可以测试一下，当我们修改代码的时候，webpack在更新页面的时候，也把count初始为0了。 为了在react模块更新的同时，能保留state等页面中其他状态，我们需要引入react-hot-loader~ Q:　请问webpack-dev-server与react-hot-loader两者的热替换有什么区别？ A: 区别在于webpack-dev-server自己的--hot模式只能即时刷新页面，但状态保存不住。因为React有一些自己语法(JSX)是HotModuleReplacementPlugin搞不定的。 而react-hot-loader在--hot基础上做了额外的处理，来保证状态可以存下来。（来自segmentfault） 下面我们来加入react-hot-loader v3, 安装依赖 npm install react-hot-loader@next --save-dev 根据文档， 我们要做如下几个修改~ .babelrc 增加 react-hot-loader/babel .babelrc { \"presets\": [ \"es2015\", \"react\", \"stage-0\" ], \"plugins\": [ \"react-hot-loader/babel\" ] } webpack.dev.config.js入口增加react-hot-loader/patch webpack.dev.config.js entry: [ 'react-hot-loader/patch', path.join(__dirname, 'src/index.js') ] src/index.js修改如下 src/index.js import React from 'react'; import ReactDom from 'react-dom'; import {AppContainer} from 'react-hot-loader'; import getRouter from './router/router'; /*初始化*/ renderWithHotReload(getRouter()); /*热更新*/ if (module.hot) { module.hot.accept('./router/router', () => { const getRouter = require('./router/router').default; renderWithHotReload(getRouter()); }); } function renderWithHotReload(RootElement) { ReactDom.render( {RootElement} , document.getElementById('app') ) } 现在，执行npm start，试试。是不是修改页面的时候，state不更新了？ 参考文章： gaearon/react-hot-loader#243 redux 接下来，我们就要就要就要集成redux了。 要对redux有一个大概的认识，可以阅读阮一峰前辈的Redux 入门教程（一）：基本用法 如果要对redux有一个非常详细的认识，我推荐阅读中文文档，写的非常好。读了这个教程，有一个非常深刻的感觉，redux并没有任何魔法。 不要被各种关于 reducers, middleware, store 的演讲所蒙蔽 ---- Redux 实际是非常简单的。 当然，我这篇文章是写给新手的，如果看不懂上面的文章，或者不想看，没关系。先会用，多用用就知道原理了。 开始整代码！我们就做一个最简单的计数器。自增，自减，重置。 先安装 redux npm install --save redux 初始化目录结构 cd src mkdir redux cd redux mkdir actions mkdir reducers touch reducers.js touch store.js touch actions/counter.js touch reducers/counter.js 先来写action创建函数。通过action创建函数，可以创建action~ src/redux/actions/counter.js /*action*/ export const INCREMENT = \"counter/INCREMENT\"; export const DECREMENT = \"counter/DECREMENT\"; export const RESET = \"counter/RESET\"; export function increment() { return {type: INCREMENT} } export function decrement() { return {type: DECREMENT} } export function reset() { return {type: RESET} } 再来写reducer,reducer是一个纯函数，接收action和旧的state,生成新的state. src/redux/reducers/counter.js import {INCREMENT, DECREMENT, RESET} from '../actions/counter'; /* * 初始化state */ const initState = { count: 0 }; /* * reducer */ export default function reducer(state = initState, action) { switch (action.type) { case INCREMENT: return { count: state.count + 1 }; case DECREMENT: return { count: state.count - 1 }; case RESET: return {count: 0}; default: return state } } 一个项目有很多的reducers,我们要把他们整合到一起 src/redux/reducers.js import counter from './reducers/counter'; export default function combineReducers(state = {}, action) { return { counter: counter(state.counter, action) } } 到这里，我们必须再理解下一句话。 reducer就是纯函数，接收state 和 action，然后返回一个新的 state。 看看上面的代码，无论是combineReducers函数也好，还是reducer函数也好，都是接收state和action， 返回更新后的state。区别就是combineReducers函数是处理整棵树，reducer函数是处理树的某一点。 接下来，我们要创建一个store。 前面我们可以使用 action 来描述“发生了什么”，使用action创建函数来返回action。 还可以使用 reducers 来根据 action 更新 state 。 那我们如何提交action？提交的时候，怎么才能触发reducers呢？ store 就是把它们联系到一起的对象。store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 触发reducers方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 src/redux/store.js import {createStore} from 'redux'; import combineReducers from './reducers.js'; let store = createStore(combineReducers); export default store; 到现在为止，我们已经可以使用redux了~ 下面我们就简单的测试下 cd src cd redux touch testRedux.js src/redux/testRedux.js import {increment, decrement, reset} from './actions/counter'; import store from './store'; // 打印初始状态 console.log(store.getState()); // 每次 state 更新时，打印日志 // 注意 subscribe() 返回一个函数用来注销监听器 let unsubscribe = store.subscribe(() => console.log(store.getState()) ); // 发起一系列 action store.dispatch(increment()); store.dispatch(decrement()); store.dispatch(reset()); // 停止监听 state 更新 unsubscribe(); 当前文件夹执行命令 webpack testRedux.js node XXX.js 是不是看到输出了state变化？ { counter: { count: 0 } } { counter: { count: 1 } } { counter: { count: 0 } } { counter: { count: 0 } } 做这个测试，就是为了告诉大家，redux和react没关系，虽说他俩能合作。 到这里，我建议你再理下redux的数据流，看看这里。 调用store.dispatch(action)提交action。 redux store调用传入的reducer函数。把当前的state和action传进去。 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。 Redux store 保存了根 reducer 返回的完整 state 树。 就是酱紫~~ 这会webpack.dev.config.js路径别名增加一下，后面好写了。 webpack.dev.config.js alias: { ... actions: path.join(__dirname, 'src/redux/actions'), reducers: path.join(__dirname, 'src/redux/reducers'), } 把前面的相对路径都改改。 下面我们开始搭配react使用。 写一个Counter页面 cd src/pages mkdir Counter touch Counter/Counter.js src/pages/Counter/Counter.js import React, {Component} from 'react'; export default class Counter extends Component { render() { return ( 当前计数为(显示redux计数) { console.log('调用自增函数'); }}>自增 { console.log('调用自减函数'); }}>自减 { console.log('调用重置函数'); }}>重置 ) } } 修改路由，增加Counter src/router/router.js import React from 'react'; import {BrowserRouter as Router, Route, Switch, Link} from 'react-router-dom'; import Home from 'pages/Home/Home'; import Page1 from 'pages/Page1/Page1'; import Counter from 'pages/Counter/Counter'; const getRouter = () => ( 首页 Page1 Counter ); export default getRouter; npm start看看效果。 下一步，我们让Counter组件和Redux联合起来。使Counter能获得到Redux的state，并且能发射action。 当然我们可以使用刚才测试testRedux的方法，手动监听~手动引入store~但是这肯定很麻烦哦。 react-redux提供了一个方法connect。 容器组件就是使用 store.subscribe() 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。你可以手工来开发容器组件，但建议使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。 connect接收两个参数，一个mapStateToProps,就是把redux的state，转为组件的Props，还有一个参数是mapDispatchToprops, 就是把发射actions的方法，转为Props属性函数。 先来安装react-redux npm install --save react-redux src/pages/Counter/Counter.js import React, {Component} from 'react'; import {increment, decrement, reset} from 'actions/counter'; import {connect} from 'react-redux'; class Counter extends Component { render() { return ( 当前计数为{this.props.counter.count} this.props.increment()}>自增 this.props.decrement()}>自减 this.props.reset()}>重置 ) } } const mapStateToProps = (state) => { return { counter: state.counter } }; const mapDispatchToProps = (dispatch) => { return { increment: () => { dispatch(increment()) }, decrement: () => { dispatch(decrement()) }, reset: () => { dispatch(reset()) } } }; export default connect(mapStateToProps, mapDispatchToProps)(Counter); 下面我们要传入store 所有容器组件都可以访问 Redux store，所以可以手动监听它。一种方式是把它以 props 的形式传入到所有容器组件中。但这太麻烦了，因为必须要用 store 把展示组件包裹一层，仅仅是因为恰好在组件树中渲染了一个容器组件。 建议的方式是使用指定的 React Redux 组件 来 魔法般的 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。 src/index.js import React from 'react'; import ReactDom from 'react-dom'; import {AppContainer} from 'react-hot-loader'; import {Provider} from 'react-redux'; import store from './redux/store'; import getRouter from 'router/router'; /*初始化*/ renderWithHotReload(getRouter()); /*热更新*/ if (module.hot) { module.hot.accept('./router/router', () => { const getRouter = require('router/router').default; renderWithHotReload(getRouter()); }); } function renderWithHotReload(RootElement) { ReactDom.render( {RootElement} , document.getElementById('app') ) } 到这里我们就可以执行npm start，打开localhost:8080/counter看效果了。 现在你可以npm start去看效果了。 这里我们再缕下（可以读React 实践心得：react-redux 之 connect 方法详解） Provider组件是让所有的组件可以访问到store。不用手动去传。也不用手动去监听。 connect函数作用是从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。也传递dispatch(action)函数到props。 异步 中间件的作用就是： 转换异步操作，生成原始的action，这样，reducer函数就能处理相应的action，从而改变state，更新UI。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-02 22:09:42 "},"CssAndHtml/Interview/Html.html":{"url":"CssAndHtml/Interview/Html.html","title":"Html ✘","keywords":"","body":"面试知识点 - HTML HTML 属于结构层，负责描绘出内容的结构。 CSS 属于表示层，负责如何显示有关内容。 JavaScript 属于行为层，负责内容应如何对事件做出反应。 HTML学习推荐 《前端工程师手册》 《HTML 教程- (HTML5 标准) - 菜鸟教程》  1. Doctype作用，HTML5 为什么只需要写  2. 行内元素有哪些，块级元素有哪些，空(void)元素有那些  3. 简述一下你对HTML语义化的理解  4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解  5. html5有哪些新特性  6. 描述一下 cookies，sessionStorage 和 localStorage 的区别  7. 如何实现浏览器内多个标签页之间的通信  8. HTML5的离线存储怎么使用，解释一下工作原理  9. src与href的区别  10. 表单提交中Get和Post方式的区别  11. cookies、session、sessionStorage、localStorage  12. 渐进增强和优雅降级？  13. img 的 alt 与 title 有何异同？ strong 与 em 的异同？  14.document load 和document ready 的区别  15.document.write(),outerHTML、outerText、innerHTML、innerText属性  16.click, touch执行顺序 1. Doctype作用，HTML5 为什么只需要写 doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的（document type definition）文档类型定义（DTD）来解析文档.声明必须是HTML文档的第一行，位于html标签之前 HTML 4.01 基于 SGML:标准通用标示语言（Standard Generalized Markup Language）是现时常用的超文本格式的最高层次标准。 HTML5不基于SGML，所以不需要引用DTD。在HTML5中只有一种 2. 行内元素有哪些，块级元素有哪些，空(void)元素有那些 行内元素：a span i img input select b 等 块级元素：div ul ol li h1~h6 p table 等 空元素：br hr link 等 3. 简述一下你对HTML语义化的理解 简单来说，就是合适的标签做合适的事情，这样具有以下好处： 有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取，利于SEO 有利于不同设备的解析 有利于构建清晰的机构，有利于团队的开发、维护 便于盲人浏览网页 简单来说，能用 、 等 div 新标签的就不用 ，不要使用 来存放段落等…… 4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解 Trident内核：IE Gecko内核：NETSCAPE6及以上版本，火狐 Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari，Chrome等。[Chrome的：Blink（WebKit的分支）] 浏览器内核又可以分成两部分：渲染引擎和JS引擎。 渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。 5. html5有哪些新特性 语义化标签: header footer nav section article aside 等 增强型表单：date(从一个日期选择器选择一个日期) email(包含 e-mail 地址的输入域) number(数值的输入域) range(一定范围内数字值的输入域) search(用于搜索域) tel(定义输入电话号码字段) 等 视频和音频：audio video Canvas绘图 SVG绘图 地理定位：Geolocation 拖放API：drag web worker：是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能 web storage: localStorage sessionStorage WebSocket: HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议6. 描述一下 cookie，sessionStorage 和 localStorage 的区别 特性 Cookie localStorage sessionStorage 生命周期 可设置失效时间，没有设置的话，默认是关闭浏览器后失效 除非被手动清除，否则将会永久保存 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 存放数据大小 4KB左右 可以保存5MB的信息 http请求 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 7. 如何实现浏览器内多个标签页之间的通信 使用localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket协议 webworker 多个标签页之间的通信 8. HTML5的离线存储怎么使用，解释一下工作原理 HTML5的离线存储 9. src与href的区别 区别：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系 浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的 当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件 10. 表单提交中Get和Post方式的区别 Get一般用于从服务器上获取数据，Post向服务器传送数据 Get传输的数据是拼接在Url之后的，对用户是可见的；Post的传输数据对用户是不可见的 Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制 Get安全性非常低，Post安全性较高 在FORM提交的时候，如果不指定Method，则默认为Get请求常见浏览器及其内核 Chrome Firefox Safari IE Opera 排版引擎 Blink Gecko Webkit Trident Blink JS 引擎 V8 SpiderMonkey Nitro Chakra V8 国内一些浏览器使用较多的是 Webkit 内核。 针对不同浏览器内核，HTML 辨别： IE 内核浏览器识别： 非 IE 内核浏览器识别： 针对不同浏览器内核，CSS 辨别： /* 设置文字不可选取 */ * { -moz-user-select: none; /* 火狐 浏览器 */ -webkit-user-select: none; /* Webkit 浏览器 */ -o-user-select: none; /* Opera 浏览器 */ -ms-user-select: none; /* IE10 浏览器 */ -khtml-user-select: none; /* 早期浏览器 */ user-select: none; /* 默认 */ } 11. cookies、session、sessionStorage、localStorage cookies：存储于浏览器端的数据。可以设置 cookies 的到期时间，如果不设置时间，则在浏览器关闭窗口的时候会消失。 session：存储于服务器端的数据。session 存储特定用户会话所需的属性和配置信息。 cookies 和 session 的区别在于： cookies 数据存放在客户的浏览器上，session 数据存放在服务器上。 前端都是裸君子，没有安全可言，cookies 可能会被黑客利用作数据欺骗。所以重要信息记得存 session。 session 如果在生效期内量过大，会占用服务器性能。 单个 cookies 保存的数据不能超过 4 K，很多浏览器限制一个站点保存最多 20 个 cookies。 sessionStorage：生命周期存在于标签页或窗口，用于本地存储一个会话（session）中的数据，这些数据会随着窗口或者标签页的关闭而被清空。 localStorage：生命周期是永久的，除非用户主动清除浏览器上存储的 localStorage 信息，否则它将会永久存在。 sessionStorage 和 localStorage 操作方法：setItem、getItem 以及 removeItem。 以 localStorage 为例： localStorage.getItem('name'); // 获取 name 的值 localStorage.setItem('name', 'jsliang'); // 设置 name 的值为 jsliang localStorage.removeItem('name'); // 删除 name 的值 参考 1：《前端分享之cookie的使用及单点登录》参考 2：《Cookie、session和localStorage、以及sessionStorage之间的区别》 渐进增强和优雅降级？ 复制代码 .transition{ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; } .transition{ 　　 transition: all .5s; 　　 -o-transition: all .5s; 　-moz-transition: all .5s; -webkit-transition: all .5s; } 第一个例子的写法叫做渐进增强（progressive enhancement），第二个例子的写法叫做优雅降级（graceful degradation）。（关于渐进增强，可以参考张鑫旭的文章： http://www.zhangxinxu.com/wordpress/?p=788） 什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？ 渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。） 优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。） 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要。 img 的 alt 与 title 有何异同？ strong 与 em 的异同？ img中的alt和title都是提示文字,但是alt是图片加载失败时的提示文字,title是鼠标放在图片上时的提示文字 strong和em都是强调的意思,只不过strong是强烈的强调,strong在显示时是黑粗体,em是倾斜体 Html b加粗与html strong加粗本质没有区别 document load 和document ready 的区别 load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数 问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 $(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行 在原生的jS中不包括ready()这个方法，只有load方法就是onload事件 document.write(),outerHTML、outerText、innerHTML、innerText属性 document.write是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。 outerHTML | outerText | innerHTML | innerText 这四个都是js原生DOM对象的属性，返回的数据都是string类型。 看例子： 获取属性 var oHtml = $(\"div\")[0].outerHTML; var oText = $(\"div\")[0].outerText; var iHtml = $(\"div\")[0].innerHTML; var iText = $(\"div\")[0].innerText; div a 分别返回： div a --------------------- div a --------------------- div a --------------------- div a 设置属性 $(\"div\")[0].outerHTML = \"a\"; $(\"div\")[0].outerText = \"a\"; $(\"div\")[0].innerHTML = \"a\"; $(\"div\")[0].innerText = \"a\"; 分别变成： a --------------------- &lt;a&gt;a&lt;/a&gt; --------------------- a --------------------- &lt;a&gt;a&lt;/a&gt; 也就是说: outer和inner决定是不是包含最外层（当前）标签； Text和HTML获取时决定是否把标签忽略，插入时决定是否把字符串解析为标签。 16.触发的先后顺序：> boxDom.addEventListener('mousedown', () => { console.log('mousedown发生了'); }) boxDom.addEventListener('mouseup', () => { console.log('mouseup发生了'); }) boxDom.addEventListener('click', () => { console.log('click发生了'); }) boxDom.addEventListener('touchstart', () => { console.log('touchstart发生了'); }) boxDom.addEventListener('touchend', () => { console.log('touchend发生了'); }) touchstart发生了 touchend发生了 mouseup发生了 mousedown发生了 click发生了 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-08 22:31:32 "},"CssAndHtml/Interview/Css.html":{"url":"CssAndHtml/Interview/Css.html","title":"Css ✘","keywords":"","body":"面试知识点 - css CSS CSS 属于表示层，负责如何显示有关内容。 CSS 学习推荐 《前端工程师手册》 《CSS 权威指南》 《CSS 揭秘》 《CSS 世界》 CSS部分  1. css盒子模型，box-sizing属性的理解  2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法  3. 如何让一个不定宽高的盒子水平垂直居中  4. px和em和rem的区别  5. position的值有哪些  6. display:none与visibility：hidden的区别  7. CSS中link 和@import的区别  8. 什么是响应式设计，响应式设计的基本原理是什么  9. 为什么要初始化CSS样式  10. CSS3有哪些新特性  11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用  12. CSS优化、提高性能的方法有哪些  13. 重绘和重排（回流）的理解  14. flex布局css预处理器  15. css预处理器  16. css中可以让文字在垂直和水平方向上重叠的两个属性是什么？  17.消除inline-block元素间隔  18.绘制三角形  19.选择器优先  20.css伪类和伪元素  21.脱离文档流的有哪些  22.为何要清除浮动？如何清除？  23.css哪些属性可以继承  24.三栏布局（圣杯和双飞翼）和两栏布局  25.:link、:hover、:active和:visited的区别？  26.左中右的满屏布局，左右固定220px,中间自适应并且要优先加载 CSS 1. css盒子模型，box-sizing属性的理解 IE盒模型和标准盒模型的区别 css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定 先说重要的区别： 两者的区别在于content的不同，IE盒模型的content包括border、padding 即IE的border,padding改变实际大小（width,height）不变。但是标准的会变 box-sizing是一个CSS3属性，与盒子模型有着密切联系。即决定元素的宽高如何计算，box-sizing有三个属性： box-sizing: content-box|border-box|inherit: content-box 使得元素的宽高即为内容区的宽高(默认模式) border-box: 计算方式content + padding + border = 本身元素大小，即缩小了content大小 inherit 指定box-sizing属性的值，应该从父元素继承 2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方式： 为父元素设置高度 为父元素添加overflow:hidden 伪元素.fix::after { content:\"\"; display:block; clear:both; } 使用伪元素的好处：不增加冗余的DOM节点，符合语义化 overflow:hidden可以触发BFC机制。BFC：块级格式化上下文，创建了 BFC的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算BFC的高度时，浮动元素也参与计算 3. 如何让一个不定宽高的盒子水平垂直居中 定位的方式 .father { position: relative; } .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; } css3属性 .father { position: relative; } .son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex布局 .father { display: flex; justify-content: center; align-items: center; } grid .grid{ display: grid; place-content: center; } 4. px和em和rem的区别? 移动端rem布局基本介绍及原理 px: 像素，相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em的值并不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素 的，也代表倍数 通俗的说，1rem = html的font-size值 例如，下这段代码。a标签的font-size值为0.5rem，实际就是100px*0.5=50px。 html{ font-size:100px; } a{ font-size:.5rem; } 如何使用rem进行布局？ 最简单的 const deviceWidth = document.documentElement.clientWidth || document.body.clientWidth; document.querySelector('html').style.fontSize = deviceWidth / 7.5 + 'px'; 1. 标签的rem单位的值怎么计算 通过使用 rem + js 改变html标签的font-size（整体缩放）实现兼容性更高的页面 下面来举个例子， 当我们拿到的设计图是750px的时候，窗口宽度750px，html的font-size的大小为100px； 也就是说1rem = 100px；所以标题的font-size的大小为26/100=.26rem； ### rem布局的效果： - 屏幕越大，标签就越大 - 屏幕越小，标签就越小 ### rem布局的原理： > 通过媒体查询的方式动态改变html标签的font-size的大小 当屏幕越大，让html标签的font-size变大即可 当屏幕越小，让html标签的font-size变小即可 ## 5. position的值有哪些 > static： 默认值。没有定位，元素出现在正常的流中 > relative（相对定位）：生成相对定位的元素,相对于其正常（原先本身）位置进行定位 > absolute（绝对定位）：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位 > fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位 ## 6. display:none与visibility：hidden的区别 区别 | display:none | visibility：hidden的 ---|---|--- 是否占据空间 | 不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中）| 该元素空间依旧存在 是否渲染 | 会触发reflow（回流），进行渲染 | 只会触发repaint（重绘），因为没有发现位置变化，不进行渲染 是否是继承属性 | 不是继承属性，元素及其子元素都会消失 | 是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出 ## 7. CSS中link 和@import的区别 > link属于XHTML标签，@import完全是CSS提供的一种方式,只能加载CSS > 加载顺序的差别，当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载 > 兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，而link标签无此问题 > 当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的 ## 8. 什么是响应式设计，响应式设计的基本原理是什么 > 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 ## 9. 为什么要初始化CSS样式 > 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异 > 初始化样式会对 SEO 有一定的影响 ## 10. CSS3有哪些新特性 - 实现圆角`border-radius`，阴影`box-shadow`，边框图片`border-image` - 对文字加特效`text-shadow`，强制文本换行`word-wrap`，线性渐变`linear-gradient` - 实现旋转`transform:rotate(90deg)`,缩放`scale(0.85,0.90)`,`translate(0px,-30px)`定位,倾斜`skew(-9deg,0deg)`; - 增加了更多的CSS选择器、多背景、`rgba()` - 唯一引入的伪元素是`::selection`； - 实现媒体查询`@media`，多栏布局`flex` - 过渡`transition` 动画`animation` 1）边框： border-radius：圆角边框，border-radius:25px; box-shadow：边框阴影，box-shadow: 10px 10px 5px #888888; border-image：边框图片，border-image:url(border.png) 30 30 round; （2）背景： background-size：规定背景图片的尺寸，background-size:63px 100px; background-origin：规定背景图片的定位区域，背景图片可以放置于 content-box、padding-box 或 border-box 区域。background-origin:content-box; CSS3 允许您为元素使用多个背景图像。background-image:url(bg_flower.gif),url(bg_flower_2.gif); （3）文本效果： text-shadow：向文本应用阴影，可以规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。text-shadow: 5px 5px 5px #FF0000; word-wrap：允许文本进行换行。word-wrap:break-word; （4）字体：CSS3 @font-face 规则可以自定义字体。 （5）2D 转换（transform） translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 transform: translate(50px,100px); rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform: rotate(30deg); scale()：元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。transform: scale(2,4); skew()：元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。transform: skew(30deg,20deg); matrix()： 把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。transform:matrix(0.866,0.5,-0.5,0.866,0,0); （6）3D 转换 rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform: rotateX(120deg); rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform: rotateY(130deg); （7）transition：过渡效果，使页面变化更平滑 transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。 transition-duration：过渡动画的一个持续时间。 transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 。 transition-delay：延迟多久后开始动画。 简写为：transition: [ || || || ]; （8）animation：动画 使用CSS3 @keyframes 规则。 animation-name: 定义动画名称 animation-duration: 指定元素播放动画所持续的时间长 animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )： 指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。 animation-delay: 指定元素动画开始时间 animation-iteration-count:infinite | ：指定元素播放动画的循环次 animation-direction: normal | alternate： 指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。 animation-play-state:running | paused ：控制元素动画的播放状态。 简写为： animation:[ || || || || || ] ## 11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用 > 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）,双冒号是在当前规范中引入的，用于区分伪类和伪元素 ## 12. CSS优化、提高性能的方法有哪些 - 移除空的css规则（Remove empty rules） - 正确使用display的属性 - 不滥用浮动、web字体 - 不声明过多的font-size - 不在选择符中使用ID标识符 - 遵守盒模型规则 - 尽量减少页面重排、重绘 - 抽象提取公共样式，减少代码量 ## 13. 重绘和重排（回流）的理解 1. 重绘（repaint或redraw）： 重绘是指当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知render 重新描绘相应的元素, 此过程称为重绘。 2. 重排： 重排是指某些元素变化涉及元素布局 (如width), 浏览器则抛弃原有属性, 重新计算，此过程称为重排。（重排一定会重绘，重绘不一定重排） 3. 回流（reflow）： 重排好的结果，传递给render以重新描绘页面元素, 此过程称为回流 [重绘和重排（回流）的理解](https://www.cnblogs.com/yxkNotes/p/12718693.html) ## 14. flex布局 [flex布局教程--阮一峰](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html) ## 15. css预处理器 提供了一种css的书写方式，常见的就是 [SAAS文档](http://sass.bootcss.com/docs/sass-reference/) 和 [LESS文档](https://less.bootcss.com/) ## 16. css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height 水平方向：letter-spacing 那么问题来了，关于letter-spacing的妙用知道有哪些么？ 答案:可以用于消除inline-block元素间的换行符空格间隙问题 ## 17.消除inline-block元素间隔 父元素 设置font-size：0 ；letter-spacing：-3px ，子元素重新设置font-size，letter-spacing: 0; ## 18.绘制三角形 首先先做一个测试深入理解一下盒子模型，主要体会一下height和border-width的用法： #div1{ height: 80px; border-style: solid; border-width: 100px 100px 100px 100px; border-color: red forestgreen blue cyan; width: 80px; } ``` \\ ## \\ 最后结果为： 其中，红色的块儿代表是上边框宽度，右边的块儿代表右边框宽度，以此类推，发现几个边距的宽度而言，他们之间的分界恰好是这个正方形的对角线所在的直线，如果里面的小盒子宽高无穷小，那么这个图形将是一个由四块不同颜色三角形拼接而成的图形，因此可以利用这个性质进行绘制三角形。若height:0;width:0;得到下面的图形： 如果我们想要得到一个上三角，那么根据刚刚的原理，只要将上边框、左右边框设置为隐藏，即可实现一个上三角。 border-color: transparent transparent blue transparent; 但是有个问题，这里这个三角距离上面总是有100px的边距，是因为隐藏的边框依然占位，所以直接将上边框去掉就好了 所以实现三角形 第一步：新建一个div。 第二步：为盒子添加样式。 1.向上.kailong{ width:0; height:0; border-right:50px solid transparent; border-left:50px solid transparent; border-bottom:50px solid red; } 2.向下.kailong{ width:0; height:0; border-right:50px solid transparent; border-left:50px solid transparent; border-top:50px solid red; } 3.向左 .kailong{ width:0; height:0; border-top:50px solid transparent; border-bottom:50px solid transparent; border-right:50px solid red; } 4.向右 .kailong{ width:0; height:0; border-top:50px solid transparent; border-bottom:50px solid transparent; border-left:50px solid red; } 19.选择器优先级 !important > 内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 元素选择器 = 关系选择器 = 伪元素选择器 > 通配符选择器 20.css伪类和伪元素 css伪类 css伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息，⽤来添加⼀些选择器的特殊效果。 :link, :visited, :hover, :focus, :active, :first-child, :lang - css3新增的伪类： :last-child, :only-child, :first-of-type, :last-of-type, :only-of-type, :nth-child(n), :nth-last-child(n), :nth-of-type(n), :nth-last-of-type(n), :root, :empty, :target, :enabled, :disabled, :checked, :not(selector), css伪元素 DOM树没有定义的虚拟元素 核⼼就是需要创建通常不存在于⽂档中的元素， ⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器::first-letter, ::first-line, ::before, ::after css3新增的伪元素 ::selection 总结 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息； 伪元素本质上是创建了一个有内容的虚拟容器； CSS3中伪类和伪元素的语法不同； 可以同时使用多个伪类，而只能同时使用一个伪元素；css伪类和伪元素的区别 为了避免大家混淆伪类和伪元素，css3中的标准规定伪类使用单冒号“:” ，伪元素使用双冒号“::”，但在此之前都使用的单冒号“:”，所以为了保证兼容伪元素两种使用方法都是可以的。 伪类可以叠加使用，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。 .box:first-child:hover { color: #000;} //使用伪类 .box:first-letter { color: #000;} //使用伪元素 .box:first-letter:hover { color: #000;} //错误写法 伪类与类优先级相同，伪元素与标签优先级相同。顺便说一下优先级怎么判断， 一般是 !important > 行内样式> ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性。还有一个简单的计算方法，内联样式表的权值为 1000，ID 选择器的权值为 100，Class 类选择器的权值为 10，HTML 标签选择器的权值为 1，权值实际并不是按十进制计算的，用数字表示只是说明思想，我们可以把选择器中规则对应做加法，比较权值大小，权值越大优先级越高，如果权值相同前面的样式会被后面的覆盖。 21.脱离文档流的有哪些 - 浮动 - 绝对定位 - 固定定位 > 元素脱离文档流会导致父元素高度塌陷，要修复高度塌陷问题，可以将子元素与父元素放在同一个BFC中 22.为何要清除浮动？如何清除？ 原因： > 元素设置了float属性后，就会脱离文档流，当 包含框 的高度小于 浮动框 的时候，会出现高度塌陷。因此才需要清除浮动！ 清除浮动方法： 1：给 包含框 添加 after伪元素清除浮动。代码： ``` .clearfix:after{ display: block; content:''; clear: both; height:0; } ``` 2：使用BFC， 原理：让浮动块包含在同一个BFC中。 给 包含框 加一个overflow：hidden就可以了；代码： ``` .container{ overflow: hidden; } .container div{ float: left; } ``` 3: 在 浮动元素 的最后面添加一个新元素，应用clear:both. ``` .clearfix{ clear:both; } ``` 这种方法不太好，使margin实效了，并且增加了一个无用的element 23.css哪些属性可以继承 字体相关：line-height, font-family, font-size, font-style, font-variant, font-weight, font 文本相关： letter-spacing, text-align, text-indent, text-transform, word-spacing 列表相关：list-style-image, list-style-position, list-style-type, list-style 颜色：color 24.三栏布局（圣杯和双飞翼）和两栏布局 一、两栏布局 左边固定长度，右边自适应 1. 浮动布局 + BFC 左 右 .left{ float:left; border:2px solid red; width:100px; } .right{ border:2px solid black; display:flow-root } 2. 浮动布局 / 绝对定位 + 外边距 左 右 .left{ float:left;/* position:absolute; */ border:2px solid red; width:100px; } .right{ border:2px solid black; margin-left:100px; } 3. 使用Flexbox .contain{ display:flex; flex-direction:row; } .left{ border:2px solid red; width:100px; } .right{ border:2px solid black; flex:1; } 二、三栏布局 两边固定长度，中间自适应 1. 浮动布局 + BFC 左 右 中 .left{ border:2px solid red; width:100px; float:left; } .center{ border:2px solid black; display:flow-root; } .right{ border:2px solid red; width:100px; float:right; } 2. 浮动布局 / 绝对定位 + 外边距 左 右 中 .left{ border:2px solid red; width:100px; float:left; } .center{ border:2px solid black; margin:0 100px } .right{ border:2px solid red; width:100px; float:right; } 3. 使用Flexbox 左 中 右 .contain{ display:flex; } .left{ border:2px solid red; width:100px; } .center{ border:2px solid black; flex:1 } .right{ border:2px solid red; width:100px; } 圣杯布局 .container { padding: 0 100px 0 200px; } .left { width: 200px; background: red; /* 关键点：-100%表示向左移动他的父元素content的宽度，这一行不能容纳，于是就**移动到了上一行**，刚好middle的左边界与left的左边界重合*/ margin-left: -100%; left: -200px; } .right { width: 100px; background: blue; margin-left: -100px; right: -100px; } .main { background: yellow; width: 100%; } .left, .main, .right{ float: left; min-height: 200px; position: relative; } main left right 双飞翼布局 中间的 div 外层用另一个 div 包裹了一下，然后被包裹用 margin 来把自己挤到中间 实现三栏水平布局之双飞翼布局 .left, .main, .right { float: left; min-height: 130px; text-align: center; } .left { margin-left: -100%; background: green; width: 200px; } .right { margin-left: -300px; background-color: red; width: 300px; } .main { background-color: blue; width: 100%; } .content{ /* 关键点：用margin把div挤到中间正常展示*/ margin: 0 300px 0 200px; } 　 　　 main 　　left 　　right 二者异同 圣杯布局与双飞翼布局实现的效果是一样的，即： 两边宽度不变，中间的部分会随浏览器窗口大小而改变。 相同点 middle中的三个div都用了浮动。 都利用负的margin-left把三个div放在一行。 middle的宽度设置为100%。 （处理遮挡文字以上的部分都相同） 不同点 圣杯布局为middle添加padding，将middle往中间缩，然后用position来处理两边的位置。 双飞翼布局是在middle里又加了一个inner，然后为inner添加padding。 25.:link、:hover、:active和:visited的区别？ >（小技巧：有一天我走在路上，捡到一个lv的包，我就很开心，笑haha。l在头，v在尾，ha依次在中间） ``` :link、:hover、:active和:visited的区别？ :link表示鼠标点击之前，也称为原始状态 :hover表示鼠标悬停状态 :active表示鼠标点击状态 :visited表示鼠标点击之后状态 ``` 26.左中右的满屏布局，左右固定220px,中间自适应并且要优先加载 order 声明在flex item上，其值是数值，默认值是0，用来控制flex item在flex container中的显示顺序，数值越小越靠前。如果flex items有相同的order属性值，则按照他们在文档流中的顺序排列。 有一点需要注意，order属性只是改变了元素的显示顺序，他们在文档流中的位置没有发生任何改变，所以像div:nth-child(1)这种选择器依然是按照元素在文档流中的顺序 center left right main { width: 100%; display: flex; } .left, .right { flex: 0 0 220px; } .center { flex: 1; } .left { order: -1; } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-08 22:01:07 "},"CssAndHtml/Interview/图片.html":{"url":"CssAndHtml/Interview/图片.html","title":"图片 ✘","keywords":"","body":"面试知识点 - 图片 在我们日常工作中，我们会经常使用 JPG、PNG、GIF、SVG 等格式图片。 但是，你真的懂图片吗？不同格式图片的区分，它们的优劣势以及使用场景等…… 下面，将根据搜集的资料，进行关于图片的科普。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 BMP  3.2 JPEG  3.3 PNG  3.4 GIF  3.5 SVG  3.6 Base64  3.7 WebP  3.8 雪碧图 四 总结 五 参考文献 二 前言 返回目录 你熟悉图片吗？能讲讲 JPG、PNG、GIF 的适用场景吗？然后 PNG 为什么会有 PNG-8 和 PNG-24？知道 SVG 吗？能讲讲它们与 JPG、PNG、GIF 的差别吗？…… 三 正文 返回目录 首先，我们要清楚的是，图片从类型上分，可以分为 位图 和 矢量图。 位图：位图又叫点阵图或像素图，计算机屏幕上的图是由屏幕上的发光点（即像素）构成的，每个点用二进制数据来描述其颜色与亮度等信息。因为这些点是离散的，类似于点阵，同时因为多个像素的色彩组合就形成了图片，所以叫这种图为点阵图或者位图。常见位图有 JPG、PNG、GIF 等格式。 矢量图：矢量图又叫向量图，它是由一系列计算机指令来描述和记录一幅图，一幅图可以解为点、线、面等组成的子图。生成的矢量图文件存储量很小，特别适用于文字设计、图案设计等，而在前端中比较常用的矢量图有 SVG 等格式…… 然后，我们按压缩划分，可以将图片分为 无损压缩 和 有损压缩。 无损压缩：无损压缩是对文件本身的压缩，使图片占用的存储空间变小，并且不会损害图片的质量。常见无损压缩有 PNG 等。 有损压缩：有损压缩是对图像本身的改变，会对图片质量造成损害，随着压缩次数越来越多，那么图片质量会越来越差。常见有损压缩有 JPG 等。 最后，究根结底，我们需要知道在计算机中，像素是用二进制来表示的。不同图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，那么它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。 一个二进制位表示两种颜色 【 0|1 黑|白 】，如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 中颜色。例如： PNG-8：它有 2^8 种颜色，即 256 种颜色。 PNG-24：它有 2^24 种颜色，即 1677216 种颜色（1600 万种颜色）。 OK，知道了这些基础知识，我们就按图片出现的顺序，一一讲解下常用的图片知识吧！ 3.1 BMP 返回目录 早期使用的图片格式，叫 BMP，取自英文单词 BitMap，Windows 中文版译作 位图，它的文件结构很简单，没有压缩，一个一个像素地记录下来。 如果你的系统是 Windows，你可以打开 画图 工具，然后点击另存为，你可以看到保存的选项中有个 24位位图 的格式，即 1600 万色的图片。 当然，历史总在前进，BMP 这种没有压缩的图片格式，逐渐被后起之秀代替了。 不知道为什么，查不到 JPG、PNG、GIF 的出现顺序，下面只好按我个人记忆方式来编文章段落。 3.2 JPEG 返回目录 关键字：有损压缩、体积小、加载快、不支持透明 简要介绍： JPEG/JPG 格式，是应用最广泛的图片格式之一，特点如下： JPEG/JPG 采用特殊的有损压缩算法，将不易被人眼察觉的图像颜色删除，从而达到较大的压缩比，因此它的压缩文件尺寸较小，下载速度快，成为互联网最广泛使用的格式。 JPEG/JPG 因为属于有损压缩，所以当压缩级别逐渐增大的时候，图片质量会逐渐损耗，所以压缩要适当。 在合适的场景下，即便我们将图片体积压缩至原有体积的 50% 以下，JPG 仍能保持住 60% 的品质，且因为 JPG 格式以 24 位图存储单个图，可以呈现多达 1600 万种颜色，足以满足大多数场景， 适用场景： 大的背景图 轮播图 Banner 图 3.3 PNG 返回目录 关键字：无损压缩、质量高、体积大、支持透明 简要介绍： PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式，它的压缩比高于 GIF，支持图像透明，可以利用 Alpha 通道调节图像透的明度。 PNG 分 PNG-8 和 PNG-24。 PNG-8：PNG-8 是无损压缩的索引色彩模式。PNG-8 是 GIF 格式很好的替代，虽然不能像 GIF 一样有动画，也不兼容 IE6 等老旧浏览器。PNG-8 最多支持 256 中颜色。 PNG-24：PNG-24 是无损压缩的直接色彩模式。PNG-24 会比 JPEG、GIF、PNG-8 占用更大的存储空间。PNG-24 可以呈现 1600 万种颜色。 2^8 = 256，2^24 = 1677216 适用场景： 普遍场景 小的 Logo，颜色简单且对比强烈的图片或者背景。 颜色简单、对比度强的透明小图。 什么时候使用 PNG-8，什么时候使用 PNG-24 呢？ 理论上，位数最大的就是最好的，直接上 PNG-24；但是实际上，为了避免体积过大的问题，一般在适合使用 PNG 的场景中，优先选择比较小巧的 PNG-8。 如何确定是使用 PNG-8 还是 PNG-24，这就看你的 UI 设计师或者负责人能接受那个了，除非你设计功底非常好，要不然不要做这个选择！ 3.4 GIF 返回目录 关键字：支持动画 简要介绍： GIF 格式，不仅仅支持静止图片，也可以支持动画，并且支持透明背景图像，适用于多种操作系统，体积很小，网上小动画很多是 GIF 格式。但是色域不太广，只支持 256 种颜色，这意味着颜色种类少。 GIF 格式的压缩率一般在 50% 左右。 适用场景： 动图 3.5 SVG 返回目录 关键字：文本文件、体积小、不失真、兼容性好 简要介绍： SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式，是可缩放的矢量图形。与 JPG、PNG、GIF 等位图不同，SVG 可以直接用代码来描绘图像，并通过任意文字处理工具打开 SVG 图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到 HTML 中通过浏览器来观看。 SVG 格式的图片可以任意放大图形显示，并且不会损失图片质量；SVG 格式可编辑和可搜寻；SVG 格式平均来讲，比 JPG 和 GIF 格式文件要小，并且下载也比较快。 SVG 文件通常是极小的，但是当图形的复杂度变高的时候，SVG 文件大小会随之上升，因为 SVG 在渲染的时候需要比像素图更多的计算能力，这也意味着性能的损耗。所以在 Logo 等图上，应尽可能简洁。 适用场景： SVG loading 效果图：SVG-Loaders 转换工具：在线 JPG、PNG 转 SVG 工具 矢量图标库：阿里巴巴矢量图标 3.6 Base64 返回目录 关键字：文本文件、依赖编码、小图标解决方案 简要介绍： Base64 并非一种图片格式，而是一种编码方式，它类似于雪碧图，是作为小图标解决方案而存在的。和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。Base64 是作为雪碧图的补充而存在的。 Base64 是一种用于传输 8 Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。 适用场景： 图片的实际尺寸很小。尽可能在图片不超过 2KB 的情况下（可查看掘金的 Base64 图）。 图片无法以雪碧图的形式与其他小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）。 图片的更新频率非常低（不需要我们重复编码和修改文件内容，维护成本较低） 为什么大图不使用 Base64？因为 Base64 编码后，图片大小会膨胀为源文件的 4/3，如果将大图编码到 HTML 或者 CSS 中，这样后者的体积增加，即便减少了 HTTP 请求，也无法弥补庞大的体积带来的性能开销。 如何获取： Webpack 的 loader：url-loader 在线编码工具：图片转换Base64 3.7 WebP 返回目录 关键字：年轻的全能型选手 简要介绍： 2010 年由 Google 提出，转为 Web 开发的一种旨在加快图片加载速度的图片格式，支持有损压缩和无损压缩。 WebP 像 JPEG 一样对图片细节丰富，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片。 官方介绍：与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。 适用场景： 由于 WebP 支持情况仅 Chrome、UC 等几家浏览器支持，所以局限性较大，目前暂不考虑使用。 参考自 Can I Use 网站中的浏览器支持程度：webp 3.8 雪碧图 返回目录 雪碧图，CSS Sprites，听起来就很清爽的一种图片，刚开始的时候 以为是大街小巷上卖的 3 块钱瓶装雪碧饮料上的图片，后来知道压根不是同一码事。 雪碧图不属于图片格式，而是一种图片应用形式。但是因为它在前端赫赫有名，经常使用，故此将其记载下来。 雪碧图又叫精灵图，因为 Sprites 的原因叫 “雪碧”，出现的原因是随着网速的提升，同时因为请求次数过多的时候会卡网页，所以我们就将 N 张小图集成到一张大图上，从而提升页面打开的速度。这种多张小图放在一张大图上的操作，就叫做精灵图（雪碧图 - CSS Sprites） 那么，平时如何使用雪碧图呢？ .img{background:url(../images/img.png) no-repeat;} .my-head{height:160px;width:120px;background-position:0 0;} .my-picture{height:292px;width:1253px;background-position:0 -160px;} @mixin img{background:url(../images/img.png) no-repeat; } @mixin my-head{height:160px;width:120px;background-position: 0 0;} @mixin my-picture{height:292px;width:1253px;background-position: 0 -160px;} 如上面代码所示，现在网上有非常多的雪碧图制作工具，我们只需要将小图发到工具上去，就可以生成大图，同时获得它的 css/sass 代码，而不需要自己一个一个定位。 这是 Windows 版本的工具，网上有很多雪碧图/精灵图制作工具，这里就不推荐本人使用的了。 MDN 定义：图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。 四 总结 返回目录 至此，我们对图片的介绍就结束了，在这里我们列个表进行汇总： 格式 使用场景 JPG/JPEG 1. 大的背景图； 2. 轮播图； 3. Banner 图 PNG 1. 小 Logo； 2. 透明背景 GIF 动态图片 SVG 能适应不同设备且画质不能损坏的图片 Base64 大小不超过 2KB，且更新率低的图片 雪碧图 小图太多的时候，集中成一张图片减少 HTTP 请求 雪碧图不属于格式，但属于一种应用形式 最后，在开发中会常用到一些资料，下面是 在图片方面的个人资源，如果小伙伴有其他的好用资源推荐，可以 QQ 或者评论留言： 常用优秀资源： SVG loading 效果：SVG-Loaders 矢量图标库：Iconfont-阿里巴巴矢量图标库 在线制作 Logo：U 钙网 压缩 PNG 或者 JPG：TinyPNG 获取图片素材： 千库网：地址 包图网：地址 在线转换工具： JPG、PNG 转 SVG JPG、PNG、GIF 转 Base64 JPG、PNG、GIF 转 ICO 其他资料支持： Can I Use —— 查看各种浏览器支持程度：caniuse.com 五 参考文献 返回目录 《jpg、png、svg、gif等图片格式的区别》 《PNG、JPEG、GIF、SVG应该用哪个？》 《图片优化——质量与性能的博弈》 《横向对比 gif、jpeg、png、svg，教你如何合理选择图像格式》 《JPG？GIF？PNG？前端如何选择图片格式？》 《矢量图与位图的区别》 《无损压缩和有损压缩是数码图像文件压缩的两种类型。》 不折腾的前端，和咸鱼有什么区别！ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-24 14:38:30 "},"CssAndHtml/Interview/移动端问题.html":{"url":"CssAndHtml/Interview/移动端问题.html","title":"移动端问题 ✘","keywords":"","body":"移动端问题  1. 移动端适配1px的问题终极方案  2. 去掉ios的input的圆角  3. 滚动穿透问题  4. ios 短信验证码自动填充时被复制两遍  5. ios 日期转换 NAN 的问题  6. 非可点击元素（label，span）,iso下不会触发  7. iOS 系统中文输入法输入英文  8. 移动端video的痛点 1. 移动端适配1px的问题终极方案 移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px长度映射到物理像素上就有2px或3px那么长 1.伪类 + transform 基于 media查询判断不同的设备像素比对线条进行缩放： .border_1px:before{ content: ''; position: absolute; top: 0; height: 1px; width: 100%; background-color: #000; transform-origin: 50% 0%; } @media only screen and (-webkit-min-device-pixel-ratio:2){ .border_1px:before{ transform: scaleY(0.5); } } @media only screen and (-webkit-min-device-pixel-ratio:3){ .border_1px:before{ transform: scaleY(0.33); } } 这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上 border-radius即可。 2.SVG(仅适合直线，圆角建议用transform于伪类实现）) postcss-write-svg 借助 PostCSS的 postcss-write-svg我们能直接使用 border-image和 background-image创建 svg的 1px边框： 在项目资源文件中新建svg.scss文件 @svg 1px-border { height: 2px; @rect { fill: var(--color, black); width: 100%; height: 50%; } } @svg 1px-border2 { width: 4px; height: 4px; @rect { fill: transparent; width: 100%; height: 100%; stroke-width: 25%; stroke: var(--color, black); } } 在需要使用的组件中引入，如果配置了eslint注意引号问题可能导致报错 @import \"./src/assets/sass/svg.scss\"; .hello { width: 100%; height: 100%; h1 { width: 375px; height: 200px; background: #303133; } p { width: 300px; height: 300px; margin: 0 auto; margin-top: 50px; background: pink; border: 1px solid transparent; border-image: svg(1px-border param(--color #000)) 2 2 stretch; } div { width: 200px; height: 200px; margin: 50px auto 0; border: 1px solid transparent; border-image: svg(1px-border2 param(--color blue)) 1 stretch; } } 2. 去掉ios的input的圆角 border-radius:0; -webkit-appearance:none;/*清除ios默认圆角*/ 这个是在input输入框设置border-bottom: 1px solid #C3C3C3;发现这根线在ios上2侧存在一个弧度。 3. 滚动穿透问题 问题描叙：弹出层内容滚动时，body跟随滚动。 解决办法： //打开模态框前调用 function fixedBody() { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; document.body.style.cssText += 'position:fixed;top:-' + scrollTop + 'px;'; } //关闭模态框后调用 function looseBody() { var body = document.body; body.style.position = 'static'; var top = body.style.top; document.body.scrollTop = document.documentElement.scrollTop = -parseInt(top); body.style.top = ''; } 基于vue指令的写法： directives: { fixed: { // inserted 被绑定元素插入父节点时调用 inserted () { var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; document.body.style.cssText += 'position:fixed;top:-' + scrollTop + 'px;'; }, // unbind 指令与元素解绑时调用 unbind () { var body = document.body; body.style.position = 'static'; var top = body.style.top; document.body.scrollTop = document.documentElement.scrollTop = -parseInt(top); body.style.top = ''; } } }, 还有一种方案是：使用（overscroll-behavior: contain;） 滚动不会传播给祖先。 4. ios 短信验证码自动填充时被复制两遍 因为type的number不支持maxLen，故这里使用type=tel。 5. ios 日期转换 NAN 的问题 ios 不支持例如2018-09-01 10:00:59这种\"-\"连接符。 这种方式在ios上获取的时间是NAN let startTime = new Date('2019/01/17 15:28:00').getTime(); 解决办法我们把“-” 替换为 “/” let startTime = new Date('2019/01/17 15:28:00'.replace(/-/g, '/')).getTime(); 6.非可点击元素（label，span）,iso下不会触发 一些情况下对非可点击元素（label，span）监听click事件，iso下不会触发，css增加cursor：pointer就搞定了。 7.iOS 系统中文输入法输入英文 iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格 可以通过正则去掉 this.value = this.value.replace(/\\u2006/g, ''); 8.移动端video的痛点 序列图片视频化技术高性能实现方法: 图片DOM对象预加载，放在内存中；播放开始，页面append当前图片DOM，同时移除上一帧DOM图片（如果有），保证页面中仅有一个图片序列元素； 对，很简单，没什么高超的技巧，但就是这种实现策略，对页面的开销是最小的，最终运行体验是最好的。 ``` CSS代码： .container { width: 256px; height: 464px; margin: auto; background-color: #000; position: relative; } .container > img { position: absolute; width: 100%; height: 100%; } .loading { position: absolute; height: 8px; width: 150px; border: 1px solid #eee; background: linear-gradient(to top, #eee, #eee); background-size: 0 100%; transition: background-size .1s; left: 0; top: 0; right: 0; bottom: 0; margin: auto; } .loading::before { content: attr(data-percent)'%'; position: absolute; left: 0; top: -1.5em; font-size: 12px; color: #eee; } HTML代码： JS代码： var urlRoot = './thumbs/'; var indexRange = [1, 47]; var maxLength = indexRange[1] - indexRange[0] + 1; // loading var eleContainer = document.getElementById('container'); var eleLoading = document.getElementById('loading'); // 存储预加载的DOM对象和长度信息 var store = { length: 0 }; // 图片序列预加载 for ( var start = indexRange[0]; start var img = new Image(); img.onload = function () { store.length++; // 存储预加载的图片对象 store[index] = this; play(); }; img.onerror = function () { store.length++; play(); }; img.src = urlRoot + index + '.jpg'; })(start); } var play = function () { // loading进度 var percent = Math.round(100 * store.length / maxLength); eleLoading.setAttribute('data-percent', percent); eleLoading.style.backgroundSize = percent + '% 100%'; // 全部加载完毕，无论成功还是失败 if (percent == 100) { var index = indexRange[0]; eleContainer.innerHTML = ''; // 依次append图片对象 var step = function () { if (store[index - 1]) { eleContainer.removeChild(store[index - 1]); } eleContainer.appendChild(store[index]); // 序列增加 index++; // 如果超过最大限制 if (index 再看一遍英姿'); } }; // 等100%动画结束后执行播放 setTimeout(step, 100); } }; ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-08 01:02:38 "},"CssAndHtml/Css/flex.html":{"url":"CssAndHtml/Css/flex.html","title":"flex ✔","keywords":"","body":"一、基本概念 Flex 容器: 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。 Flex 项目: 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。 在 Flexbox 模型中，有三个核心概念： – flex 项（注：也称 flex 子元素），需要布局的元素 – flex 容器，其包含 flex 项 – 排列方向（direction），这决定了 flex 项的布局方向 二、容器属性 2.1 flex-direction: row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿2.2 flex-wrap: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 2.3 justify-content: flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.4 align-items: flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.5 align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 结合 justify-content和align-items，看看在 flex-direction 两个不同属性值的作用下，轴心有什么不同： 三、项目属性 3.1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 80px; text-align: center; margin-left: 20px; } p:nth-child(1){ order: 4; } p:nth-child(2){ order: 3; } p:nth-child(4){ order: -1; /** 设置为-1 **/ } 1 2 3 4 3.2 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 80px; text-align: center; margin-left: 20px; } p:nth-child(1){ flex-grow: 2; } p:nth-child(2){ flex-grow: 1; } p:nth-child(3){ flex-grow: 1; margin-right: 20px; } 1 2 3 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.3 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 150px; text-align: center; margin-left: 20px; } p:nth-child(1){ } p:nth-child(2){ flex-shrink: 0; /**设置为0**/ } p:nth-child(3){ margin-right: 20px; } 1 2 3 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 3.4 Flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 150px; text-align: center; margin-left: 20px; } p:nth-child(2){ flex-basis: 30px; } 1 2 3 它可以设为跟width或height属性一样的值（比如30px），则项目将占据固定空间。 3.5flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 p { flex: none | [ ? || ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 3.6 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 例子 div{ display: flex; border: 1px solid #000; height: 250px; align-items: center; } p{ border: 1px solid red; width: 150px; text-align: center; margin-left: 20px; } p:nth-child(2){ align-self: flex-end; } 1 2 3 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 flex-start | flex-end | center | baseline | stretch; 参考1 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-06 11:18:33 "},"CssAndHtml/Css/grid.html":{"url":"CssAndHtml/Css/grid.html","title":"grid ✔","keywords":"","body":"一.基本概念 参考阮一峰 容器和项目 容器属性 display 属性 display: grid指定一个容器采用网格布局。 grid-template-columns 属性， grid-template-rows 属性, repeat(),auto-fill关键字,fr 关键字,minmax(),auto 关键字,网格线的名称 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性 grid-template-areas grid-auto-flow justify-items 属性， align-items 属性， place-items 属性 justify-content 属性， align-content 属性， place-content 属性 grid-auto-columns 属性， grid-auto-rows 属性 grid-template 属性， grid 属性 项目属性 下面这些属性定义在项目上面。 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性 grid-column 属性， grid-row 属性 这两个属性之中，也可以使用span关键字，表示跨越多少个网格 grid-area justify-self 属性， align-self 属性， place-self 属性 练习grid 1写一个左中右的满屏布局，左右固定220px,中间自适应并且要优先加载 ? .main { display: grid; grid-template-columns: 200px auto 200px; //auto 由浏览器自己决定长度。 grid-template-rows: 1fr; height: 200px; } .center { grid-area: 1 / 2 / 2 / 3; background: deepskyblue; } .left { grid-area: 1 / 1 / 2 / 2; background: skyblue; } .right { grid-area: 1 / 3 / 2 / 4; background: skyblue; } 垂直居中 .grid{ display: grid; place-content: center; } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-14 17:43:22 "},"CssAndHtml/Css/冷门css.html":{"url":"CssAndHtml/Css/冷门css.html","title":"冷门css ✔","keywords":"","body":"HTML5的标签meter 作用：定义已知范围或分数值内的标量测量。 说明： 标签不应用于指示进度（在进度条中）。如果标记进度条，请使用 标签。 注释： 标签是 HTML 5 中的新标签。显示度量值： 3/10 60% 注释：Internet Explorer 不支持 meter 标签。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-18 20:58:38 "},"CssAndHtml/Css/canvas.html":{"url":"CssAndHtml/Css/canvas.html","title":"canvas ✔","keywords":"","body":" 1. 程序求出物体的个数，以及每个不同物体的面积。  2. canvas进阶之图片缩放、水印及放大镜 1. 平面上有若干个不特定的形状，如下图所示。请写程序求出物体的个数，以及每个不同物体的面积？ 分析 想要知道有多少个图形，想到的就是先获取图片中的每一个像素点然后判获取像素点的背景颜色（RGBA）。想要获得图片中的每一个像素点，那就可以联想到使用h5的canvas。 如下： 菜鸟教程中canvas的getimagedata方法 书写html标签。 对不你，你的浏览器不支持Canvas js获取canvas对象 let ctxt = canvas.getContext('2d'); js创建image对象 let img = new Image; img.src = './image.png'; //图片路径 img.onload = function(){} //加载成功后的执行函数，之后的代码就写在其中 创建存储图片像素点的二维数组 let coordinates = []; for(let i=0; i获取像素点，也就是使用getimagedata方法。 ctxt.drawImage(img, 0, 0); //将图片画如canvas let data = ctxt.getImageData(0, 0, 350, 200).data;//读取整张图片的像素。 将像素存入二维数组 let x=0,y=0; //二维数组的行和列， x：列 y：行 for(let i =0,len = data.length; i= 350){ x = 0; y++; } } 目前代码如下： (function(){ let ctxt = canvas.getContext('2d'); let img = new Image; let coordinates = []; let h = 200, w = 350; for(let i=0; i= 350){ x = 0; y++; } } console.log(coordinates); } })(); 如图： 构成类似如下二维数组： 0,0,0,0,0,0,0,0,0,0,0,0 0,0,1,1,1,0,0,0,0,0,0,0 0,1,1,1,1,0,0,0,0,0,0,0 0,1,1,1,0,0,0,1,1,1,1,0 0,0,0,0,0,0,1,1,1,0,0,0 0,0,0,0,0,0,1,1,1,0,0,0 0,0,0,0,0,0,0,0,0,0,0,0 那么我们就只需要知道二维数组中这种连续为1的块有多少个就知道了图片中形状有多少个，并且块中有多少个1，那么这个块的面积就是1的个数。 递归回溯算法 //计算连续的面积和个数 const linkSum = (i,j,num)=>{ //走过的路就置0 coordinates[i][j] = 0; num++; //向上 if((i+1 = 0) && coordinates[i-1][j] == 1){ num = linkSum(i-1 , j , num); } //向右 if((j-1 >= 0) && coordinates[i][j-1] == 1){ num = linkSum(i , j-1 , num); } return num; } 不熟悉的，直接百度就好，这里就不多说了，其实代码就反应了很多信息。 使用算法，统计并计算出结果。 const getCountAndArea = () =>{ let sum = []; let count = 0; for(let i = 0; i 最后的代码 (function(){ let ctxt = canvas.getContext('2d'); let img = new Image; let coordinates = []; let h = 200, w = 350; for(let i=0; i= 350){ x = 0; y++; } } // console.log(coordinates); let rst = getCountAndArea(); // console.log(rst); console.log('个数： ' + rst.count); for(let i=0; i{ let sum = []; let count = 0; for(let i = 0; i { //走过的路就置0 coordinates[i][j] = 0; num++; //向上 if((i+1 = 0) && coordinates[i-1][j] == 1){ num = linkSum(i-1 , j , num); } //向右 if((j-1 >= 0) && coordinates[i][j-1] == 1){ num = linkSum(i , j-1 , num); } return num; } })(); 2. canvas进阶之图片缩放、水印及放大镜 一、拖动滑竿实现图片缩放 要实现的效果： 效果一 HTML布局： 您的浏览器尚不支持canvas var canvas = document.getElementById(\"canvas\") var context = canvas.getContext(\"2d\") var slider = document.getElementById(\"scale-range\") var image = new Image() window.onload = function(){ canvas.width = 1152 canvas.height = 768 var scale = slider.value image.src = \"img-lg.jpg\" image.onload = function(){ drawImageByScale( scale ) // 鼠标移动，实时改变缩放的值 slider.onmousemove = function(){ scale = slider.value drawImageByScale( scale ) } } } // 绘制裁切后的图片 function drawImageByScale( scale ){ var imageWidth = 1152 * scale var imageHeight = 768 * scale //context.drawImage( image , sx , sy , canvas.width , canvas.height , 0 , 0 , canvas.width , canvas.height ) 把裁切后的图片在canvas里绘制 前一部分是裁切图片，后一部分是把裁切后的图片在canvas里绘制 x = canvas.width /2 - imageWidth / 2 y = canvas.height / 2 - imageHeight / 2 context.clearRect( 0 , 0 , canvas.width , canvas.height ) // 清除矩形 context.drawImage( image , x , y , imageWidth , imageHeight ) // 把裁切后的图片在canvas内重新绘制 } 二、图片缩放+绘制水印 要实现的效果： 效果二 HTML布局： 您的浏览器尚不支持canvas 您的浏览器尚不支持canvas JS脚本： var canvas = document.getElementById(\"canvas\") var context = canvas.getContext(\"2d\") var slider = document.getElementById(\"scale-range\") var watermarkCanvas = document.getElementById(\"watermark-canvas\") var watermarkContext = watermarkCanvas.getContext(\"2d\") window.onload = function(){ canvas.width = 1152 canvas.height = 768 var image = new Image() var scale = 1.0 image.src = \"img-lg.jpg\" image.onload = function(){ drawImage( image , scale ) slider.onmousemove = function(){ // 鼠标移动不断绘制 类似于window.resize() touchMove drag scale = slider.value drawImage( image , scale ) } } // 水印画布 watermarkCanvas.width = 600 watermarkCanvas.height = 100 watermarkContext.font = \"bold 50px Arial\" // 设置字体 watermarkContext.fillStyle = \"rgba( 255 , 0 , 0 , 0.5 )\" // 填充rgba字体颜色 watermarkContext.textBaseline = \"middle\"; // 文本对齐方式 watermarkContext.fillText( \"== 天涯客 ==\" , 20 , 50 ) // 填充文本 } // 绘制图片函数 function drawImage( image , scale ){ imageWidth = 1152 * scale imageHeight = 768 * scale x = canvas.width /2 - imageWidth / 2 y = canvas.height / 2 - imageHeight / 2 context.clearRect( 0 , 0 , canvas.width , canvas.height ) context.drawImage( image , x , y , imageWidth , imageHeight ) // 绘制图片 context.drawImage( watermarkCanvas , canvas.width - watermarkCanvas.width , // 绘制水印 canvas.height - watermarkCanvas.height ) } 三、放大镜效果 要实现的效果： 效果三 HTML布局： 您的浏览器尚不支持canvas JS脚本： var canvas = document.getElementById(\"canvas\") var context = canvas.getContext(\"2d\") var offCanvas = document.getElementById(\"offCanvas\") var offContext = offCanvas.getContext(\"2d\") var image = new Image() var isMouseDown = false // 鼠标是否按下的标识 var scale window.onload = function(){ canvas.width = 1152 canvas.height = 768 image.src = \"img-lg.jpg\" image.onload = function(){ offCanvas.width = image.width // 原始图片的宽度 offCanvas.height = image.height // 原始图片的高度 scale = offCanvas.width / canvas.width // 原始图片的宽度与canvas画布的宽度比 context.drawImage( image , 0 , 0 , canvas.width , canvas.height ) // 绘制图片 设置宽高 offContext.drawImage( image , 0 , 0 ) // 绘制图片 不设置宽 } } // 获取相对于canvas画布的x,y坐标 function windowToCanvas( x , y ){ var bbox = canvas.getBoundingClientRect() // getBoundingClientRect()用来获取canvas这个矩形对象的属性 left,top, right, bottom, width, height return {x:x-bbox.left , y:y-bbox.top} } // 鼠标按下，进行放大绘制 canvas.onmousedown = function(e){ e.preventDefault() isMouseDown = true point = windowToCanvas( e.clientX , e.clientY ) drawCanvasWithMagnifier( true , point ) } // 鼠标抬起，停止放大绘制 canvas.onmouseup = function(e){ e.preventDefault() isMouseDown = false drawCanvasWithMagnifier( false ) } // 鼠标离开，停止放大绘制 canvas.onmouseout = function(e){ e.preventDefault() isMouseDown = false drawCanvasWithMagnifier( false ) } // 鼠标移动，实时的进行放大绘制 canvas.onmousemove = function(e){ e.preventDefault() if( isMouseDown == true ){ point = windowToCanvas( e.clientX , e.clientY ) drawCanvasWithMagnifier( true , point ) } } // 用放大镜绘制 function drawCanvasWithMagnifier( isShowMagnifier , point ){ context.clearRect( 0 , 0 , canvas.width , canvas.height ) context.drawImage( image , 0 , 0 , canvas.width , canvas.height ) if( isShowMagnifier == true ){ drawMagnifier( point ) } } // 放大镜绘制函数 function drawMagnifier( point ){ var mr = 200 // 半径 var imageLG_cx = point.x * scale // 当前坐标点x放大scale倍 var imageLG_cy = point.y * scale // 当前坐标点y放大scale倍 var sx = imageLG_cx - mr // 从sx坐标点，开始裁切x轴图片 var sy = imageLG_cy - mr // 从sy坐标点，开始裁切y轴图片 var dx = point.x - mr // 在canvas中绘制裁切后的图片，然后在x轴的dx坐标绘制 var dy = point.y - mr // 在canvas中绘制裁切后的图片，然后在y轴的dy坐标绘制 context.save() // 保存以前的状态 context.lineWidth = 10.0 // 描边宽度 context.strokeStyle = \"#069\" // 描边颜色 context.beginPath() // 开始路径 context.arc( point.x , point.y , mr , 0 , Math.PI*2 , false ) // 绘制圆 arc(圆心坐标，半径，开始弧度，结束弧度，顺时针) context.stroke() // 描边 context.clip() // 裁切圆形区域 context.drawImage( offCanvas , sx , sy , 2*mr , 2*mr , dx , dy , 2*mr , 2*mr ) // 在圆形区域内绘制放大后的区域图 context.restore() // 恢复到以前的状态 } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 13:09:24 "},"HttpAndBrowerAndPerformanceSafety/谷歌浏览器消息提示.html":{"url":"HttpAndBrowerAndPerformanceSafety/谷歌浏览器消息提示.html","title":"谷歌浏览器消息提示.md ✔","keywords":"","body":"Notification 浏览器的消息推送 Notification 对象，存在于window上，可以生成一个通知对象以推送推送浏览器消息通知。 这玩意兼容性不咋地，实不实用看场景。对外用户的应用，自然是鸡肋功能，因为你无法知道用户使用的是哪家哪版本的浏览器；对内部系统的帮助则是很大，内部员工使用的浏览器是可控的，为了实现更大的工作效率，该功能可用于比如站内消息、跟踪事务状态变化等的通知，并且，这玩意只要不关闭通知所在的网页，即使浏览器活动标签不是这个网页，依然可以弹出通知，这样就可以在做其他工作的同时及时收到需要的消息了。 实现效果如图(在Windows系统下，是在桌面右下侧图标栏上方弹出)： 对的，就是这个。但是你听我解释..我真的没有下过这个单... 进入正文。 Notification 是个构造函数，它上面有三个静态成员：maxActions、permission、requestPermission。 1. maxActions，这个属性值为2，表示支持的最大的actions数量(actions见下文)。 2. permission，这个属性有三个值：\"granted\"、\"denied\"、\"default\"，default 和 denied 效果一样，表示用户不允许该网站显示通知，granted表示用户允许该网站显示通知。 3. requestPermission，通过调用这个方法，浏览器会弹出框来让用户确认是否允许消息通知，该方法传入一个回调函数作为参数，用户授权结果作为回调函数的参数给到开发者；该方法返回一个Promise。 代码如下： // 打开chrome浏览器，打开www.baidu.com，打开控制台，然后... Notification.requestPermission(res =>{ console.log(res); }); /* * 返回值 * Promise {} * __proto__: Promise * [[PromiseStatus]]: \"resolved\" * [[PromiseValue]]: \"granted\" * * 输出值: granted 因为我点击了允许。 */ Notification.permission // 输出: \"granted\" Notification 构造函数需要2个参数：title，options。 title 是消息的标题 options 消息的配置信息，含有值： 2.1. body，通知消息的内容，只有Windows系统下Firefox可以显示多行数据，其余环境下只显示单行。 2.2. icon，通知的图标图片地址。 2.3. lang，消息通知的语言，值参考ISO 2 letter language codes 2.4. dir，文字排列方向，三个值：auto、ltr、rtl。只有Windows系统下Firefox浏览器支持... 2.5. image，当没有足够的空间显示通知本身时，用于表示通知的图像的URL。只有Windows系统下Chrome支持... 2.6. tag，在构造函数的选项参数中指定的通知ID(如果有的话)，暂未研究出怎么使用，也没找到详细的使用文档... 2.7. data，返回克隆后的消息格式，暂未研究出怎么使用，也没找到详细的使用文档... 2.8. actions，用户操作行为的数组，暂未研究出怎么使用，也没找到详细的使用文档... 2.9. badge，当没有足够的空间显示通知本身时，用于表示通知的图像的URL。然而测试过支持的浏览器，也没有一个对于这个属性做出反应... 2.10. vibrate，指定具有振动功能的设备发出振动模式，然而在iphone手机上下载了几个浏览器，都未成功弹出通知，所以该值结果还是未知... 2.11. requireInteraction，表示是否需要用户手动关闭通知，默认false，然而即使设置为true，通知也有系统来控制，并不会一直处于活动状态... 2.12. 还有几个还在试验阶段的配置... 综上所述，通过浏览器测试后(Firefox含Mac和Windows、Chrome含Mac和Windows、Safari)，通用的有效配置仅有3个：title，body，icon。 使用代码如下： function createNotify(title,options) { var PERMISSON_GRANTED = 'granted'; var PERMISSON_DENIED = 'denied'; var PERMISSON_DEFAULT = 'default'; if (Notification.permission === PERMISSON_GRANTED) { notify(title,options); } else { Notification.requestPermission(function (res) { if (res === PERMISSON_GRANTED) { notify(title,options); } }); } function notify($title,$options) { var notification = new Notification($title, $options); } } createNotify('测试通知',{body:'啊啊啊啊啊啊啊啊啊啊啊啊'}); Notification 实例上有一些事件：onclick、onerror、onclose(文档表示是要删除的方法)、onshow(文档表示是要删除的方法)；一个方法：close；属性：timestamp消息的时间戳。 代码如下： function createNotify(title,options) { var PERMISSON_GRANTED = 'granted'; var PERMISSON_DENIED = 'denied'; var PERMISSON_DEFAULT = 'default'; if (Notification.permission === PERMISSON_GRANTED) { notify(title,options); } else { Notification.requestPermission(function (res) { if (res === PERMISSON_GRANTED) { notify(title,options); } }); } function notify($title,$options) { var notification = new Notification($title, $options); console.log(notification); notification.onshow = function(event){ console.log('show : ',event); } notification.onclose = function(event){ console.log('close : ',event); } notification.onclick = function(event){ console.log('click : ',event); notification.close(); } } } createNotify('测试通知',{body:'啊啊啊啊啊啊啊啊啊啊啊啊'}); /* 依次打印 * show: Event Object(事件对象)，事件的type为\"show\" * click: Event Object(事件对象)，事件的type为\"click\"。点击消息后消息被关闭，跳到close事件。 * close: Event Object(事件对象)，事件的type为\"close\" */ 最后，它的兼容性是这样的... 最后，本地测试这玩意需要起个服务来访问(可以用java或者nodejs随便起个简单的)，直接打开html是无效的，估摸着是浏览器处理通知地址的时候所需依赖导致。 就这么多，将就着用。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-26 21:05:06 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/用户输入URL到浏览器呈现页面.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/用户输入URL到浏览器呈现页面.html","title":"用户输入URL到浏览器呈现页面 ✘","keywords":"","body":"面试知识点 - 用户输入URL到浏览器呈现页面 大纲 从浏览器接收url到开启网络请求线程 多进程的浏览器 多线程的浏览器内核 解析URL 网络请求都是单独的线程 更多 开启网络线程到发出一个完整的http请求 DNS查询得到IP tcp/ip请求 五层因特网协议栈 从服务器接收到请求到对应后台接收到请求 -负载均衡 -后台的处理 后台和前台的http交互 http报文结构 cookie以及优化 gzip压缩 长连接与短连接 http 2.0 https 单独拎出来的缓存问题，http的缓存 = 强缓存与弱缓存 = 缓存头部简述 = 头部的区别 解析页面流程 流程简述 HTML解析，构建DOM 生成CSS规则 构建渲染树 渲染 简单层与复合层 Chrome中的调试 资源外链的下载 loaded和domcontentloaded CSS的可视化格式模型 包含块（Containing Block） 控制框（Controlling Box） BFC（Block Formatting Context） IFC（Inline Formatting Context） 其它 JS引擎解析过程 JS的解释阶段 JS的预处理阶段 JS的执行阶段 回收机制 其它 总结 从浏览器接收url到开启网络请求线程 这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制 具体请看浏览器多进程到JS单线程，JS运行机制 多进程的浏览器 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程） 进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等 Browser进程：浏览器的主进程（负责协调、主控），只有一个 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制 浏览器渲染进程（内核进程）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程 多线程的浏览器内核 每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程 GUI线程 JS引擎线程 事件触发线程 定时器线程 网络请求线程 这里JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的 解析URL 输入URL后，会进行解析（URL的本质就是统一资源定位符） URL一般包括几大部分： protocol，协议头，譬如有http，ftp等 host，主机域名或IP地址 port，端口号 path，目录路径 query，即查询参数 fragment，即#后的hash值，一般用来定位到某个位置 网络请求都是单独的线程 每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载 因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复） 更多 开启网络线程到发出一个完整的http请求 这一部分主要内容包括：dns查询，tcp/ip请求构建，五层因特网协议栈等等 仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多） DNS查询得到IP 如果输入的是域名，需要进行dns解析成IP，大致流程： 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP 注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话） 而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化 tcp/ip请求 http的本质就是tcp/ip请求 需要了解3次握手规则建立连接以及断开连接时的四次挥手 tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输 三次握手 三次握手，其实就是要双方相互确认彼此能够通信。 一般要与对方确认可以通信，就要确认自己能够跟对方通信(1)，且能够收到对方的通信(2)，反过来对方也能够和自己通信(3)，且能收到自己的通信(4)。基于这一点，流程就简化为3次握手通信。 首先，client发送一个SYN=1，seq=X（X随机）到server，server收到这个消息，则确认了client能够与server通信这件事(1),这时，server将SYN=1，ACK=1，ack=X+1,seq=Y（Y随机）发送给client；client收到这个消息，则确认了client能够收到对方的通信(2)和server能够与client通信这件事(3)，最后client发送ack=Y+1,ACK=1返回给server，server收到后，确认了server能够收到client的通信这件事(4)。至此，双方的通信确认过程完成且建立了连接。（总结上面的发送信息，简单的说就是：SYN:表示一个想要连接对方的请求；ACK、ack表示一个答复对方连接请求的响应;中间随机数seq：请求连接的信物） 这里的三次握手重点每一次都有关联，seq随机一个数发送给对方，对方收到后用ack=seq+1的方式表示针对上一个通信的准确回复。如果不用序列号的话，client在最后一步的发送中可以发送任意数据给server，确认最后的连接过程且最终建立连接。由于client可以随意伪造任意多的ip，那么最终server建立了很多不存在且无用的TCP连接。 但是这个机制同样存在一个问题，就是SYN攻击。client伪造大量随机ip，向server发送SYN=1，seq=X的第一步的连接请求，server给不存在的ip发送SYN=1，ACK=1，ack=X+1,seq=Y响应，由于client的ip不是实际存在的，所以server发出的消息不能到达，server不断的重试直到超时，那么server的连接队列会被占满，正常的TCP握手请求就无法到达server，影响了正常的连接请求，导致网络阻塞或者server系统瘫痪。 这种SYN攻击通过命令netstat -nap | grep SYN_RECV可以查出来. 三次握手的步骤： 客户端：首先发送一个带 SYN 标志的数据包给对方 服务端：收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息 客户端：回传一个带 ACK 标志的数据包 建立连接成功后，接下来就正式传输数据 然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手） 三次握手的作用： 通过三次握手，就能明确双方的收发功能均正常，也就是说，保证了建立的连接是可靠的。而且，由上可见，三次是确保连接可靠的最少次数，再就多余。 四次挥手的步骤：（抽象派） 只要弄懂了三次握手，四次挥手很简单辣，因为四次就是将三次握手的第2步拆分了而已。为什么会拆分呢？是因为连接时必须同时进行连接，但是断开时，不一定同时断开，可能一方断开，另一方继续传输数据。 四次挥手(简化版)为： 第一次挥手：由浏览器发起，发送给服务器，我东西发完了（请求报文），你准备关闭吧 第二次挥手：由服务器发起，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备好 第三次挥手：有服务器发起，告诉浏览器，我东西发送完了（响应报文），你准备关吧 第四次挥手：由浏览器发起，告诉服务器，我东西接受完了，我准备关了，你也准备好吧 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 tcp/ip的并发限制 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等） 而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求 所以针对这个瓶颈，又出现了很多的资源优化方案 get和post的区别 get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。 get会产生一个tcp数据包，post两个 具体就是： get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据）， post请求时，浏览器先发送headers，服务器响应100 continue， 浏览器再发送data，服务器响应200（返回数据）。 再说一点，这里的区别是specification（规范）层面，而不是implementation（对规范的实现） 更多 五层因特网协议栈 其实就是一个概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。 简括就是： 从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。 当然，服务端的接收就是反过来的步骤 五层因特网协议栈其实就是： 1.应用层(dns,http) DNS解析成IP并发送http请求 2.传输层(tcp,udp) 建立tcp连接（三次握手） 3.网络层(IP,ARP) IP寻址 4.数据链路层(PPP) 封装成帧 5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质） 当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。 OSI七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程 除了层的数量之外，开放式系统互联（OSI）模型与TCP/IP协议有什么区别？ 开放式系统互联模型是一个参考标准，解释协议相互之间应该如何相互作用。TCP/IP协议是美国国防部发明的，是让互联网成为了目前这个样子的标准之一。开放式系统互联模型中没有清楚地描绘TCP/IP协议，但是在解释TCP/IP协议时很容易想到开放式系统互联模型。两者的主要区别如下： TCP/IP协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能 更多 从服务器接收到请求到对应后台接收到请求 服务端在接收到请求时，内部会进行很多的处理 这里由于不是专业的后端分析，所以只是简单的介绍下，不深入 负载均衡 对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡 当然了，负载均衡不止这一种实现方式，这里不深入… 简单的说： 用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户 后台的处理 一般后台都是部署到容器中的，所以一般为： 先是容器接受到请求（如tomcat容器） 然后对应容器中的后台程序接收到请求（如java程序） 然后就是后台会有自己的统一处理，处理完后响应响应结果 概括下： 一般有的后端是有统一的验证的，如安全拦截，跨域验证 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等） 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等） 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装） 然后就是将这个包从后端发送到前端，完成交互 后台和前台的http交互 前后端交互时，http报文作为信息的载体 所以http是一块很重要的内容，这一部分重点介绍它 http报文结构 报文一般包括了：通用头部，请求/响应头部，请求/响应体 通用头部 这也是开发人员见过的最多的信息，包括如下： Request Url: 请求的web服务器地址 Request Method: 请求方式 （Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE） Status Code: 请求的返回状态码，如200代表成功 Remote Address: 请求的远程服务器地址（会转为IP） 譬如，在跨域拒绝时，可能是method为options，状态码为404/405等（当然，实际上可能的组合有很多） 其中，Method的话一般分为两批次： HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP 1.0定义参考：https://tools.ietf.org/html/rfc1945 HTTP 1.1定义参考：https://tools.ietf.org/html/rfc2616 这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）： 200——表明该请求被成功地完成，所请求的资源发送回客户端 301——永久性重定向。该状态码表示请求的资源已被分配了新的 URI 302——临时性重定向。已移动的资源对应的URI 将来还有可能发生改变。 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 400——客户端请求有错（譬如可以是安全模块拦截） 401——请求未经授权 403——禁止访问（譬如可以是未登录时禁止） 404——资源未找到 500——服务器内部错误 502——错误网关 503——服务不可用 ... 再列举下大致不同范围状态的意义 1xx——指示信息，表示请求已接收，继续处理 2xx——成功，表示请求已被成功接收、理解、接受 3xx——重定向，要完成请求必须进行更进一步的操作 4xx——客户端错误，请求有语法错误或请求无法实现 5xx——服务器端错误，服务器未能实现合法的请求 请求/响应头部 请求和响应头部也是分析时常用到的 常用的请求头部（部分）： Accept: 接收类型，表示浏览器支持的MIME类型 （对标服务端返回的Content-Type） Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收 Content-Type：客户端发送出去实体内容的类型 application/x-www-form-urlencoded, multipart/form-data, application/json, application/xml 这四个是ajax的请求，表单提交或上传文件的常用的资源类型。 Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中 Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间 Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中 If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中 Cookie: 有cookie并且同域访问时会自动带上 Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive Host：请求的服务器URL Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私 Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段) User-Agent：用户客户端的一些必要信息，如UA头部等 常用的响应头部（部分）： Access-Control-Allow-Headers: 服务器端允许的请求Headers Access-Control-Allow-Methods: 服务器端允许的请求方法 Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*） Content-Type：服务端返回的实体内容的类型 text/html, text/plain, text/css, text/javascript, image/jpeg, image/png, image/gif Date：数据从服务器发送的时间 Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档 Last-Modified：请求资源的最后修改时间 Expires：应该在什么时候认为文档已经过期,从而不再缓存它 Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效 ETag：请求变量的实体标签的当前值 Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端 Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38） Server：服务器的一些相关信息 一般来说，请求头部和响应头部是匹配分析的。 譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错 譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误 譬如，在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应 还有很多的分析方法，这里不一一赘述 请求/响应实体 http请求时，除了头部，还有消息实体，一般来说 请求实体中会将一些需要的参数都放入进入（用于post请求）。 譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等 而一般响应实体中，就是放服务端需要传给客户端的内容 一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。 CRLF CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在 请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔 一般来说（分隔符类别）： CRLF->Windows-style LF->Unix Style CR->Mac Style cookie以及优化 cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。 场景如下（简述）： 在登陆页面，用户登陆了 此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等） 然后会有一个sessionid（相当于是服务端的这个session对应的key） 然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx 然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。 上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素） 一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在*cookie中设置httponly（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全） 另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。 譬如以下场景： 客户端在域名A下有cookie（这个可以是登陆时由服务端写入的） 然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源） 此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie 也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证 此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了） 当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是： 将静态资源分组，分别放到不同的域名下（如static.base.com） 而page.base.com（页面所在域名）下请求时，是不会带上static.base.com域名的cookie的，所以就避免了浪费 说到了多域名拆分，这里再提一个问题，那就是： 在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc） 此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用） 关于cookie的交互，可以看下图总结 长连接与短连接 首先看tcp/ip层面的定义： 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包） 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接 然后在http层面： http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接 http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接 注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效 http 2.0 http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的） 然后简述下http2.0与http1.1的显著不同点： http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来 http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。 所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等） 然后简述下http2.0的一些特性： 多路复用（即一个tcp/ip连接可以请求多个资源） 首部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） https https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析 一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了） HTTPS的七次握手（TCP三次+TLS四次） TLS的握手阶段是发生在TCP握手之后 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息） 对称加密和非对称加密 对称加密 即加密的密钥和解密的密钥相同, 非对称加密 非对称加密将密钥分为公钥和私钥,公钥可以公开,私钥需要保密,客户端公钥加密的数据,服务端可以通过私钥来解密 浏览器收到服务端的证书后 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密Premaster secret，发送给服务器。 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-session key 使用约定好的HASH算法计算握手消息，并使用生成的session key对消息进行加密，最后将之前生成的所有信息发送给服务端。 服务端收到浏览器的回复 利用已知的加解密方式与自己的私钥进行解密，获取Premaster secret 和浏览器相同规则生成session key 使用session key解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致 使用session key加密一段握手消息，发送给浏览器 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束， 之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密 单独拎出来的缓存问题（浏览器缓存和CDN缓存） http的缓存 前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的 缓存判断顺序 先判断Cache-Control，在Cache-Control的max-age之内，直接返回200 from cache； 没有Cache-Control再判断Expires，再Expires之内，直接返回200 from cache； Cache-Control=no-cache或者不符合Expires，浏览器向服务器发送请求； 服务器同时判断ETag和Last-Modified，都一致，返回304，有任何一个不一致，返回200。强缓存与弱缓存 缓存可以简单的划分成两种类型：强缓存200 ok ( from cache )与协商缓存（304） 区别简述如下： 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存 对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效 但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧） 缓存头部简述 上述提到了强缓存和协商缓存，那它们是怎么区分的呢？ 答案是通过不同的http头部控制 先看下这几个头部： If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires 这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。 属于强缓存控制的： （http1.1）Cache-Control/Max-Age （http1.0）Pragma/Expires 注意：Max-Age不是一个头部，它是Cache-Control头部的值 属于协商缓存控制的： （http1.1）If-None-Match/E-tag （http1.0）If-Modified-Since/Last-Modified 可以看到，上述有提到http1.1和http1.0，这些不同的头部是属于不同http时期的 HTML页面中可以用一个meta标签可以控制缓存方案 经测试跨浏览器禁止缓存的 headers,其他文件就需要使用服务器设置文件控制 header 如下： Cache-Control: no-cache, no-store, must-revalidate Pragma: no-cache Expires: 0 因为是 HTML 页面，可以于 HEAD 标签内直接添加 META 标签： 头部的区别 首先明确，http的发展是从http1.0到http1.1 而在http1.1中，出了一些新内容，弥补了http1.0的不足。 http1.0中的缓存控制： Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用） Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41 If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内 http1.1中的缓存控制： Cache-Control：缓存控制头部，有no-cache、max-age等多种取值 Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算 If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。 Max-Age相比Expires？ Expires使用的是服务器端的时间 但是有时候会有这样一种情况-客户端时间和服务端不同步 那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期 所以一般http1.1后不推荐使用Expires 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题 因此推荐使用Max-Age。 注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。 E-tag相比Last-Modified？ Last-Modified： 表明服务端的文件最后何时改变的 它有一个缺陷就是只能精确到1s， 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效 而E-tag： 是一种指纹机制，代表文件相关指纹 只有文件变才会变，也只要文件变就会变， 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了 如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag Etag主要在断点下载时比较有用 各大缓存头部的整体关系如下图 CDN 利用负载均衡等技术让用户访问就近的缓存服务器 解析页面流程 前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染 这部分很多都参考了网上资源，特别是图片，参考了来源中的文章 流程简述 浏览器内核拿到内容后，渲染步骤大致可以分为以下几步： 解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 如下图： HTML解析，构建DOM 整个渲染步骤中，HTML解析是第一步。 简单的理解，这一步的流程是这样的：浏览器解析HTML，构建DOM树。 但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。 解析HTML到构建出DOM当然过程可以简述如下： Bytes → characters → tokens → nodes → DOM 譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式） Critical Path Hello web performance students! 浏览器的处理如下： 列举其中的一些重点过程： Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符 Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集 Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则 DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样 例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象 最后的DOM树如下： 生成CSS规则 同理，CSS规则树的生成也是类似。简述为： Bytes → characters → tokens → nodes → CSSOM 譬如style.css内容如下： body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } 那么最终的CSSOM树就是： 相关面试题 css加载会阻塞阻塞DOM树解析和渲染吗？ css加载不会阻塞DOM树的解析 css加载会阻塞DOM树的渲染 css加载会阻塞后面js语句的执行 构建渲染树 当DOM树和CSSOM都有了后，就要开始构建渲染树了 一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应 因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等 整体来说可以看图： 渲染 有了render树，接下来就是开始渲染，基本流程如下 图中重要的四个步骤就是： 计算CSS样式 构建渲染树 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性 绘制，将图像绘制出来 然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint） 这里Layout和Repaint的概念是有区别的： Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树 Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了 回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。 什么会引起回流？ 1.页面渲染初始化 2.DOM结构改变，比如删除了某个节点 3.render树变化，比如减少了padding 4.窗口resize 5.最复杂的一种：获取某些属性，引发回流， 很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流， 但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括 (1) offset(Top/Left/Width/Height) (2) scroll(Top/Left/Width/Height) (3) cilent(Top/Left/Width/Height) (4) width,height (5) 调用了getComputedStyle()或者IE的currentStyle 回流一定伴随着重绘，重绘却可以单独出现 所以一般会有一些优化方案，如： 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document 避免多次读取offset等属性。无法避免则将它们缓存到变量 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高 注意：改变字体大小会引发回流 再来看一个示例： var s = document.body.style; s.padding = \"2px\"; // 回流+重绘 s.border = \"1px solid red\"; // 再一次 回流+重绘 s.color = \"blue\"; // 再一次重绘 s.backgroundColor = \"#ccc\"; // 再一次 重绘 s.fontSize = \"14px\"; // 再一次 回流+重绘 // 添加node，再一次 回流+重绘 document.body.appendChild(document.createTextNode('abc!')); 简单层与复合层 上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。 这里不展开，进简单介绍下： 可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的 如果开启了硬件加速功能，可以将某个节点变成复合图层 复合图层之间的绘制互不干扰，由GPU直接控制 而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速 更多参考： 普通图层和复合图层 Chrome中的调试 资源外链的下载 上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了 简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）： CSS样式资源 JS脚本资源 img图片类资源遇到外链时的处理 当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接） 遇到CSS样式资源 CSS资源的处理有几个特点： CSS下载时异步，不会阻塞浏览器构建DOM树 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建） 有例外，media query声明的CSS是不会阻塞渲染的 遇到JS脚本资源 JS脚本资源的处理有几个特点： 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已 defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行 注意，defer和async是有区别的： defer是延迟执行，而async是异步执行。 简单的说（不展开）： async是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前或后 defer是延迟执行，在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在DOMContentLoaded事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面） 遇到img图片类资源 遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方 loaded和domcontentloaded 简单的对比： DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成) load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了 CSS的可视化格式模型 这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源 前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： CSS的可视化格式模型 先了解： CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示） 然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局 换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等 说到底： CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树 另外，CSS有三种定位机制：普通流，浮动，绝对定位，如无特别提及，下文中都是针对普通流中的 关键字： 包含块（Containing Block） 控制框（Controlling Box） BFC（Block Formatting Context） IFC（Inline Formatting Context） 定位体系 浮动 ... 包含块（Containing Block） 一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。 元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系 譬如： 根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块 static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建 fixed的包含块是当前可视窗口 absolute的包含块由它最近的position 属性为absolute、relative或者fixed的祖先元素创建 如果其祖先元素是行内元素，则包含块取决于其祖先元素的direction特性 如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界 控制框（Controlling Box） 块级元素和块框以及行内元素和行框的相关概念 块框: 块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子box和生成的内容 块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围 关于匿名块框的生成，示例： Some text More text div生成了一个块框，包含了另一个块框p以及文本内容Some text，此时Some text文本会被强制加到一个匿名的块框里面，被div生成的块框包含（其实这个就是IFC中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同） 换句话说: 如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框） 行内框： 一个行内元素生成一个行内框 行内元素能排在一行，允许左右有其它元素 关于匿名行内框的生成，示例： Some emphasized text P元素生成一个块框，其中有几个行内框（如EM），以及文本Some ， text，此时会专门为这些文本生成匿名行内框 display属性的影响 display的几个属性也可以影响不同框的生成： block，元素生成一个块框 inline，元素产生一个或多个的行内框 inline-block，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生BFC） none，不生成框，不再格式化结构中，当然了，另一个visibility: hidden则会产生一个不可见的框 总结： 如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决） 如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列 BFC（Block Formatting Context） FC（格式上下文）？ FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如 FC像是一个大箱子，里面装有很多元素 箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染） 内部的规则可以是：如何定位，宽高计算，margin折叠等等 不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC 注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则 BFC规则： 在块格式化上下文中 每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边） 即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合） 除非这个元素也创建了一个新的BFC 总结几点BFC特点： 内部box在垂直方向，一个接一个的放置 box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠 BFC区域不会与float box重叠（可用于排版) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌） 如何触发BFC？ 根元素 float属性不为none position为absolute或fixed display为inline-block, flex, inline-flex，table，table-cell，table-caption overflow不为visible 这里提下，display: table，它本身不产生BFC，但是它会产生匿名框（包含display: table-cell的框）而这个匿名框产生BFC IFC（Inline Formatting Context） IFC即行内框产生的格式上下文 IFC规则 在行内格式化上下文中 框一个接一个地水平排列，起点是包含块的顶部。 水平方向上的 margin，border 和 padding 在框之间得到保留 框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐 行框 包含那些框的长方形区域，会形成一行，叫做行框 行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定 行框的规则： 如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割） 行框在堆叠时没有垂直方向上的分割且永不重叠 行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐） 行框的左边接触到其包含块的左边，右边接触到其包含块的右边。 结合补充下IFC规则： 浮动元素可能会处于包含块边缘和行框边缘之间 尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化 同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本） 当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性 空的行内框应该被忽略 即不包含文本，保留空白符，margin/padding/border非0的行内元素， 以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)， 并且不是以换行结束的行框， 必须被当作零高度行框对待 总结： 行内元素总是会应用IFC渲染规则 行内元素会应用IFC规则渲染，譬如text-align可以用来居中等 块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则 行内框内部，对于那些行内元素，一样应用IFC渲染规则 另外，inline-block，会在元素外层产生IFC（所以这个元素是可以通过text-align水平居中的），当然，它内部则按照BFC规则渲染 相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件） 但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解 其它 当然还有有一些其它内容： 譬如常规流，浮动，绝对定位等区别 譬如浮动元素不包含在常规流中 譬如相对定位，绝对定位，Fixed定位等区别 譬如z-index的分层显示机制等 这里不一一展开，更多请参考： http://bbs.csdn.net/topics/340204423 JS引擎解析过程 前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程） JS的解释阶段 首先得明确： JS是解释型语音，所以它无需提前编译，而是由解释器实时运行 引擎对JS的处理过程可以简述如下： 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token） 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree） 使用翻译器（translator），将代码转为字节码（bytecode） 使用字节码解释器（bytecode interpreter），将字节码转为机器码 最终计算机执行的就是机器码。 为了提高运行速度，现代浏览器一般采用即时编译（JIT-Just In Time compiler） 即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache） 这样整个程序的运行速度能得到显著提升。 而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8） 总结起来可以认为是： 核心的JIT编译器将源码编译成机器码运行 JS的预处理阶段 上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等） 预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分： 分号补全 JS执行是需要分号的，但为什么以下语句却可以正常运行呢？ console.log('a') console.log('b') 原因就是JS解释器有一个Semicolon Insertion规则，它会按照一定规则，在适当的位置补充分号 譬如列举几条自动加分号的规则： 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。 当有}时，如果缺少分号，会补分号。 程序源代码结束时，如果缺少分号，会补分号。 于是，上述的代码就变成了 console.log('a'); console.log('b'); 所以可以正常运行 当然了，这里有一个经典的例子： function b() { return { a: 'a' }; } 由于分号补全机制，所以它变成了： function b() { return; { a: 'a' }; } 所以运行后是undefined 变量提升 一般包括函数提升和变量提升 譬如： a = 1; b(); function b() { console.log('b'); } var a; 经过变量提升后，就变成： function b() { console.log('b'); } var a; a = 1; b(); 这里没有展开，其实展开也可以牵涉到很多内容的 譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等 JS的执行阶段 此阶段的内容中的图片来源：深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇） 解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念： 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文） VO（变量对象）和AO（活动对象） 作用域链 this机制等 这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性 执行上下文简单解释 JS有执行上下文） 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出） 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。 这样依次执行（最终都会回到全局执行上下文） 譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收 然后执行上下文与VO，作用域链，this的关系是： 每一个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 具体看变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链 回收机制 JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。 一般来说，垃圾处理器有自己的回收策略。 譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能） 常用的两种垃圾回收规则是： 标记清除 引用计数 Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），简单解释如下： 遍历所有可访问的对象。 回收已不可访问的对象。 譬如：（出自javascript高程） 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。 而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。 而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。 最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 关于引用计数，简单点理解： 跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug） GC的缺陷 和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作这是为了安全考虑。 而Javascript的GC在100ms甚至以上对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。 这就是引擎需要优化的点： 避免GC造成的长时间停止响应。 GC优化策略 这里介绍常用到的：分代回收（Generation GC） 目的是通过区分“临时”与“持久”对象: 多回收“临时对象”区（young generation） 少回收“持久对象”区（tenured generation） 减少每次需遍历的对象，从而减少每次GC的耗时。 像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。） 更多可以参考： V8 内存浅析 相关博文: FEX-输入 URL 到页面加载完成的过程中都发生了什么事情？ 从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ 一篇文章搞定前端面试 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-08 22:01:07 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/浏览器多进程到JS单线程，JS运行机制.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/浏览器多进程到JS单线程，JS运行机制.html","title":"浏览器多进程到JS单线程，JS运行机制 ✘","keywords":"","body":"浏览器多进程到JS单线程，JS执行机制 大纲 区分进程和线程 浏览器是多进程的 浏览器都包含哪些进程？ 浏览器多进程的优势 重点是浏览器内核（渲染进程） Browser进程和浏览器内核（Renderer进程）的通信过程 梳理浏览器内核中线程之间的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker，JS的多线程？ WebWorker与SharedWorker 简单梳理下浏览器渲染流程 load事件与DOMContentLoaded事件的先后 css加载是否会阻塞dom树渲染？ 普通图层和复合图层 区分进程和线程 通俗的话：如果把cpu看作一个工厂，那进程好比工厂的车间，代表cpu能处理的单个任务，任意时刻cpu总是运行一个进程，其他进程都要停止，线程就好比车间的工人.每个线程都共享着内存空间。 官方的话：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 根本区别： 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。浏览器是多进程的 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 浏览器都包含哪些进程？ Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有负责浏览器界面显示，与用户交互。如前进，后退等负责各个页面的管理，创建和销毁其他进程将Renderer进程得到的内存中的Bitmap，绘制到用户界面上网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 浏览器多进程的优势 相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。 重点是浏览器内核（渲染进程） 重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程 可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程 请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分） 终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）： GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 5.异步http请求线程 ** 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧： Browser进程和浏览器内核（Renderer进程）的通信过程 再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。 打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）， 然后在这前提下，看下整个的过程：(简化了很多) Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染 - 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） - 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来浏览器内核中线程之间的关系 GUI渲染线程与JS引擎线程互斥 由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 JS阻塞页面加载 从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？ 前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？ 所以，后来HTML5中支持了Web Worker。 MDN的官方解释是： Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面 一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window 因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误 这样理解下： 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect! 而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。 其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。WebWorker与SharedWorker 既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混） WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程 简单梳理下浏览器渲染流程 本来是直接计划开始谈JS执行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本） 为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文） 浏览器输入url，浏览器主进程接管，开一个下载线程， 然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容， 随后将内容通过RendererHost接口转交给Renderer进程 浏览器渲染流程开始 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了 既然略去了一些详细的步骤，那么就提一些可能需要注意的细节吧。 这里重绘参考来源中的一张图：（参考来源第一篇） 参考： load事件与DOMContentLoaded事件的先后 上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？ 很简单，知道它们的定义就可以了： 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了） 所以，顺序是：DOMContentLoaded -> load css加载是否会阻塞dom树渲染？ 这里说的是头部引入css的情况 首先，我们都知道：css是由单独的下载线程异步下载的。 然后再说下几个现象： css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 这可能也是浏览器的一种优化机制。 因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 普通图层和复合图层 渲染步骤中就提到了composite概念。 可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘） 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒 可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息 如何变成复合图层（硬件加速） 将该元素变成一个复合图层，就是传说中的硬件加速技术 最常用的方式：translate3d、translateZ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\\\\\\\\等元素 其它，譬如以前的flash插件 absolute和硬件加速的区别 可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。 所以，就算absolute中信息改变时不会改变普通文档流中render树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的） 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图） 复合图层的作用？ 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡 硬件加速时请使用index 使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染 具体的原理时这样的： webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 从Event Loop谈JS的执行机制 javascript是一门单线程语言，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果上一个任务的执行过程耗时很长，下一个任务就不得不等待很长的时间，这是设计者就把任务设成了同步任务和异步任务。同步任务在主线程上是一个个执行，而异步任务则会进入任务队列（task queue），只有在所有同步任务执行完，异步任务才会被执行 （ 事件循环机制： 上面讲了JS引擎线程会维护一个执行栈，执行栈中的所有任务从顶向下同步执行并出栈； 但当遇到一些需要异步执行的任务，如ajax、setTimeout等时，会立即返回函数，然后将异步操作交给浏览器内核中的其他模块处理（如timer、network、DOM Binding模块），接着主线程继续往下执行 栈中的任务。 当上面说的异步操作完成后如ajax接受完响应、setTimeout到达指定延时；这些任务 即回调函数会被放入到任务队列中。一般不同的异步任务的回调函数会放入不同的任务队列之中。（分为宏任务和微任务；优先执行微任务队列） 只有当执行栈为空时，执行引擎才会去看任务队列有无可执行的任务；如果有，就取一个放入到执行栈中执行。执行完后，执行栈为空，便又去检查任务队列。 不断地循环重复上述过程的机制，就是“事件循环(event loop)机制”。 总结： （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。 （3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些执行机制分析。 这里不谈可执行上下文，VO，scop chain等概念相关会总结 在知道JS引擎是单线程后再理解一个概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。 事件循环机制进一步补充 总结： JS引擎线程只执行执行栈中的事件 执行栈中的代码执行完毕，就会读取事件队列中的事件 事件队列中的回调事件，是由各自线程插入到事件队列中的 如此循环 单独说说定时器 上述事件循环机制的核心是：JS引擎线程和事件触发线程 但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？ 是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身） 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 譬如: setTimeout(function(){ console.log('hello!'); }, 1000); 这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行 setTimeout(function(){ console.log('hello!'); }, 0); console.log('begin'); 这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行 注意： 执行结果是：先begin后hello! 虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定) 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列） setTimeout而不是setInterval 用setTimeout模拟定期计时和直接用setInterval是有区别的。 因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关） 而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间） 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。 事件循环进阶：js 宏任务和微任务 可以看看这篇 简单概括： 宏任务（macrotask ）和微任务（microtask ） macrotask 和 microtask 表示异步任务的两种分类。 在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。 微任务和宏任务的区别: 微任务进入主线程执行是一队一队的, 而宏任务进入主线程是一个一个的。 微任务是在主线程空闲时批量执行, 宏任务是在事件循环下一轮的最开始执行 宏任务和微任务之间的关系 console.log(1) setTimeout(function() { console.log(2) }) Promise.resolve() .then(function() { console.log(3) }) console.log(4) // 打印结果: 1 4 3 2 整个的执行过程: stack(执行栈)、Micro(微任务)、Macro（宏任务） 1.初始状态： stack:[], Micro: [], Macro: [script]。执行栈为空, 微任务为空, 宏任务队列中有一个整体的 script代码 2. 主线程开始执行, 遇到console.log(1), 首先会打印 1 3. 继续向下执行,遇到 setTimeout异步任务,就将其加入到Macro(宏任务)队列中。等待执行 4. 继续向下执行, 遇到 Promise.resolve也是一个异步任务,单它是微任务,将其加入 Micro(微任务)队列中,等待着行 5. 解析console.log(4), 并且打印4。 当主线程执行完打印的结果依次是 1 和 4。 6. 这时候主线程就会问 任务(异步)队列,有没有微任务要执行,将所有的 Micro(微任务)加入执行栈执行, 打印结果 3 7. 微任务执行完了, 就开始下一轮事件循环, 将第一个 Macro(宏任务)压入执行栈执行, 再次打印 2。 再看个例子 setTimeout(() => { //执行后 回调一个宏事件 console.log('内层宏事件3') }, 0) console.log('外层宏事件1'); new Promise((resolve) => { console.log('外层宏事件2'); resolve() }).then(() => { console.log('微事件1'); }).then(()=>{ console.log('微事件2') }) 我们看看打印结果 外层宏事件1 外层宏事件2 微事件1 微事件2 内层宏事件3 宏任务先于微任务执行。宏任务包括整体代码script，setTimeout，setInterval；微任务有Promise，process.nextTick。上面的例子就是整体代码script，所以先执行 首先浏览器执行js进入第一个宏任务script进入主线程, 遇到 setTimeout 分发到宏任务Event Queue中 遇到 console.log() 直接执行 输出 外层宏事件1 遇到 Promise， new Promise 直接执行 输出 外层宏事件2 执行then 被分发到微任务Event Queue中 第一轮宏任务执行结束，开始执行微任务 打印 '微事件1' '微事件2' 第一轮微任务执行完毕，执行第二轮宏事件，打印setTimeout里面内容'内层宏事件3' 宏任务 # 浏览器 Node script √ √ setTimeout √ √ setInterval √ √ setImmediate x √ requestAnimationFrame √ x 微任务 # 浏览器 Node process.nextTick x √ MutationObserver √ x Promise.then catch finally √ √ 这个例子看懂基本js执行机制就理解了 //主线程直接执行 console.log('1'); //丢到宏事件队列中 setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') }) }) //微事件1 process.nextTick(function() { console.log('6'); }) //主线程直接执行 new Promise(function(resolve) { console.log('7'); resolve(); }).then(function() { //微事件2 console.log('8') }) //丢到宏事件队列中 setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') }) }) 首先浏览器执行js进入第一个宏任务进入主线程, 直接打印console.log('1') 遇到 setTimeout 分发到宏任务Event Queue中 遇到 process.nextTick 丢到微任务Event Queue中 遇到 Promise， new Promise 直接执行 输出 console.log('7'); 执行then 被分发到微任务Event Queue中 第一轮宏任务执行结束，开始执行微任务 打印 6,8 第一轮微任务执行完毕，执行第二轮宏事件，执行setTimeout 先执行主线程宏任务，然后主线程就会问 任务(异步)队列,有没有微任务要执行，再执行微任务，打印'2,4,3,5' 在执行第二个setTimeout,同理打印 ‘9,11,10,12’ 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 以上是在浏览器环境下执行的数据，只作为宏任务和微任务的分析，我在node环境下测试打印出来的顺序为：1，7，6，8，2，4，9，11，3，10，5，12。node环境执行结果和浏览器执行结果不一致的原因是：浏览器的Event loop是在HTML5中定义的规范，而node中则由libuv库实现。libuv库流程大体分为6个阶段：timers，I/O callbacks，idle、prepare，poll，check，close callbacks，和浏览器的microtask，macrotask那一套有区别。 参考： 从浏览器多进程到JS单线程，JS执行机制最全面的一次梳理 深入解析浏览器的幕后工作原理 js 宏任务和微任务 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-26 16:14:37 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/Axios.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/Axios.html","title":"Axios ✘","keywords":"","body":"Axios 饮水思源：Axios 中文文档 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 一 目录 目录 一 目录 二 正文  2.1 get  2.1 post 二 正文 返回目录 axios 实战经验 2.1 get 返回目录 方法：axios.get(url, options) 话不多说，先上代码： Vue学习 new Vue({ el: document.getElementById('app'), template: ` 发送请求 数据为： {{ getData }} `, data() { return { getData: '' } }, methods: { sendAjax() { // 直接使用 axios // get 为请求方式 axios.get('https://www.easy-mock.com/mock/5be3885e033152564881d354/getInfo') // then 为 promise 获取数据 .then((res) => { this.getData = res.data; }) // catch 为 promise 捕获异常 .catch(); } } }) 如上，我们使用 axios 非常简单，只需要引用它的 cdn，然后通过： axios.get() .then() .catch() 就可以直接调用 axios 获取数据。 2.2 post 返回目录 post 请求讲解 三 杂记 3.1 跨域代理 http-proxy-middleware | 代理了解推荐文章 步骤 1. 设置 index.js： dev: { proxyTable: { '/stat': { target: 'http://172.**.**.**:8080/', // 接口的域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 } }, }, 步骤 2. 设置 main.js 全局拦截器： // 设置 axios import axios from 'axios'; // 添加请求拦截器 axios.interceptors.request.use( (config) => { config.headers.common['timestamp'] = \"******\"; config.headers.common['deviceid'] = \"******\"; config.headers.common['signature'] = \"******\"; // 在发送请求之前做些什么 return config; }, (error) => { // 在请求错误时做些什么 return Promise.reject(error); }) 步骤 3. 调用 PartOne.vue： axios({ url: \"stat/getApersonnelDistribution\", method: \"get\", params: { rank: 4 }, }).then( (res) => { console.log(res); }) 3.2 单个页面多 API 调用 步骤 1. 全代码为： create() { this._getApi(); }, methods: { _getApi() { axios(xxx).then( res=> { console.log(res); this._drawxxx(res); }) }, _drawxxx(res) { } } 步骤 2. 理解： 首先，在 create() 中调用方法体。 然后，在 methods() 中编写方法体，方法体调用 axios。 最后，在方法体中通过 axios 获取到数据之后，将数据传入到方法中进行处理。 步骤 3. 缘故：这样分布处理，有利于代码逻辑优化，当某步出现错误的时候，方便调试。同时使用 _ 开头命名方法，防止与其他 api 冲突。 3.3 Axios 封装 步骤 1. 封装 api 到 src/api/api.js 中 api.js /** * 封装逻辑 * 1. 引入 axios。 * 2. 设置请求配置 request。如：请求超时，响应头等 * 3. 设置请求中的遮罩（未实现） * 4. 设置请求成功后的数据过滤（未实现） * 5. 设置并暴露接口，传 data、method、url 到请求配置 request 上。 */ // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 本地开发 dev 的时候，不需要开启这个 // baseURL: 'http://172.****.****.5:8080', timeout: 5000, headers: { timestamp: \"20181026094424\", deviceid: \"10102\", signature: \"F9CB03DD3ED50EDA5DB214C42D4DC0D6\", } }) /** * 获取用户名 * userId */ export const getUserName = data => request({ method: 'get', url: '/api/getUserName', params: data }) 步骤 2. 在 Pages 中调用： UserInfo.vue // 引用接口 import { getUserName } from \"@/api/api\" export default { methods: { _getUserName() { // 获取用户名 getUserName({ userId: this.userId, }).then( (res) => { console.log(\"\\n【API - 获取用户名】：\"); }) } } } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 21:40:00 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/OSI七层模型-tcpIP四层模型 - 五层模型.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/OSI七层模型-tcpIP四层模型 - 五层模型.html","title":"OSI七层模型-tcpIP四层模型 - 五层模型 ✘","keywords":"","body":"OSI七层模型-tcpIP四层模型 - 五层模型 源自http://www.colasoft.com.cn/download/protocols_map.php OSI七层模型 OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。OSI 七层模型是一种框架性的设计方法 ，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能使就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。如下图： 五层模型 5层只是OSI和TCP/IP的综合，是业界产生出来的非官方协议模型，但是很多具体的应用。实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。 tcp/IP四层模型 4层是指TCP/IP四层模型，主要包括：应用层、传输层、网络层和数据链路层。 4层协议和对应的标准7层协议的关系如下图： 数据包 从上往下，每经过一层，协议就会在包头上面做点手脚，加点东西，传送到接收端，再层层解套出来，如下示意图： 应用层 HTTP 超文本传输协议 FTP 文件传输协议 SMTP 简单邮件传输协议 TELNET TCP/IP终端仿真协议 POP3 邮局协议第三版 Finger 用户信息协议 NNTP 网络新闻传输协议 IMAP4 因特网信息访问协议第四版 LPR UNIX 远程打印协议 Rwho UNIX 远程 Who协议 Rexec UNIX远程执行协议 Login UNIX 远程登陆协议 RSH UNIX 远程Shell协议 NTF HP网络文件传输协议 RDA HP 远程数据库访问协议 VT 虚拟终端仿真协议 RFA HP 远程文件访问协议 RPC Remote Process Comm. S-HTTP 安全超文本传输协议 GDP网关发现协议 X-Window CMOT 基于TCP/IP的CMIP协议 SOCKS 安全套接字协议 FANP流属性通知协议 SLP服务定位协议 MSN微软网络服务 Radius 远程用户拨号认证服务协议 DNS 域名系统 NFS网络文件系统协议 NIS SUN 网络信息系统协议 R-STAT SUN远程状态协议 NSM SUN 网络状态监测协议 PMAP SUN 端口映射协议 Mount LPR UNIX远程打印协议 常用UDP协议的应用层服务 BOOTP引导协议 DHCP动态主机配套协议 NTP网络时间协议 TFTP简单文件传输协议 SNMP简单网络管理协议表示层 DECnet NSP LPP 轻量级表示协议 NBSSN NetBIOS会话服务协议 XDP外部数据表示协议 IPX会话层 SSL 安全套接字层协议 TLS传输层安全协议 DAP目录访问协议 LDAP轻量级目录访问协议 RPC远程过程调用协议 VINES NETRPC VFRP NeTBIOS IPX 传输层 XOT 基于tcp之上的X协议 Van Jacobson 压缩TCP协议 ISO-DE ISO 开发环境-------->NetBISO TALI 传输适配层接口协议 DSI、NetBIOS、IP NeTBIOS、ISO-TP SSP、SMB、MSRPC UDP用户数据报协议 RUDP可靠的用户数据报协议 Mobile IP 移动IP协议网络层 IP/IPv6 互联网协议/互联网协议第六版 ICMPv6互联网控制信息协议第六版 ICMP互联网控制信息协议 IGMP 互联网组管理协议 SLIP 串行线路IP协议 安全协议 AH 认证头协议 ESP 安装封装有效载荷协议 路由协议 EGP 外部网关协议 OSPF 开放最短路径优先协议 IGRP 内部网关路由协议 NHRP 下一跳解析协议 IE-IRGP 增强内部网关路由选择协议 RIPng for IPv6 IPv6路由信息协议 GGP 网关到网关协议 VRRP 虚拟路由器冗余协议 PGM 实际通用组播协议 RSVP 资源预留协议 PIM-DM 密集模式独立组播协议 DVMRP 距离矢量组播路由协议 RIP2 路由信息协议第二版 PIM-SM 稀疏模式独立组播协议 MOSPF 组播开放最短路径优先协议数据链路层 MPLS 多协议标签交换协议 XTP 压缩传输协议 DCAP 数据转换客户访问协议 SLE 串行连接封装协议 IPinIP IP套IP封装协议 隧道协议 PPTP点对点隧道协议 L2F第二层转发协议 L2TP 第二层隧道协议 ATMP接入隧道管理协议 Cisco 协议 CDP 思科发现协议 CGMP 思科组管理协议 地址解析协议 ARP地址解析协议 RAR逆向地址解析协议物理层 IEEE 802.2 Ethernet v.2 Internetwork Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-12 00:18:04 "},"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/什么是TCP、UDP、HTTP以及三者的区别.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/HttpAndBrower/什么是TCP、UDP、HTTP以及三者的区别.html","title":"什么是TCP、UDP、HTTP以及三者的区别 ✘","keywords":"","body":"IP： 网络层协议；（高速公路） TCP和UDP： 传输层协议；（卡车:主要解决数据如何在网络中传输） HTTP： 应用层协议；（货物: 如何包装数据）。HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 SOCKET： 套接字，TCP/IP网络的API。(港口码头/车站)Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 TCP/IP： 代表传输控制协议/网际协议，指的是一系列协议，TCP/IP 模型在 OSI 模型的基础上进行了简化，变成了四层，从下到上分别为：网络接口层、网络层、传输层、应用层。与 OSI 体系结构对比如下： 什么是TCP TCP(Transmission Control Protocol传输控制协议）是一种面向连接的，可靠的，基于字节流的传输通信协议。 1、tcp(Transmission Control Protocol传输控制协议) 2、传输层协议 3、原因：应用层需要可靠的连接，但是IP层没有这样的流机制 4、面向连接，即在客户端和服务器之间发送数据之间，必须先建立连接 5、位于应用层和IP层之间 6、连接需要建立三次握手、四次挥手断开连接 7、传输数据时可靠的 TCP连接建立——使用三次握手建立连接 1、客户端发送请求【寻址请求】 2、服务器端收到报文请求，向客户端发回确认报文【确认请求】 3、客户端收到服务端的报文进行回应。【连接请求】 三次握手完成，TCP客户端和服务端成功地建立连接，可以传输数据。 TCP终止一个连接——四次握手 1、数据验证请求码 2、传输结束标记 3、确认结束标记 4、连接断开标记 UDP(User Datagram Protocol用户数据报协议) 1、UDP(User Datagram Protocol用户数据报协议) 2、传输层协议 3、无连接的数据报协议 4、不能提供数据报分组，组装和不能对数据报进行排序 5、主要用于不要求分组顺序到达的传输中，分组传输顺序的检查和排序有应用层完成。 6、提供面向事务的简单不可靠传递服务。 7、UDP协议使用端口分别运行在同一台设备上的多个应用程序 8、功能：为了在给定的主句上能识别多个目的的地址，同时允许多个应用程序在同一台主句上工作并能够独立地进行数据包的发送和接受，设计用户数据报协议UDP TCP、UDP两者的区别 1、TCP是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP是无连接的（发送数据之前不需要先建立连接） 2、TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP使用越来越多。 4、每一条TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信。 5、TCP对系统资源要去比较多，UDP对系统资源要求比较少 6、UDP程序结构更加简单 7、TCP是流模式，UDP是数据报模式 1、字节流是通过二进制进行传输，比如0101010001之类的。 2、用户数据传输分为两种协议：udp、tcp。 3、UDP协议不建立连接直接传输，每次最大数据64k，打包形式。 4、TCP协议是经过三次握手协议(先连接)，安全，数据大小不限，传输速度慢。 Websocket Websocket协议解决了服务器与客户端全双工通信的问题。 注:什么是单工、半双工、全工通信？ 信息只能单向传送为单工； 信息能双向传送但不能同时双向传送称为半双工； 信息能够同时双向传送则称为全双工。 websocket协议解析 wensocket协议包含两部分:一部分是“握手”，一部分是“数据传输”。 WebSocket和Socket区别 可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。 HTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。 WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-10-26 00:14:38 "},"HttpAndBrowerAndPerformanceSafety/Interview/safe/safe.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/safe/safe.html","title":"网络安全相关 ✘","keywords":"","body":"面试知识点 - web安全 [参考]（https://segmentfault.com/a/1190000012693772） 一、说说你所知道的web安全及防护措施 常用攻击手段：SQL注入、XSS(Cross Site Script)，跨站脚本攻击、CSRF(Cross Site Request Forgery)，跨站点伪造请求 （1）XSS xss: 跨站脚本攻击（Cross Site Scripting）是最常见和基本的攻击 WEB 网站方法，攻击者通过注入非法的 html 标签或者 javascript 代码，从而当用户浏览该网页时，控制用户浏览器。 (一) 类别（三种） DOM xss : DOM即文本对象模型，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。这种方式不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。 反射型 xss : 反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。 存储型 Xss 存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，它不需要用户手动触发。 当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。 （二） Xss危害 利用虚假输入表单骗取用户个人信息。 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。 （三） 抵御Xss危害 httpOnly: 在 cookie 中设置 HttpOnly 属性，使js脚本无法读取到 cookie 信息。 前端负责输入检查，后端也要做相同的过滤检查。 某些情况下，不能对用户数据进行严格过滤时，需要对标签进行转换 （二） CSRF 跨站点请求伪造（Cross-Site Request Forgeries），冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。 1、可能造成危害： 利用已通过认证的用户权限更新设定信息等； 利用已通过认证的用户权限购买商品； 利用已通过的用户权限在留言板上发表言论。 2、防御： 验证码；强制用户必须与应用进行交互，才能完成最终请求。 尽量使用 post ，限制 get 使用；get 太容易被拿来做 csrf 攻击； 请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。 token 验证 CSRF 防御机制是公认最合适的方案。 使用token的原理： 第一步：后端随机产生一个 token，把这个token 保存到 session 状态中；同时后端把这个token 交给前端页面； 第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端； 后端验证前端传来的 token 与 session 是否一致，一致则合法，否则是非法请求。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-17 01:55:19 "},"HttpAndBrowerAndPerformanceSafety/Interview/Performance/":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/Performance/","title":"性能相关 ✘","keywords":"","body":"我们都知道对于Web应用来说性能很重要。然而性能优化相关的知识却非常的庞大并且杂乱。对于性能优化需要做些什么以及性能瓶颈是什么，通常我们并不清楚（不包括那些对性能优化有丰富经验的高手）。 事实上关于Web性能有很多可以优化的点，其中涉及到的知识大致可以划分为几类：度量标准、编码优化、静态资源优化、交付优化、构建优化、性能监控。 本文主要介绍性能优化需要做的事以及需要考虑的问题。目的在于给读者脑海中生成一个宏观的地图。 不会介绍每个优化项目具体如何操作。PS：后续会有系列文章针对不同优化分类下的具体优化操作进行更详细的介绍。 1.度量标准与设定目标 在进行性能优化之前，我们需要为应用选择一个正确的度量标准（性能指标）以及设定一个合理的优化目标。 并不是所有指标都同样重要，这取决于你的应用。最后根据度量标准设定一个现实的目标。 1.1 度量标准 下面是一些值得考虑的指标： 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上） 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成） 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互） 输入响应（Input responsiveness，界面响应用户输入所需的时间） 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好） 自定义指标，由业务需求和用户体验来决定。 FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。 1.2设定目标 100毫秒的界面响应时间与60FPS 速度指标（Speed Index）小于1250ms 3G网络环境下可交互时间小于5s 重要文件的大小预算小于170kb 以上四种指标的设定都有据可循。详细信息请查看RAIL性能模型。 2.编码优化 编码优化涉及到应用的运行时性能，本小节介绍几个可以提升程序运行时性能的建议。 2.1 数据读取速度 事实上数据访问速度有快慢之分，下面列出几个影响数据访问速度的因素： 字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢 变量从局部作用域到全局作用域的搜索过程越长速度越慢 对象嵌套的越深，读取速度就越慢 对象在原型链中存在的位置越深，找到它的速度就越慢 推荐的做法是缓存对象成员值。将对象成员值缓存到局部变量中会加快访问速度 2.2 DOM 应用在运行时，性能的瓶颈主要在于DOM操作的代价非常昂贵，下面列出一些关于DOM操作相关提升性能的建议： 在JS中对DOM进行访问的代价非常高。请尽可能减少访问DOM的次数（建议缓存DOM属性和元素、把DOM集合的长度缓存到变量中并在迭代中使用。读变量比读DOM的速度要快很多。） 重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，建议先让元素脱离文档流，处理完毕后再让元素回归文档流，这样浏览器只会进行两次重排与重绘（脱离时和回归时）。 善于使用事件委托 2.3 流程控制 下面列出一些流程控制相关的一些可以略微提升性能的细节，这些细节在大型开源项目中大量运用（例如Vue）： 避免使用for...in（它能枚举到原型，所以很慢） 在JS中倒序循环会略微提升性能 减少迭代的次数 基于循环的迭代比基于函数的迭代快8倍 用Map表代替大量的if-else和switch会提升性能 3.静态资源优化 Web应用的运行离不开静态资源，所以对静态资源的优化至关重要。 3.1 使用Brotli或Zopfli进行纯文本压缩 在最高级别的压缩下Brotli会非常慢（但较慢的压缩最终会得到更高的压缩率）以至于服务器在等待动态资源压缩的时间会抵消掉高压缩率带来的好处，但它非常适合静态文件压缩，因为它的解压速度很快。 使用Zopfli压缩可以比Zlib的最大压缩提升3％至8％。 3.2 图片优化 尽可能通过srcset，sizes和元素使用响应式图片。还可以通过元素使用WebP格式的图像。 响应式图片可能大家未必听说过，但响应式布局大家肯定都听说过。响应式图片与响应式布局类似，它可以在不同屏幕尺寸与分辨率的设备上都能良好工作（比如自动切换图片大小、自动裁切图片等）。 当然，如果您不满足这种尺度的优化，还可以对图片进行更深层次的优化。例如：模糊图片中不重要的部分以减小文件大小、使用自动播放与循环的HTML5视频替换GIF图，因为视频比GIF文件还小（好消息是未来可以通过img标签加载视频）。 4.交付优化 交付优化指的是对页面加载资源以及用户与网页之间的交付过程进行优化。 4.1 异步无阻塞加载JS JS的加载与执行会阻塞页面渲染，可以将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS。有多种无阻塞加载JS的方法：defer、async、动态创建script标签、使用XHR异步请求JS代码并注入到页面。 但更推荐的做法是使用defer或async。如果使用defer或async请将Script标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。 4.2 使用Intersection Observer实现懒加载 懒加载是一个比较常用的性能优化手段，下面列出了一些常用的做法： 可以通过Intersection Observer延迟加载图片、视频、广告脚本、或任何其他资源。 可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。 延迟加载所有体积较大的组件、字体、JS、视频或Iframe是一个好主意 4.3 优先加载关键的CSS CSS资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成标签中CSS的加载与解析之后才会渲染页面。如果CSS文件过大，用户就需要等待很长的时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的CSS提取出来内嵌到中，然后再将剩余部分的CSS用异步的方式加载。可以通过Critical做到这一点。 4.4 资源提示（Resource Hints） Resource Hints（资源提示）定义了HTML中的Link元素与dns-prefetch、preconnect、prefetch与prerender之间的关系。它可以帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。 4.4.1 dns-prefetch dns-prefetch可以指定一个用于获取资源所需的源（origin），并提示浏览器应该尽可能早的解析。 > 4.4.2 preconnect preconnect用于启动预链接，其中包含DNS查找，TCP握手，以及可选的TLS协议，允许浏览器减少潜在的建立连接的开销。 4.4.3 prefetch Prefetch用于标识下一个导航可能需要的资源。浏览器会获取该资源，一旦将来请求该资源，浏览器可以提供更快的响应。 > > 浏览器不会预处理、不会自动执行、不会将其应用于当前上下文。 as与crossorigin选项都是可选的。 4.4.4 prerender prerender用于标识下一个导航可能需要的资源。浏览器会获取并执行，一旦将来请求该资源，浏览器可以提供更快的响应。 浏览器将预加载目标页面相关的资源并执行来预处理HTML响应。 4.5 Preload 通过一个现有元素（例如：img，script，link）声明资源会将获取与执行耦合在一起。然而应用可能只是想要先获取资源，当满足某些条件时再执行资源。 Preload提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。因此，Preload可以构建自定义的资源加载与执行。 例如，应用可以使用Preload进行CSS资源的预加载、并且同时具备：高优先级、不阻塞渲染等特性。然后应用程序在合适的时间使用CSS资源： var res = document.createElement(\"link\"); res.rel = \"preload\"; res.as = \"style\"; res.href = \"styles/other.css\"; document.head.appendChild(res); Link: ; rel=preload; as=style 4.6 快速响应的用户界面 PSI（Perceptual Speed Index，感知速度指数）是提升用户体验的重要指标，让用户感觉到页面的反馈比没有反馈体验要好很多。 可以尝试使用骨架屏或添加一些Loading过渡动画提示用户体验。 输入响应（Input responsiveness）指标同样重要，甚至更重要。试想，用户点击了网页后缺毫无反应会是什么心情。JS的单线程大家已经不能再熟悉，这意味着当JS在运行时用户界面处于“锁定”状态，所以JS同步执行的时间越长，用户等待响应的时间也就越长。 据调查，JS执行100毫秒以上用户就会明显觉得网页变卡了。所以要严格限制每个JS任务执行时间不能超过100毫秒。 解决方案是可以将一个大任务拆分成多个小任务分布在不同的Macrotask中执行（通俗的说是将大的JS任务拆分成多个小任务异步执行）。或者使用WebWorkers，它可以在UI线程外执行JS代码运算，不会阻塞UI线程，所以不会影响用户体验。 应用越复杂，主动管理UI线程就越重要 5.构建优化 现代前端应用都需要有构建的过程，项目在构建过程中是否进行了合理的优化，会对Web应用的性能有着巨大的影响。例如：影响构建后文件的体积、代码执行效率、文件加载时间、首次有效绘制指标等。 5.1 使用预编译 拿Vue举例，如果您使用单文件组件开发项目，组件会在编译阶段将模板编译为渲染函数。最终代码被执行时可以直接执行渲染函数进行渲染。而如果您没有使用单文件组件预编译代码，而是在网页中引入vue.min.js，那么应用在运行时需要先将模板编译成渲染函数，然后再执行渲染函数进行渲染。相比预编译，多了模板编译的步骤，所以会浪费很多性能。 5.2 使用 Tree-shaking、Scope hoisting、Code-splitting Tree-shaking是一种在构建过程中清除无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。 目前Webpack与Rollup都支持Scope Hoisting。它们可以检查import链，并尽可能的将散乱的模块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了一次的模块才会被合并。使用Scope Hoisting可以让代码体积更小并且可以降低代码在运行时的内存开销，同时它的运行速度更快。前面2.1节介绍了变量从局部作用域到全局作用域的搜索过程越长执行速度越慢，Scope Hoisting可以减少搜索时间。 code-splitting是Webpack中最引人注目的特性之一。此特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。code-splitting可以用于获取更小的bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 5.3 服务端渲染（SSR） 单页应用需要等JS加载完毕后在前端渲染页面，也就是说在JS加载完毕并开始执行渲染操作前的这段时间里浏览器会产生白屏。 服务端渲染（Server Side Render，简称SSR）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。 比较推荐的做法是：使用服务端渲染静态HTML来获得更快的首次有效绘制，一旦JavaScript加载完毕再将页面接管下来。 5.4 使用import函数动态导入模块 使用import函数可以在运行时动态地加载ES2015模块，从而实现按需加载的需求。 这种优化在单页应用中变得尤为重要，在切换路由的时候动态导入当前路由所需的模块，会避免加载冗余的模块（试想如果在首次加载页面时一次性把整个站点所需要的所有模块都同时加载下来会加载多少非必须的JS，应该尽可能的让加载的JS更小，只在首屏加载需要的JS）。 使用静态import导入初始依赖模块。其他情况下使用动态import按需加载依赖 5.5 使用HTTP缓存头 正确设置expires，cache-control和其他HTTP缓存头。 推荐使用Cache-control: immutable避免重新验证。 6.其他 其他一些值得考虑的优化点： HTTP2 使用最高级的CDN（付费的比免费的强的多） 优化字体 其他垂直领域的性能优化 7.性能监控 最后，你可能需要一个性能检测工具来持续监视网站的性能。 8.总结 最后用一张图来总结这篇文章所表达的内容 参考资源 https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/ 《高性能JavaScript》 https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images https://www.w3.org/TR/preload/ https://w3c.github.io/resource-hints/ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-25 12:13:59 "},"HttpAndBrowerAndPerformanceSafety/Interview/Performance/detail.html":{"url":"HttpAndBrowerAndPerformanceSafety/Interview/Performance/detail.html","title":"详细 ✔","keywords":"","body":"性能优化 === https://csspod.com/frontend-performance-best-practices/ 页面内容 减少 HTTP 请求数 减少 DNS 查询 避免重定向 缓存 Ajax 请求 延迟加载 预先加载 减少 DOM 元素数量 划分内容到不同域名 尽量减少 iframe 使用 避免 404 错误 服务器 使用 CDN 添加 Expires 或 Cache-Control 响应头 启用 Gzip 配置 Etag 尽早输出缓冲 Ajax 请求使用 GET 方法 避免图片 src 为空 Cookie 减少 Cookie 大小 静态资源使用无 Cookie 域名 CSS 把样式表放在 中 不要使用 CSS 表达式 使用 替代 @import 不要使用 filter JavaScript 把脚本放在页面底部 使用外部 JavaScript 和 CSS 压缩 JavaScript 和 CSS 移除重复脚本 减少 DOM 操作 使用高效的事件处理 事件委托 防抖（debounce）/节流（throttle） 防抖（debounce） 输入搜索时，可以用防抖debounce等优化方式，减少http请求； 这里以滚动条事件举例：防抖函数 onscroll 结束时触发一次，延迟执行 function debounce(func， wait) { let timeout; return function() { let context = this; // 指向全局 let args = arguments; if (timeout) { clearTimeout(timeout); } timeout = setTimeout(() => { func.apply(context， args); // context.func(args) }， wait); }; } // 使用 window.onscroll = debounce(function() { console.log('debounce'); }， 1000); 节流（throttle） 节流函数：只允许一个函数在N秒内执行一次。滚动条调用接口时，可以用节流throttle等优化方式，减少http请求； 下面还是一个简单的滚动条事件节流函数：节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样 function throttle(fn， delay) { let prevTime = Date.now(); return function() { let curTime = Date.now(); if (curTime - prevTime > delay) { fn.apply(this， arguments); prevTime = curTime; } }; } // 使用 var throtteScroll = throttle(function() { console.log('throtte'); }， 1000); window.onscroll = throtteScroll; 图片 优化图片 优化 CSS Sprite 不要在 HTML 中缩放图片 使用体积小、可缓存的 favicon.ico 移动端 ß保持单个文件小于 25 KB ß打包内容为分段（multipart）文档 webpack性能优化和监控 https://blog.csdn.net/weixin_44157964/article/details/108110972 webpack 优化构建速度（可用于生产） 优化 babel-loader IgnorePlugin noParse happyPack ParallelUgligyPluginwebpack 优化构建速度（不可用于生产） 自动刷新 热更新 DllPluginwebpack 优化产出代码 小图片 base64 编码 bundle 加 hash 懒加载 提取公共代码 使用 CDN 加速 IgnorePlugin 使用 Production Scope Hosting 1、noParse: 不去分析某个模块中的依赖关系，即不去管某个文件是否 import(依赖)了某个文件，对于一些独立的库，比如 jquery，其根本不存在依赖关系 module.exports = { module: { noParse:/jquery/,//不去解析jquery中的依赖库 } } 2. exclude: exclude: 在 loader 中使用 exclude 排除对某些目录中的文件处理，即引入指定目录下的文件时候，不使用对应的 loader 进行处理，exclude 是 loader 配置中的一个属性，属性值为正则表达式，如: module.exports = { module: { rules: [ { test: /\\.js$/, use: [ { loader: \"babel-loader\", options: { presets: [\"@babel/preset-env\"], plugins: [\"@babel/plugin-transform-runtime\"] } } ], exclude: /node_modules/ } ] } } 3、使用 IgnorePlugin 使用 IgnorePlugin 来忽略某个模块中某些目录中的模块引用，比如在引入某个模块的时候，该模块会引入大量的语言包，而我们不会用到那么多语言包，如果都打包进项目中，那么就会影响打包速度和最终包的大小，然后再引入需要使用的语言包即可，如: 项目根目录下有一个 time 包，其中有一个 lang 包，lang 包中包含了各种语言输出对应时间的 js 文件，time 包下的 index.js 会引入 lang 包下所有的 js 文件，那么当我们引入 time 模块的时候，就会将 lang 包下的所有 js 文件都打包进去，添加如下配置: const webpack = require(\"webpack\"); module.exports = { plugins: [ new webpack.IgnorePlugin(/lang/, /time/) ] } 引入 time 模块的时候，如果 time 模块中引入了其中的 lang 模块中的内容，那么就忽略掉，即不引入 lang 模块中的内容，需要注意的是，这 /time/ 只是匹配文件夹和 time 模块的具体目录位置无关，即只要是引入了目录名为 time 中的内容就会生效 4、使用 HappyPack 使用 HappyPack：由于在打包过程中有大量的文件需要交给 loader 进行处理，包括解析和转换等操作，而由于 js 是单线程的，所以这些文件只能一个一个地处理，而 HappyPack 的工作原理就是充分发挥 CPU 的多核功能，将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程，happypack 主要起到一个任务劫持的作用，在创建 HappyPack 实例的时候要传入对应文件的 loader，即 use 部分，loader 配置中将使用经过 HappyPack 包装后的 loader 进行处理，如: module.exports = { plugins: [ new HappyPack({ // 这里对处理css文件的loader进行包装 id: \"css\",// 之前的loader根据具体的id进行引入 use: [\"style-loader\",\"css-loader\"], threads: 5 // 设置开启的进程数 }) ], module: { rules: [ { test: /\\.css$/, // 匹配以.css结尾的文件 use: [\"happypack/loader?id=css\"] //根据happypack实例中配置的id引入包装后的laoder，这里的happyPack的h可以大写也可以小写 } ] } } 注意： webpack 要打包的文件非常多的时候才需要使用 happypack 进行优化，因为开启多进程也是需要耗时间的，所以文件少的时候，使用 happypack 返回更耗时 5、抽离公共模块: 抽离公共模块: 对于多入口情况，如果某个或某些模块，被两个以上文件所依赖，那么可以将这个模块单独抽离出来，不需要将这些公共的代码都打包进每个输出文件中，这样会造成代码的重复和流量的浪费，即如果有两个入口文件 index.js 和 other.js，它们都依赖了 foo.js，那么如果不抽离公共模块，那么 foo.js 中的代码都会打包进最终输出的 index.js 和 other.js 中去，即有两份 foo.js 了。抽离公共模块也很简单，直接在 optimization 中配置即可，如: module.exports = { splitChunks: { // 分割代码块，即抽离公共模块 cacheGroups: { // 缓存组 common: { // 组名为common可自定义 chunks: \"initial\", minSize: 0, // 文件大小为0字节以上才抽离 minChunks: 2, // 被引用过两次才抽离 name: \"common/foo\", // 定义抽离出的文件的名称 } } } } 这样就会将公共的 foo.js 模块抽离到 common 目录下 foo.js 中了，但是如果我们也有多个文件依赖了第三方模块如 jquery，如果按以上配置，那么 jquery 也会被打包进 foo.js 中，会导致代码混乱，所以我们希望将 jquery 单独抽出来，即与 foo.js 分开，我们可以复制一份以上配置，并通过设置抽离代码权重的方式来实现，即优先抽离出 jquery，如: module.exports = { splitChunks: { // 分割代码块，即抽离公共模块 cacheGroups: { // 缓存组 common: { // 组名为common可自定义 chunks: \"initial\", minSize: 0, // 文件大小为0字节以上才抽离 minChunks: 2, // 被引用过两次才抽离 name: \"common/foo\", // 定义抽离出的文件的名称 }, verdor: { test: /node_modules/, priority: 1, // 设置打包权重，即优先抽离第三方模块 chunks: \"initial\", minSize: 0, // 文件大小为0字节以上才抽离 minChunks: 2, // 被引用过两次才抽离 name: \"common/jquery\", // 定义抽离出的文件的名称 } } } } 这样就会在 common 目录下同时抽离出 foo.js 和 jquery.js 了，需要注意的是，代码的抽离必须是该模块没有被排除打包，即该模块会被打包进输出 bundle 中，如果第三方模块已经通过 externals 排除打包，则以上 vendor 配置无效。 按需加载 6、按需加载，即在需要使用的时候才打包输出，webpack 提供了 import() 方法，传入要动态加载的模块，来动态加载指定的模块，当 webpack 遇到 import()语句的时候，不会立即去加载该模块，而是在用到该模块的时候，再去加载，也就是说打包的时候会一起打包出来，但是在浏览器中加载的时候并不会立即加载，而是等到用到的时候再去加载，比如，点击按钮后才会加载某个模块，如: const button = document.createElement(\"button\"); button.innerText = \"点我\" button.addEventListener(\"click\", () => { // 点击按钮后加载foo.js import(\"./foo\").then((res) => { // import()返回的是一个Promise对象 console.log(res); }); }); document.body.appendChild(button); 从中可以看到，import() 返回的是一个 Promise 对象，其主要就是利用 JSONP 实现动态加载，返回的 res 结果不同的 export 方式会有不同，如果使用的 module.exports 输出，那么返回的 res 就是 module.exports 输出的结果；如果使用的是 ES6 模块输出，即 export default 输出，那么返回的 res 结果就是 res.default，如: // ES6模块输出，res结果为 {default: \"foo\", __esModule: true, Symbol(Symbol.toStringTag): \"Module\"} 7.ParallelUglifyPlugin ParallelUglifyPlugin可以开启多进程压缩JS文件 import ParallelUglifyPlugin from 'webpack-parallel-uglify-plugin'; module.exports = { plugins: [ new ParallelUglifyPlugin({ test, include, exclude, cacheDir, workerCount, sourceMap, uglifyJS: { }, uglifyES: { } }), ], }; 压缩图片 抽取公共模块 在 webpack4 之前，都是利用 CommonsChunkPlugin 插件来进行公共模块抽取。 到了 webpack4 之后，利用了 SplitChunksPlugin 插件来进行公共模块抽取，所以以下只针对 SplitChunksPlugin 插件进行说明。 Scope Hoisting Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。 比如我们希望打包两个文件 // test.js export const a = 1 // index.js import { a } from './test.js' 对于这种情况，我们打包出来的代码会类似这样 [ /* 0 */ function (module, exports, require) { //... }, /* 1 */ function (module, exports, require) { //... } ] 但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码 [ /* 0 */ function (module, exports, require) { //... } ] 这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。 module.exports = { optimization: { concatenateModules: true } } Tree Shaking Tree Shaking 可以实现删除项目中未被引用的代码，比如 // test.js export const a = 1 export const b = 2 // index.js import { a } from './test.js' 对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。 如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。 外围扩展 externals externals 用于排除一些引入的模块，不进行打包，引用外部的模块。 通常，我们这样引入vue模块 import vue from 'vue' 但是我们映入了CDN就不要再打包这个模块了，所以通过 externals 来排除这个模块 externals: { vue: 'vue' } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-27 10:08:30 "},"Javascript/interview/js基础面试.html":{"url":"Javascript/interview/js基础面试.html","title":"Javascript基础面试","keywords":"","body":" 目录  1. JavaScript 有哪些数据类型  2. 怎么判断不同的JS数据类型  3. undefined 和 null 有什么区别  4. 数组对象有哪些常用方法  5. Js 有哪几种创建对象的方式  6. 怎么实现对对象的拷贝(浅拷贝与深拷贝)  7. 什么是闭包，为什么要用它  8. 介绍一下 JavaScript 原型，原型链，它们有何特点  9. JavaScript 如何实现继承  10. new 操作符具体干了什么  11. 同步和异步的区别，怎么异步加载 JavaScript  12. 跨域问题的产生，怎么解决它  13. 对 this 的理解  14. apply()、call()和 bind() 是做什么的，它们有什么区别  15. 什么是内存泄漏，哪些操作会造成内存泄漏  16. 什么是事件代理，它的原理是什么  17. 对AMD和CMD的理解，它们有什么区别  18. 对ES6的了解  19. 箭头函数有什么特点  20. Promise 对象的了解  21. async 函数以及 awit 命令  22. export 与 export default有什么区别  23. 前端性能优化  24. 对JS引擎执行机制的理解  25. 事件流  26. 事件循环event-loop  27. ES6中的class语法的实现？ 1. JavaScript 有哪些数据类型 6种原始数据类型： Boolean: 布尔表示一个逻辑实体，可以有两个值：true 和 false Number: 用于表示数字类型 String: 用于表示文本数据 Null: Null 类型只有一个值： null,特指对象的值未设置 Undefined: 一个没有被赋值的变量会有个默认值 undefined Symbol: 符号(Symbols)是ECMAScript第6版新定义的。符号类型是唯一的并且是不可修改的 引用类型：Object 详见 JavaScript的数据类型-MDN 2. 怎么判断不同的JS数据类型 typeof操作符：返回一个字符串，表示未经计算的操作数的类型 typeof 操作符对于简单数据类型，返回其本身的数据类型，函数对象返回 function ，其他对象均返回 Object null 返回 Object instanceof: 用来判断A 是否是 B的实例，表达式为 A instanceof B，返回一个Boolean类型的值 instanceof 检测的是原型,只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型 let a = []; a instanceof Array // true a instanceof Object // true 变量a 的 __proto__ 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，a 就是Object的实例.针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型 constructor: 当一个函数被定义时，JS引擎会为其添加prototype原型，然后再在 prototype上添加一个 constructor 属性，并让其指向该函数的引用 null和undefined是无效的对象，因此是不会有constructor存在的，这两种类型的数据需要通过其他方式来判断 函数的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor引用会丢失，constructor会默认为 Object function F() {}; var f = new F; f.constructor == F // true F.prototype = {a: 1} var f = new F f.constructor == F // false 在构造函数 F.prototype 没有被重写之前，构造函数 F 就是新创建的对象 f 的数据类型。当 F.prototype 被重写之后，原有的 constructor 引用丢失, 默认为 Object 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改 toString: Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(11) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call([]) ; // [object Array] 3. undefined 和 null 有什么区别 null表示\"没有对象\"，即该处不应该有值 典型用法： 作为函数的参数，表示该函数的参数不是对象 作为对象原型链的终点 undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义 典型用法： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值的属性，该属性的值为undefined 函数没有返回值时，默认返回undefined 详见： undefined和null的区别-阮一峰 4. 数组对象有哪些常用方法 修改器方法： pop(): 删除数组的最后一个元素，并返回这个元素 push()：在数组的末尾增加一个或多个元素，并返回数组的新长度 reverse(): 颠倒数组中元素的排列顺序 shift(): 删除数组的第一个元素，并返回这个元素 unshift(): 在数组的开头增加一个或多个元素，并返回数组的新长度 sort(): 对数组元素进行排序，并返回当前数组 splice(): 在任意的位置给数组添加或删除任意个元素 访问方法： concat(): 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组 join(): 连接所有数组元素组成一个字符串 slice(): 抽取当前数组中的一段元素组合成一个新数组 indeOf(): 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1 lastIndexOf(): 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1 迭代方法： forEach(): 为数组中的每个元素执行一次回调函数,最终返回 undefined every(): 如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false some(): 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false filter(): 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回 map(): 返回一个由回调函数的返回值组成的新数组 更多方法请参考 MDN 传送门 5. Js 有哪几种创建对象的方式 对象字面量 var obj = {} Object 构造函数 var obj = new Object() 工厂模式 function Person(name, age) { var o = new Object() o.name = name; o.age = age; o.say = function() { console.log(name) } return o } 缺点： 每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源 构造函数模式 function Person(name, age) { this.name = name this.age = age this.say = function() { console.log(name) } } var person = new Person('hello', 18) 构造函数模式隐试的在最后返回return this 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象,可以根据return this 的特性调用call或者apply指定this 原型模式 function Person() {} Person.prototype.name = 'hanmeimei'; Person.prototype.say = function() { alert(this.name); } Person.prototype.friends = ['lilei']; var person = new Person(); 实现了方法与属性的共享，可以动态添加对象的属性和方法。但是没有办法创建实例自己的属性和方法，也没有办法传递参数 构造函数和原型组合 function Person(name, age) { this.name = name this.age = age } Person.prototype.say = function() { console.log(this.name) } var person = new Person('hello') 还有好几种模式，感兴趣的小伙伴可以参考 红宝书，你们肯定知道的了！ 6. 怎么实现对对象的拷贝(浅拷贝与深拷贝) 浅拷贝 拷贝原对象引用 可以使用Array.prototype.slice()也可以完成对一个数组或者对象的浅拷贝 Object.assign()方法 深拷贝 最常用的方式就是 JSON.parse(JSON.stringify(目标对象)，缺点就是只能拷贝符合JSON数据标准类型的对象 7. 什么是闭包，为什么要用它 简单来说，闭包就是能够读取其他函数内部变量的函数 function Person() { var name = 'hello' function say () { console.log(name) } return say() } Person() // hello 由于 JavaScript 特殊的作用域，函数外部无法直接读取内部的变量，内部可以直接读取外部的变量，从而就产生了闭包的概念 用途： 最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中 注意点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 8. 介绍一下 JavaScript 原型，原型链，它们有何特点 首先明确一点，JavaScript是基于原型的 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针. 图解： 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象 原型对象默认拥有一个constructor属性，指向指向它的那个构造函数 每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象 那么什么是原型链： JavaScript中所有的对象都是由它的原型对象继承而来。而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链 所有原型链的终点都是Object函数的prototype属性。Objec.prototype指向的原型对象同样拥有原型，不过它的原型是null，而null则没有原型 9. JavaScript 如何实现继承 原型链继承 function Animal() {} Animal.prototype.name = 'cat' Animal.prototype.age = 1 Animal.prototype.say = function() {console.log('hello')} var cat = new Animal() cat.name // cat cat.age // 1 cat.say() // hello 最简单的继承实现方式，但是也有其缺点 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 要想为子类新增属性和方法，必须要在new语句之后执行，不能放到构造器中 构造继承 function Animal() { this.species = \"动物\" } function Cat(name, age) { Animal.call(this) this.name = name this.age = age } var cat = new Cat('豆豆', 2) cat.name // 豆豆 cat.age // 2 cat.species // 动物 使用call或apply方法，将父对象的构造函数绑定在子对象上. 组合继承 function Animal() { this.species = \"动物\" } function Cat(name){ Animal.call(this) this.name = name } Cat.prototype = new Animal() // 重写原型 Cat.prototype.constructor = Cat 如果没有Cat.prototype = new Animal()这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal.这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat extends 继承 ES6新增继承方式，Class 可以通过extends关键字实现继承 class Animal { } class Cat extends Animal { constructor() { super(); } } 使用 extends 实现继承，必须添加 super 关键字定义子类的 constructor，这里的super() 就相当于 Animal.prototype.constructor.call(this) 当然，还有很多种实现继承的方式，这里就不多说了。然后，再推荐一波 红宝书 10. new 操作符具体干了什么 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 11. 同步和异步的区别，怎么异步加载 JavaScript 同步模式 同步模式，又称阻塞模式。javascript 在默认情况下是会阻塞加载的。当前面的 javascript 请求没有处理和执行完时，会阻止浏览器的后续处理 异步模式 异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理 异步加载 JavaScript 动态添加 script 标签 defer async defer属性和async都是属于 script 标签上面的属性，两者都能实现 JavaScript 的异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到 html 加载完毕之后再执行 12. 跨域问题的产生，怎么解决它 由于浏览器的 同源策略，在出现 域名、端口、协议有一种不一致时，就会出现跨域，属于浏览器的一种安全限制。 解决跨域问题有很多种方式，常用的就是以下几种： jsonp 跨域：动态创建script，再请求一个带参网址实现跨域通信.缺点就是只能实现 get 一种请求 document.domain + iframe跨域：两个页面都通过js强制设置document.domain为基础主域，就实现了同域.但是仅限主域相同，子域不同的跨域应用场景 window.name + iframe（非同源可用） location.hash + iframe（非同源可用） 跨域资源共享（CORS）：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置 nginx反向代理接口跨域：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题 WebSocket协议跨域 window.postMessage WebSocket13. 对 this 的理解 在 JavaScript 中，研究 this 一般都是 this 的指向问题，核心就是 this 永远指向最终调用它的那个对象，除非改变 this 指向或者箭头函数那种特殊情况 function test() { console.log(this); } test() // window var obj = { foo: function () { console.log(this.bar) }, bar: 1 }; var foo = obj.foo; var bar = 2; obj.foo() // 1 foo() // 2 // 函数调用的环境不同，所得到的结果也是不一样的 14. apply()、call()和 bind() 是做什么的，它们有什么区别 相同点：三者都可以改变 this 的指向 不同点： apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组 var obj = { name : 'sss' } function func(firstName, lastName){ console.log(firstName + ' ' + this.name + ' ' + lastName); } func.apply(obj, ['A', 'B']); // A sss B call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组 var obj = { name: 'sss' } function func(firstName, lastName) { console.log(firstName + ' ' + this.name + ' ' + lastName); } func.call(obj, 'C', 'D'); // C sss D bind 接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数 var obj = { name: 'sss' } function func() { console.log(this.name); } var func1 = func.bind(null, 'xixi'); func1(); apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数 bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window bind 在传递参数的时候会将自己带过去的参数排在原函数参数之前 function func(a, b, c) { console.log(a, b, c); } var func1 = func.bind(this, 'xixi'); func1(1,2) // xixi 1 2 15. 什么是内存泄漏，哪些操作会造成内存泄漏 内存泄漏：是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束 可能造成内存泄漏的操作： 意外的全局变量 闭包 循环引用 被遗忘的定时器或者回调函数 你可能还需要知道 垃圾回收机制 此外，高程上面对垃圾回收机制的介绍也很全面，有兴趣的小伙伴可以看看 16. 什么是事件代理，它的原理是什么 事件代理：通俗来说就是将元素的事件委托给它的父级或者更外级元素处理 原理：利用事件冒泡机制实现的 优点：只需要将同类元素的事件委托给父级或者更外级的元素，不需要给所有元素都绑定事件，减少内存空间占用，提升性能; 动态新增的元素无需重新绑定事件 17. 对AMD和CMD的理解，它们有什么区别 AMD和CMD都是为了解决浏览器端模块化问题而产生的，AMD规范对应的库函数有 Require.js，CMD规范是在国内发展起来的，对应的库函数有Sea.js AMD和CMD最大的区别是对依赖模块的执行时机处理不同 1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 2、CMD推崇就近依赖，只有在用到某个模块的时候再去require 参考：AMD-中文版 CMD-规范 18. 对ES6的了解 ECMAScript 6.0 是 JavaScript 语言的下一代标准 新增的特性： 声明变量的方式 let const 变量解构赋值 字符串新增方法 includes() startsWith() endsWith() 等 数组新增方法 Array.from() Array.of() entries() keys() values() 等 对象简洁写法以及新增方法 Object.is() Object.assign() entries() keys() values()等 箭头函数、rest 参数、函数参数默认值等 新的数据结构： Set 和 Map Proxy Promise对象 async函数 await命令 Class类 Module 体系 模块的加载和输出方式 了解更多，参考 ES6入门-阮一峰 19. 箭头函数有什么特点 ES6 允许使用“箭头”（=>）定义函数 var f = v => v; // 等同于 var f = function (v) { return v; } 注意点： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 20. Promise 对象的了解 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大.所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果 --ES6入门-阮一峰 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 特点： 对象的状态不受外界影响 一旦状态改变，就不会再变，任何时候都可以得到这个结果 Promise 新建后就会立即执行 const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }) Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数 promise.then(function(value) { // success }, function(error) { // failure }) then 方法返回的是一个新的Promise实例 Promise.prototype.catch 用于指定发生错误时的回调函数,具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获 getJSON('/post/1.json').then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }); catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法 出去上述方法，Promise还有其他用法，小伙伴们可以在这里查看大佬写的文章 ES6入门-阮一峰 21. async 函数以及 awit 命令 async 函数是什么？一句话，它就是 Generator 函数的语法糖 了解Generator函数的小伙伴，这里 传送门 async 特点： async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数 async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误 async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到 function timeout(ms) { return new Promise((resolve) => { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } asyncPrint('hello world', 50); await 命令: await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值 async function f() { // 等同于 // return 123; return await 123; } f().then(v => console.log(v)) // 123 await 命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象.也就是说就算一个对象不是Promise对象，但是只要它有then这个方法， await 也会将它等同于Promise对象 使用注意点： await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中 多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发 await 命令只能用在 async 函数之中，如果用在普通函数，就会报错 了解更多，请点击 这里 22. export 与 export default有什么区别 export 与 export default 均可用于导出常量、函数、文件、模块等 在一个文件或模块中，export、import 可以有多个，export default 仅有一个 通过 export 方式导出，在导入时要加 { }，export default 则不需要 使用 export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名; export 加载的时候需要知道加载模块的变量名 export default 命令的本质是将后面的值，赋给 default 变量，所以可以直接将一个值写在 export default 之后 23. 前端性能优化 参见 雅虎14条前端性能优化 24. 对JS引擎执行机制的理解 首选明确两点： JavaScript 是单线程语言 JavaScript 的 Event Loop 是 JS 的执行机制, 也就是事件循环 console.log(1) setTimeout(function(){ console.log(2) },0) console.log(3) // 1 3 2 JavaScript 将任务分为同步任务和异步任务，执行机制就是先执行同步任务，将同步任务加入到主线程，遇到异步任务就先加入到 event table ，当所有的同步任务执行完毕，如果有可执行的异步任务，再将其加入到主线程中执行 视频详解，移步 这里 setTimeout(function(){console.log(1);},0); new Promise(function(resolve){ console.log(2); for(var i = 0; i 在异步任务中，定时器也属于特殊的存在。有人将其称之为 宏任务、微任务，定时器就属于宏任务的范畴。 参考 JS引擎的执行机制 25. 事件流 参考 [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://www.cnblogs.com/cangqinglang/p/8963557.html) 事件流分为两种，捕获事件流和冒泡事件流。 - 捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。 - 冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。 26. 事件循环event-loop[https://blog.csdn.net/qq_36150631/article/details/88787226] 概括 事件循环：从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到任务队列中排队。程序按照代码顺序执行完毕后，查询任务队列中是否有等待的任务。如果有，则按照次序从任务队列中把任务放到执行栈中执行。执行完毕后，再从任务队列中获取任务，再执行，不断重复。 　　由于主线程不断的重复读取任务、执行任务、再取任务、再执行。所以，这种机制被称为事件循环 线程 javascript是单线程的语言，也就是说，同一个时间只能做一件事 why? 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 排队 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着 var i, t = Date.now() for (i = 0; i 像上面这样，如果排队是因为计算量大，CPU忙不过来，倒也算了 但是，如果是网络请求就不合适。因为一个网络请求的资源什么时候返回是不可预知的，这种情况再排队等待就不明智了 同步和异步 【同步】 如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的 Math.sqrt(2); console.log('Hi'); 第一个函数返回时，就拿到了预期的返回值：2的平方根；第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串所以这两个函数都是同步的 【异步】 如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的 fs.readFile('foo.txt', 'utf8', function(err, data) { console.log(data); }); 在上面的代码中，我们希望通过fs.readFile函数读取文件foo.txt中的内容，并打印出来。但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间 所以，fs.readFile函数是异步的 　　正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择 异步详解 从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有执行异步操作、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分 　　一个异步过程通常是这样的：主线程发起一个异步请求，异步任务接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时异步操作开始执行；执行完成后通知主线程；主线程收到通知后，执行一定的动作(调用回调函数) 　　因此，一个异步过程包括两个要素：注册函数和回调函数，其中注册函数用来发起异步过程，回调函数用来处理结果 　　下面的代码中，其中的setTimeout就是异步过程的发起函数，fn是回调函数 setTimeout(fn, 1000); 有一个很重要的问题，如何才算是异步操作执行完成呢？对于不同类型的异步任务，操作完成的标准不同 【异步类型】 　　一般而言，异步任务有以下三种类型 　　1、普通事件，如click、resize等 　　2、资源加载，如load、error等 　　3、定时器，包括setInterval、setTimeout等 　　下面对这三种类型分别举例说明，下面代码中，鼠标点击div时，就代表任务执行完成了 div.onclick = () => { console.log('click') } 下面代码中，XHR对象的readyState值为4，即已经接收到全部响应数据了，代表任务执行完成 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ //实际操作 result.innerHTML += xhr.responseText; } } } 下面代码中，过1s后，代表任务执行完成 setTimeout(() => { console.log('timeout') },1000) 对于同步任务来说，按顺序执行即可；但是，对于异步任务，各任务执行的时间长短不同，执行完成的时间点也不同，主线程如何调控异步任务呢？这就用到了任务队列 任务队列 　　有些文章把任务队列称为消息队列，或者叫事件队列，总之是和异步任务相关的队列 　　可以确定的是，它是队列这种先入先出的数据结构，和排队是类似的，哪个异步操作完成的早，就排在前面。不论异步操作何时开始执行，只要异步操作执行完成，就可以到任务队列中排队 　　这样，主线程在空闲的时候，就可以从任务队列中获取任务并执行 　　任务队列中放的任务具体是什么东西？任务的具体结构当然跟具体的实现有关。但是为了简单起见，可以认为：任务就是注册异步任务时添加的回调函数 任务队列的宏任务和微任务 任务队列的宏任务和微任务JS异步还有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入event queue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数，如下图： 【事件】 　　为什么叫事件循环？而不叫任务循环或消息循环。究其原因是任务队列中的每条任务实际上都对应着一个事件 　　DOM操作对应的是DOM事件，资源加载操作对应的是加载事件，而定时器操作可以看做对应一个“时间到了”的事件 如图： 同步和异步任务分别进入不同的执行“场所”，同步进入主线程，异步进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，回去了Event Queue读取对应的函数，进入主线程。上述过程会不断重复，也就是常说的Event Loop（事件循环）。 Event-loop 是如何工作的？ 先看一个简单的示例： setTimeout(()=>{ console.log(\"setTimeout1\"); Promise.resolve().then(data => { console.log(222); }); }); setTimeout(()=>{ console.log(\"setTimeout2\"); }); Promise.resolve().then(data=>{ console.log(111); }); // qqqq 复制代码思考一下, 运行结果是什么？ 运行结果为: 111 setTimeout1 222 setTimeout2 复制代码我们来看一下为什么？ 我们来详细说明一下, JS引擎是如何执行这段代码的: 主线程上没有需要执行的代码 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)。 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在再下一次的事件循环中执行)。 首先检查微任务队列, 即 microtask队列，发现此队列不为空，执行第一个promise的then回调，输出 '111'。 此时microtask队列为空，进入下一个事件循环, 检查宏任务队列，发现有 setTimeout的回调函数，立即执行回调函数输出 'setTimeout1',检查microtask 队列，发现队列不为空，执行promise的then回调，输出'222'，microtask队列为空，进入下一个事件循环。 检查宏任务队列，发现有 setTimeout的回调函数, 立即执行回调函数输出'setTimeout2'。 再思考一下下面代码的执行顺序: console.log('script start'); setTimeout(function () { console.log('setTimeout---0'); }, 0); setTimeout(function () { console.log('setTimeout---200'); setTimeout(function () { console.log('inner-setTimeout---0'); }); Promise.resolve().then(function () { console.log('promise5'); }); }, 200); Promise.resolve().then(function () { console.log('promise1'); }).then(function () { console.log('promise2'); }); Promise.resolve().then(function () { console.log('promise3'); }); console.log('script end'); 复制代码思考一下, 运行结果是什么？ 运行结果为: script start script end promise1 promise3 promise2 setTimeout---0 setTimeout---200 promise5 inner-setTimeout---0 复制代码那么为什么？ 我们来详细说明一下, JS引擎是如何执行这段代码的: 首先顺序执行完主进程上的同步任务，第一句和最后一句的console.log 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)。 接着遇到setTimeout 200，它的作用是在 200ms 后将回调函数放到宏任务队列中(这个任务在再下一次的事件循环中执行)。 同步任务执行完之后，首先检查微任务队列, 即 microtask队列，发现此队列不为空，执行第一个promise的then回调，输出 'promise1'，然后执行第二个promise的then回调，输出'promise3'，由于第一个promise的.then()的返回依然是promise，所以第二个.then()会放到microtask队列继续执行，输出 'promise2'; 此时microtask队列为空，进入下一个事件循环, 检查宏任务队列，发现有 setTimeout的回调函数，立即执行回调函数输出 'setTimeout---0',检查microtask 队列，队列为空，进入下一次事件循环. 检查宏任务队列，发现有 setTimeout的回调函数, 立即执行回调函数输出'setTimeout---200'. 接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中，检查微任务队列，即 microtask 队列，发现此队列不为空，执行promise的then回调，输出'promise5'。 此时microtask队列为空，进入下一个事件循环，检查宏任务队列，发现有 setTimeout 的回调函数，立即执行回调函数输出，输出'inner-setTimeout---0'。代码执行结束. 为什么会需要event-loop? 因为 JavaScript 是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 最后有一点需要注意的是：本文介绍的是浏览器的Event-loop，因此在测试验证时，一定要使用浏览器环境进行测试验证，如果使用了node环境，那么结果不一定是如上所说。 1.forEach、for-in与for-of的区别 forEach介绍 objArr.forEach(function (value) { console.log(value); }); foreach 方法没办法使用 break 语句跳出循环，或者使用return从函数体内返回 for-in介绍 for-in循环设计之初，是给普通以字符串的值为key的对象使用的。而非数组。 所以： for(var index in objArr){ console.log(objArr[index]) } 以上代码会出现的问题： index 值 会是字符串（String）类型 循环不仅会遍历数组元素，还会遍历任意其他自定义添加的属性，如，objArr上面包含自定义属性，objArr.name，那这次循环中也会出现此name属性 某些情况下，上述代码会以随机顺序循环数组 for-of介绍 for(let value of objArr){ console.log(value) } 可以避免所有 for-in 循环的陷阱 不同于 forEach()，可以使用 break, continue 和 return for-of 循环不仅仅支持数组的遍历。同样适用于很多类似数组的对象 它也支持字符串的遍历 for-of 并不适用于处理原有的原生对象 for-of 遍历 Set var uniqueWords = new Set(words); for (var word of uniqueWords) { console.log(word); } for-of 遍历 Map for (var [key, value] of phoneBookMap) { console.log(key + \"'s phone number is: \" + value); } Map是键值对组成，需要用到 Es6新特性解构 for-of 遍历原生对象 // 输出对象自身可以枚举的值 for (var key of Object.keys(someObject)) { console.log(key + \": \" + someObject[key]); } 总结 for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法： for (var key of Object.keys(someObject)) { console.log(key + \": \" + someObject[key]); } 遍历map对象时适合用解构,例如; for (var [key, value] of phoneBookMap) { console.log(key + \"'s phone number is: \" + value); }new一个函数的过程 function Foo(){}; var f = new Foo(); 这个过程等同于function Foo(){} var f = new Object(); // 新建一个对象 f.proto = Foo.prototype;// 使该构造函数的隐式原形等于实例函数的显示原形 Foo.call(f); // 使用call方法调用函数并且指定上下文的'this' // 当调用Foo方法的时候，该方法的this值会绑定到f对象上。 说说你对AMD和Commonjs的理解? CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作，只能在node环境下使用。 AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 27. ES6中的class语法的实现？ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-10-30 00:16:57 "},"Javascript/interview/es6面试.html":{"url":"Javascript/interview/es6面试.html","title":"es6面试","keywords":"","body":" 1、es5和es6的区别，说一下你所知道的es6  2、var、let、const之间的区别  3、使用class 手写一个promise  4、理解 async/await以及对Generator的优势  5、forEach、for in、for of三者区别  6、promise和async await的区别 1、es5和es6的区别，说一下你所知道的es6 ECMAScript5，即ES5，是ECMAScript的第五次修订，于2009年完成标准化 ECMAScript6，即ES6，是ECMAScript的第六次修订，于2015年完成，也称ES2015 ES6是继ES5之后的一次改进，相对于ES5更加简洁，提高了开发效率 ES6新增的一些特性： 1）let声明变量和const声明常量，两个都有块级作用域 　　ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明 2）箭头函数 　　ES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义 3）模板字符串 　　模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串 4）解构赋值 　　ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值 5）for of循环 　　for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串 6）import、export导入导出 　　ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用 7）set数据结构 　　Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数 8）... 展开运算符 　　可以将数组或对象里面的值展开；还可以将多个值收集为一个变量 9）修饰器 @ 　　decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数 10）class 类的继承 　　ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念 11）async、await 　　使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 　　async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成 12）promise 　　Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大 13）Symbol 　　Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的 14）Proxy代理 　　使用代理（Proxy）监听对象的操作，然后可以做一些相应事情 2、var、let、const之间的区别 var声明变量可以重复声明，而let不可以重复声明 var是不受限于块级的，而let是受限于块级 var会与window相映射（会挂一个属性），而let不与window相映射 var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错 const声明之后必须赋值，否则会报错 const定义不可变的量，改变了就会报错 const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错 3、使用class 手写一个promise //创建一个Promise的类 class Promise{ constructor(executer){//构造函数constructor里面是个执行器 this.status = 'pending';//默认的状态 pending this.value = undefined//成功的值默认undefined this.reason = undefined//失败的值默认undefined //状态只有在pending时候才能改变 let resolveFn = value =>{ //判断只有等待时才能resolve成功 if(this.status == pending){ this.status = 'resolve'; this.value = value; } } //判断只有等待时才能reject失败 let rejectFn = reason =>{ if(this.status == pending){ this.status = 'reject'; this.reason = reason; } } try{ //把resolve和reject两个函数传给执行器executer executer(resolve,reject); }catch(e){ reject(e);//失败的话进catch } } then(onFufilled,onReject){ //如果状态成功调用onFufilled if(this.status = 'resolve'){ onFufilled(this.value); } //如果状态失败调用onReject if(this.status = 'reject'){ onReject(this.reason); } } } 4、理解 async/await以及对Generator的优势 　　 async await 是用来解决异步的，async函数是Generator函数的语法糖 　　使用关键字async来表示，在函数内部使用 await 来表示异步 　　async函数返回一个 Promise 对象，可以使用then方法添加回调函数 　　当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 　　async较Generator的优势： 　　（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 　　（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　 　　（3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值 　　（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用 5、forEach、for in、for of三者区别 forEach更多的用来遍历数组 for in 一般常用来遍历对象或json for of数组对象都可以遍历，遍历对象需要通过和Object.keys(),不同于 forEach()，可以使用 break, continue 和 return for in循环出的是key，for of循环出的是value 6、promise和async await的区别 首先说说两者的概念 Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的 async await async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。 两者的区别 Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。 async await与Promise一样，是非阻塞的。 async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。 简单来看，这两者除了语法糖不一样外，他们解决的问题、达到的效果是大同小异的，我们可以在不同的应用场景，根据自己的喜好来选择使用。 async 函数的实现原理 async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 async function fn(args) { // ... } // 等同于 function fn(args) { return spawn(function* () { // ... }); } 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 function spawn(genF) { return new Promise(function(resolve, reject) { const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); }); } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-21 00:20:00 "},"Javascript/interview/js综合基础题.html":{"url":"Javascript/interview/js综合基础题.html","title":"Javascript综合基础题","keywords":"","body":"1. (考察变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染) function Foo() { getName = function () { alert (1); }; return this; } Foo.getName = function () { alert (2);}; Foo.prototype.getName = function () { alert (3);}; var getName = function () { alert (4);}; function getName() { alert (5);} //请写出以下输出结果： Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName(); new new Foo().getName(); 第一问(Foo.getName()) 先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。 第一问的Foo.getName自然是访问Foo函数上存储的静态属性，答案自然是2，这里就不需要解释太多的，一般来说第一问对于稍微懂JS基础的同学来说应该是没问题的,当然我们可以用下面的代码来回顾一下基础，先加深一下了解 function User(name) { var name = name; //私有属性 this.name = name; //公有属性 function getName() { //私有方法 return name; } } User.prototype.getName = function() { //公有方法 return this.name; } User.name = 'Wscats'; //静态属性 User.getName = function() { //静态方法 return this.name; } var Wscat = new User('Wscats'); //实例化 注意下面这几点： 调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的 静态方法和静态属性就是我们无需实例化就可以调用 而对象的私有方法和属性,外部是不可以访问的 第二问getName(); 直接调用getName函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以这里应该直接把关注点放在4和5上，跟1 2 3都没什么关系。此处其实有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。 我们来看看为什么，可参考(1)关于Javascript的函数声明和函数表达式 (2)关于JavaScript的变量提升 在Javascript中，定义函数有两种类型 函数声明 // 函数声明 function wscat(type) { return type === \"wscat\"; } 函数表达式 // 函数表达式 var oaoafly = function(type) { return type === \"oaoafly\"; } 先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为getName的函数 getName() //oaoafly var getName = function() { console.log('wscat') } getName() //wscat function getName() { console.log('oaoafly') } getName() //wscat 上面的代码看起来很类似，感觉也没什么太大差别。但实际上，Javascript函数上的一个“陷阱”就体现在Javascript两种类型的函数定义上。 JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。 而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用 var getName //变量被提升，此时为undefined getName() //oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了 var getName = function() { console.log('wscat') } //函数表达式此时才开始覆盖函数声明的定义 getName() //wscat function getName() { console.log('oaoafly') } getName() //wscat 这里就执行了函数表达式的值 所以可以分解为这两个简单的问题来看清楚区别的本质 var getName; console.log(getName) //undefined getName() //Uncaught TypeError: getName is not a function var getName = function() { console.log('wscat') } var getName; console.log(getName) //function getName() {console.log('oaoafly')} getName() //oaoafly function getName() { console.log('oaoafly') } 第三问Foo().getName(); Foo().getName();先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。 Foo函数的第一句getName = function () { alert (1); };是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为function(){alert(1)}。 此处实际上是将外层作用域内的getName函数修改了。 注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。 之后Foo函数的返回值是this，而JS的this问题已经有非常多的文章介绍，这里不再多说。 简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this指向window对象。 遂Foo函数返回的是window对象，相当于执行window.getName()，而window中的getName已经被修改为alert(1)，所以最终会输出1 此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题 我们可以利用下面代码来回顾下这两个知识点 var name = \"Wscats\"; //全局变量 window.name = \"Wscats\"; //全局变量 function getName() { name = \"Oaoafly\"; //去掉var变成了全局变量 var privateName = \"Stacsw\"; return function() { console.log(this); //window return privateName } } var getPrivate = getName(\"Hello\"); //当然传参是局部变量，但函数里面我没有接受这个参数 console.log(name) //Oaoafly console.log(getPrivate()) //Stacsw 因为JS没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值的方法会直接或者间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取，函数还真的是第一公民呀~ 而关于this，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 所以第三问中实际上就是window在调用Foo()函数，所以this的指向是window window.Foo().getName(); //->window.getName(); 第四问getName(); 直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1，也就是说Foo执行后把全局的getName函数给重写了一次，所以结果就是Foo()执行重写的那个getName函数 第五问new Foo.getName(); 第五问new Foo.getName();此处考察的是JS的运算符优先级问题，我觉得这是这题灵魂的所在，也是难度比较大的一题 下面是JS运算符的优先级表格，从高到低排列。可参考MDN运算符优先级 优先级 运算类型 关联性 运算符 20 圆括号 n/a（不相关） ( … ) 19 成员访问 从左到右 … . … 需计算的成员访问 从左到右 … [ … ] new (带参数列表) n/a new … ( … ) 函数调用 从左到右 … ( … ) 可选链（Optional chaining） 从左到右 ?. 18 new (无参数列表) 从右到左 new … 17 后置递增(运算符在后) n/a … ++ 后置递减(运算符在后) n/a … -- 16 逻辑非 从右到左 ! … 按位非 从右到左 ~ … 一元加法 从右到左 + … 一元减法 从右到左 - … 前置递增 从右到左 ++ … 前置递减 从右到左 -- … typeof 从右到左 typeof … void 从右到左 void … delete 从右到左 delete … await 从右到左 await … 15 幂 从右到左 … ** … 14 乘法 从左到右 … * … 除法 从左到右 … / … 取模 从左到右 … % … 13 加法 从左到右 … + … 减法 从左到右 … - … 12 按位左移 从左到右 … 按位右移 从左到右 … >> … 无符号右移 从左到右 … >>> … 11 小于 从左到右 … 小于等于 从左到右 … 大于 从左到右 … > … 大于等于 从左到右 … >= … in 从左到右 … in … instanceof 从左到右 … instanceof … 10 等号 从左到右 … == … 非等号 从左到右 … != … 全等号 从左到右 … === … 非全等号 从左到右 … !== … 9 按位与 从左到右 … & … 8 按位异或 从左到右 … ^ … 7 按位或 从左到右 `… \\ …` 6 逻辑与 从左到右 … && … 5 逻辑或 从左到右 `… \\ \\ …` 4 条件运算符 从右到左 … ? … : … 3 赋值 从右到左 … = … … += … … -= … … *= … … /= … … %= … … … >>= … … >>>= … … &= … … ^= … `… = …` 2 yield 从右到左 yield … yield* 从右到左 yield* … 1 展开运算符 n/a ... … 0 逗号 从左到右 … , … 这题首先看优先级的第18和第17都出现关于new的优先级，new (带参数列表)比new (无参数列表)高比函数调用高，跟成员访问同级 new Foo.getName();的优先级是这样的 相当于是: new (Foo.getName)(); 点的优先级(18)比new无参数列表(17)优先级高 当点运算完后又因为有个括号()，此时就是变成new有参数列表(18)，所以直接执行new，当然也可能有朋友会有疑问为什么遇到()不函数调用再new呢，那是因为函数调用(17)比new有参数列表(18)优先级低 .成员访问(18)->new有参数列表(18) 所以这里实际上将getName函数作为了构造函数来执行，遂弹出2 第六问new Foo().getName(); 这一题比上一题的唯一区别就是在Foo那里多出了一个括号，这个有括号跟没括号我们在第五问的时候也看出来优先级是有区别的 (new Foo()).getName() 那这里又是怎么判断的呢？首先new有参数列表(18)跟点的优先级(18)是同级，同级的话按照从左向右的执行顺序，所以先执行new有参数列表(18)再执行点的优先级(18)，最后再函数调用(17) new有参数列表(18)->.成员访问(18)->()函数调用(17) 这里还有一个小知识点，Foo作为构造函数有返回值，所以这里需要说明下JS中的构造函数返回值问题。 构造函数的返回值 在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。 而在JS中构造函数可以有返回值也可以没有。 没有返回值则按照其他语言一样返回实例化对象 function Foo(name) { this.name = name } console.log(new Foo('wscats')) 若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。 function Foo(name) { this.name = name return 520 } console.log(new Foo('wscats')) 若返回值是引用类型，则实际返回值为这个引用类型。 function Foo(name) { this.name = name return { age: 16 } } console.log(new Foo('wscats')) 原题中，由于返回的是this，而this在构造函数中本来就代表当前实例化对象，最终Foo函数返回实例化对象。 之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，当前对象的原型对象(prototype)中寻找getName函数。 当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认会拿构造函数的公有方法而不是原型链，这个知识点在原题中没有表现出来，后面改进版我已经加上。 function Foo(name) { this.name = name this.getName = function() { return this.name } } Foo.prototype.name = 'Oaoafly'; Foo.prototype.getName = function() { return 'Oaoafly' } console.log((new Foo('Wscats')).name) //Wscats console.log((new Foo('Wscats')).getName()) //Wscats 第七问new new Foo().getName(); new new Foo().getName();同样是运算符优先级问题。做到这一题其实我已经觉得答案没那么重要了，关键只是考察面试者是否真的知道面试官在考察我们什么。 最终实际执行为: new ((new Foo()).getName)(); new有参数列表(18)->new有参数列表(18) 先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new，所以最终结果为3 答案 function Foo() { getName = function () { alert (1); }; return this; } Foo.getName = function () { alert (2);}; Foo.prototype.getName = function () { alert (3);}; var getName = function () { alert (4);}; function getName() { alert (5);} //答案： Foo.getName();//2 getName();//4 Foo().getName();//1 getName();//1 new Foo.getName();//2 new Foo().getName();//3 new new Foo().getName();//3 改变一下 function Foo() { this.getName = function() { console.log(3); return { getName: getName //这个就是第六问中涉及的构造函数的返回值问题 } }; //这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级 getName = function() { console.log(1); }; return this } Foo.getName = function() { console.log(2); }; Foo.prototype.getName = function() { console.log(6); }; var getName = function() { console.log(4); }; function getName() { console.log(5); } //答案： Foo.getName(); //2 getName(); //4 console.log(Foo()) Foo().getName(); //1 getName(); //1 new Foo.getName(); //2 new Foo().getName(); //3 //多了一问 new Foo().getName().getName(); //3 1 new new Foo().getName(); //3 async await async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\"); } async function async2() { console.log(\"async2\"); } async1(); console.log('start') 这道基础题输出的是啥？ 答案： 'async1 start' 'async2' 'start' 'async1 end' 过程分析： 首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置 发现async1函数被调用了，然后去看看调用的内容 执行函数中的同步代码async1 start，之后碰到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1 跳出async1函数后，执行同步代码start 在一轮宏任务全部执行完之后，再来执行刚刚await后面的内容async1 end。 在这里，你可以理解为「紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中」。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 13:09:13 "},"Javascript/基础1.1JavaScript声明变量详解.html":{"url":"Javascript/基础1.1JavaScript声明变量详解.html","title":"基础1.1JavaScript声明变量详解 ✔","keywords":"","body":"前言 如果文章中有出现纰漏、错误之处，还请看到的小伙伴多多指教，先行谢过 在ES5阶段，JavaScript 使用 var 和 function 来声明变量， ES6 中又添加了let、const、import、 Class 这几种声明变量的方式。那么，他们各自都有什么样的特点呢？ 下面，就让我们一起去探究一下吧 以下↓ 变量就是存储信息的容器。 ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据 var 声明 一直以来，我们都是使用 var 关键字来声明变量 var a = 1; var b; console.log(a) // 1 console.log(b) // undefined console.log(c) // undefined var b = 2; var c = 3; console.log(b) // 2 console.log(c) // 3 function f() { var c = 4; console.log(c) // 4 c = 5; console.log(c) // 5 } f(); console.log(c) // 3 function fun() { c = 6 } fun(); console.log(c) // 6 从上面的结果我们不难看出，使用var声明的变量具有以下特点： 变量可以没有初始值，会保存一个特殊的值 undefined 变量可以重复定义，且可以修改值 变量声明语句从自动提升到所在作用域的顶端 函数内重复定义对函数外无影响(局部变量) 函数内重新赋值对函数外有影响 function 关键字声明 在 ES5 中，除了使用 var 声明变量，我们也可以使用 function 关键字声明变量 f(); function f() {console.log(1)} var f; console.log(f) // function f 特点： 使用 function 声明的是函数对象，也存在声明提升 函数声明要优于变量声明 let声明 由于 ES5 中使用 var 声明变量存在着一些很让人迷惑的特性（比如变量提升，重复定义等），ES6 中新增 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在 let 命令所在的代码块内有效 { var a = 1; let b = 2; } console.log(a) // 1 console.log(b) // Uncaught ReferenceError: b is not defined console.log(c) // Uncaught ReferenceError: c is not defined let c = 3 let a = 4 console.log(a) // Identifier 'a' has already been declared 通过以上的代码，我们很容易发现使用 let 声明变量的特点： let 声明的变量只在它所在的代码块有效 不存在变量提升 不可以重复声明 由于 let 声明变量的这些特点，所以 for 循环的计数器，就很合适使用 let 命令 for(let i = 0; i let 实际上为 JavaScript 新增了块级作用域 const声明 const 也是 ES6 新增的声明变量的方式，const 声明一个只读的常量。一旦声明，常量的值就不能改变 const API; console.log(API) // SyntaxError: Missing initializer in const declaration console.log(MAX); // Uncaught ReferenceError: MAX is not defined const MAX = 1; const MAX = 2; console.log(MAX); // Identifier 'MAX' has already been declared const PI = 3.1415; console.log(PI) // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const f = {} f.name = 'HELLO' // 正常执行 f = {name: 'World'} // 报错 所以，使用 const 声明的变量具有以下特点： const 一旦声明变量，就必须立即初始化，不能留到以后赋值 不允许重复声明 不存在变量提升 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动 如果真的想将对象冻结，应该使用 Object.freeze 方法 import 声明 ES6 新增的模块的概念。 模块功能主要由两个命令构成：export 和 import。 export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能 所以在一定程度上来说，import 也具有声明变量的功能。只是在使用 import 的时候，具有一些限制 export { first, last } import { first, last } from './xxx' first = {} // Syntax Error : 'a' is read-only; first.name = 'Hello' // 成功执行，但是不建议这样使用 export default function(){} // a.js import xxx from 'a.js' import { New as $ } from './xxx' 特点： import 命令接受一对大括号，大括号里面的变量名，必须与被导入模块对外接口的名称相同 import 命令输入的变量都是只读的，因为它的本质是输入接口 当使用 export default 命令，为模块指定默认输出的时候，import 命令可以为该匿名函数指定任意名字 import 命令具有提升效果，会提升到整个模块的头部，首先执行 如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字 class 声明 ES6 引入了类的概念，有了 class 这个关键字，作为对象的模板。通过 class 关键字，可以定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，类的实质还是函数对象，类中的方法和对象其实都是挂在对应的函数对象的 prototype 属性下 所以就可以改写成下面这种ES5的方式 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function() { return '(' + this.x + ', ' + this.y + ')'; } 特点： 所有类都有 constructor 函数，如果没有显式定义，一个空的 constructor 方法会被默认添加。当然所有函数对象都必须有个主体 生成类的实例对象的写法，与 ES5 通过构造函数生成对象完全一样，也是使用 new 命令 class B {} let b = new B(); 在类的实例上面调用方法，其实就是调用原型上的方法 与函数对象一样，Class 也可以使用表达式的形式定义 Class 其实就是一个 function ，但是有一点不同，Class 不存在变量提升，也就是说 Class 声明定义必须在使用之前 全局变量 在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的 var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩 var a = 1; window.a // 1 let b = 2; window.b // undefined 隐式声明 在 JavaScript 中还存在着隐式声明。 a = 1; console.log(a) // 1 当没有声明，直接给变量赋值时，会隐式地给变量声明，此时这个变量作为全局变量存在。这个时候就不存在声明提前的问题了 最后 其实只要我们理解并掌握了这几种声明变量的方式，记住它们的特点，那么在实际使用的过程当中就很容易能够找到最合适的方式去定义 每天学习分享，不定期更新 最后，推荐一波前端学习历程，这段时间总结的一些面试相关，分享给有需要的小伙伴，欢迎 star 关注 传送门 参考文档 ECMAScript 6入门 ES6变量声明 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 18:31:53 "},"Javascript/基础1.2:变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链.html":{"url":"Javascript/基础1.2:变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链.html","title":"基础1.2:变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链 ✔","keywords":"","body":"基础1.1:变量（变量提升,暂时性死区）、执行环境、执行栈 一·变量提升 首先两个打印例子 a = 'ghostwu'; var a; console.log( a ); //ghostwu console.log( a ); var a = 'ghostwu'; //undefined why? 首先:明确两点 javascript代码并不是一行一行往下执行的. javascript执行分为2个步骤:1.编译(词法解释/预解释) 2.执行 其次:当我们碰到 var a = \"ghostwu\" 定义一个变量的时候， 其实js把这句话看成是2个阶段的事, var a 发生在==编译==阶段， a = 'ghostwu'发生在执行阶段. 然后 var a会被提升到当前作用域的最前面, a = 'ghostwu'留在原地==等待执行==阶段，所以： a = 'ghostwu'; var a; console.log( a ); // 上面这段代码经过编译之后，变成下面这样 var a; //被提升到当前作用域的最前面 a = 'ghostwu'; //留在原地，等待执行 console.log( a ); console.log( a ); var a = 'ghostwu'; //上面这段代码,经过编译之后，变成下面这样 var a; console.log( a ); a = 'ghostwu'; 明确函数定义的两种方式 //函数声明, 形如: function show(){ console.log( '函数声明方式' ); } //函数表达式, 形如: var show = function(){ console.log( '表达式方式' ); } 因为表达式和函数声明，在编译阶段，会产生不同的解释效果。 show(); //undefined function show(){ console.log( a ); var a = 'ghostwu'; } 函数声明会被提升 所以，上面的代码，经过编译之后，就变成了下面这样： function show(){ //函数声明被提升到 当前作用域的最前面 var a; //var声明被提升到当前作用域的最前面, 注意，它不会提升到函数的外面, 因为当前的作用域是在函数中 console.log( a ); a = 'ghostwu'; } show(); 函数表达式，是不会提升的, 看下面的例子: show(); //报错,show is not a function var show = function(){ console.log( 'ghostwu' ); } //对于上面这段表达式代码，经过编译之后: var show; show(); //执行之后就是 undefined, 所以在表达式定义之前，调用函数报错了 show = function(){ console.log( 'ghostwu' ); show(); //你好 var show; function show(){ console.log( '你好' ); } show = function(){ console.log( 'hello' ); } 上面的例子为什么是你好？ 因为： 当出现同名的函数声明，变量声明的时候， 函数声明会被优先提升，变量声明会被忽略。 所以经过编译之后，就变成: function show(){ console.log( '你好' ); } show(); //你好 show = function(){ console.log( 'hello' ); } show();//如果这里在调用一次，就是hello, 因为show函数体在执行阶段 被 重新赋值了 如果有同名的函数声明，后面的会覆盖前面的，如下: show(); //how are you var show; function show(){ console.log( 'hello' ); } show = function(){ console.log( '你好' ); } function show(){ console.log( 'how are you!' ); } //上面的代码经过编译之后，变成如下形式: function show(){ console.log( 'how are you!' ); } show(); //how are you show = function(){ console.log( '你好' ); } show(); //如果在这里再执行一次，结果：你好 暂时性死区 我们都知道，var声明的变量会有变量提升的作用，如下 console.log(a); //1 var a=1; console.log(b); //undefined var b; 可以看出，虽然代码中console调用a在前，声明a在后，但是由于在js中，函数及变量的声明都将被提升到函数的最顶部，也就是说（var声明的）变量可以先使用再声明。 然后，使用let，const（后面会提及）声明的变量却不存在变量提升。 console.log(foo); // Uncaught ReferenceError: foo is not defined let foo = 2; console.log(foo1); // Uncaught ReferenceError: foo1 is not defined let foo1; ES6明确规定，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let,const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 注：“暂时性死区”也意味着typeof不再是一个百分之百安全的操作，因为会使typeof报错。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let和 const的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 let不允许在相同作用域内，重复声明同一个变量。 if (true) { let aa; let aa; // Uncaught SyntaxError: Identifier 'aa' has already been declared } if (true) { var _aa; let _aa; // Uncaught SyntaxError: Identifier '_aa' has already been declared } if (true) { let aa_; var aa_; // Uncaught SyntaxError: Identifier 'aa_' has already been declared } 全局变量 vs 全局对象的属性 ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window/global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。 ES6 中做了严格的区分，使用 var 和 function 声明的全局变量依旧作为全局对象的属性，使用 let, const 命令声明的全局变量不属于全局对象的属性。 let let_test = 'test'; console.log(window.let_test); // undefined console.log(this.let_test); // undefined var var_test = 'test'; console.log(window.var_test); // test console.log(this.var_test); // test const 除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。使用const声明变量的时候，必须同时赋值，否则会报错。并且之后任何试图修改值的操作都会引起错误. const data; //Uncaught SyntaxError: Missing initializer in const declaration if (true) { var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常 ! b = 4; // Uncaught TypeError: Assignment to constant variable. } console.log( a ); // 3 console.log( b ); // Uncaught ReferenceError: b is not defined 注：复合类型const变量保存的是引用。因为复合类型的常量不指向数据，而是指向数据(heap)所在的地址(stack)，所以通过 const 声明的复合类型只能保证其地址引用不变，但不能保证其数据不变。 const arr= [1, 2]; // 修改数据而不修改引用地址，正确执行 arr.push(3); // [1, 2, 3] // 修改 arr 常量所保存的地址的值，报错 arr = []; // Uncaught TypeError: Assignment to constant variable. 简单的使用const无法完成对象的冻结。可以通过Object.freeze()方法实现对对象的冻结。使用Object.freeze()方法返回的对象将不能对其属性进行配置(definedProperty()不可用)同时不能添加新的属性和移除(remove)已有属性。彻底冻结对象时需要递归的对它的对象属性进行冻结。 let obj = { a: 1, b: { b1: 2 } }; obj.b.b1 = 3; console.log(obj.b.b1 ); //3 function freeze(obj){ Object.freeze(obj); Object.values(obj).forEach(function (value,index) { if(typeof value === 'object'){ freeze(value); } }) } freeze(obj); obj.b.b1 = 4; console.log(obj.b.b1); //3 二：执行环境 什么是js的\"执行环境\"？ 执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了各自的行为。每个执行环境中包含这三部分： 变量对象/活动对象 作用域链 this的值 当JavaScript代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。 执行环境的类型 执行环境总共有三种类型 1.全局执行环境：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 2.函数执行环境：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行环境。 3.Eval 函数执行环境： 指的是运行在 eval 函数中的代码，不用很少用而且不建议使用。 执行栈 用于存储在代码执行期间创建的所有执行环境。 JavaScript解释器在浏览器中是单线程的（下面再说进程和线程），这意味着浏览器在同一时间内只执行一个事件，对于其他的事件我们把它们排队在一个称为 执行栈的地方。下表是一个单线程栈的抽象视图。 当浏览器第一次加载你的script，它默认的进了全局执行环境。如果在你的全局代码中你调用了一个函数，那么顺序流就会进入到你调用的函数当中，创建一个新的执行环境并且把这个环境添加到执行栈的顶部。如果在当前的函数中调用了其他函数，同样的事会再次发生。执行流进入内部函数，并且创建一个新的执行环境，把它添加到已经存在的执行栈的顶部。浏览器始终执行当前在栈顶部的执行环境。一旦函数完成了当前的执行环境，它就会被弹出栈的顶部, 把控制权返回给当前执行环境的下个执行环境。下面例子展示了一个递归函数和该程序的执行栈： javascript (function foo(i) { if (i === 3) { return; } else { foo(++i); } }(0)); 这段代码简单地调用了自己三次，由1递增i的值。每次函数foo被调用，一个新的执行环境就会被调用。一旦一个环境完成了执行，它就会被弹出执行栈并且把控制权返回给当前执行环境的下个执行环境直到再次到达全局执行环境。 记住执行栈，有五个关键点 单线程 同步执行 一个全局环境 无限的函数环境 函数被调用就会创建一个新的执行环境，甚至调用自己。 执行环境的详情 一个函数被调用就会创建一个新的执行环境。然而解释器的内部，每次调用执行环境会有两个阶段： 创建阶段 当函数被调用，但是为执行内部代码之前: 创建一个作用域链。 创建变量，函数和参数。 确定this的值。 激活/代码执行阶段 赋值，引用函数，解释/执行代码。 这可能意味着每个执行环境在概念上作为一个对象并带有三个属性executionContextObj = { scopeChain: { /* variableObject + all parent execution context's variableObject */ }, //作用域链：{变量对象＋所有父执行环境的变量对象} variableObject: { /* function arguments / parameters, inner variable and function declarations */ }, //变量对象:{函数形参＋内部的变量＋函数声明(但不包含表达式)} this: {} } 活动／变量 对象(AO/VO) 当函数被调用，executionContextObj就被创建，该对象在实际函数执行前就已创建。这就是已知的第一个阶段创建阶段.在第一阶段，解释器创建了executionContextObj对象，通过扫描函数，传递形参，函数声明和局部变量声明。扫描的结果成为了变量对象在executionContextObj中。 这有一个解释器是如何评估代码的伪概述： 找到一些代码来调用函数 在执行函数代码前，创建执行环境 进入创建阶段： 初始化作用域链 创建变量对象: 创建arguments对象，检查环境中的参数，初始化名和值，创建一个参考副本 扫描环境中内的函数声明： 某个函数被发现，在变量对象创建一个属性，它是函数的确切名。它是一个指针在内存中，指向这个函数。 如果这个函数名已存在，这个指针的值将会重写。 扫描环境内的变量声明 某个变量声明被发现，在变量对象中创建一个属性，他是变量的名，初始化它的值为undefined。 如果变量名在变量对象中已存在，什么也不做，继续扫描。 在环境中确定this的值。 激活/代码执行阶段：在当前环境上运行/解释函数代码，并随着代码一行行执行指派变量的值 看下面例子： function foo(i) { var a = 'hello'; var b = function privateB() { }; function c() { } } foo(22); On calling foo(22), the creation stage looks as follows: 在调用foo(22)时，创建阶段像下面这样： fooExecutionContext = { scopeChain: { ... }, variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c() a: undefined, b: undefined }, this: { ... } } 正如你看到的，创建阶段处理了定义属性的名，但是并不把值赋给变量，不包括形参和实参。一旦创建阶段完成,执行流进入函数并且激活/代码执行阶段,在函数执行结束之后，看起来像这样： fooExecutionContext = { scopeChain: { ... }, variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c() a: 'hello', b: pointer to function privateB() }, this: { ... } } **进阶一言** 你可以在网上找到大量的术语来描述JavaScript进阶。解释变量和函数声明被提升到它们函数作用域的顶端。然而，没有一个详细的解释为什么这样， 现在你配备了关于解释器怎么创建活动对象的新知识，这会很明白这是为什么。看看下面例子： ​(function() { console.log(typeof foo); // function pointer console.log(typeof bar); // undefined var foo = 'hello', bar = function() { return 'world'; }; function foo() { return 'hello'; } }());​ ``` 现在我们能解答的问题有： 为什么在声明foo之前我们就可以调用? 如果我们按照创建阶段进行，我们知道变量在激活/执行阶段之前已经被创建了。因此，在函数流开始执行，foo已经在活动对象中被定义了。 foo被声明了两次, 为什么foo展现出来的是functiton，而不是undefined或者string 我们从创建阶段知道,尽管foo被声明了两次，函数在活动对象中是在变量之前被创建的，并且如果属性名在活动对象已经存在,我们会简单地绕过这个声明。 所以，引用函数foo（）是在活动对象上第一次被创建的， 当我们解释到 var foo的时候，我们发现属性名foo已经存在，所以代码不会做任何处理，只是继续进行 为什么bar是undefined？ bar确实是一个变量，并且值是一个函数。我们知道变量是在创建阶段被创建的，但是它们的值被初始化为undefined。 事件循环 可以看看这篇 事件循环机制： 上面讲了JS引擎线程会维护一个执行栈，执行栈中的所有任务从顶向下同步执行并出栈； 但当遇到一些需要异步执行的任务，如ajax、setTimeout等时，会立即返回函数，然后将异步操作交给浏览器内核中的其他模块处理（如timer、network、DOM Binding模块），接着主线程继续往下执行 栈中的任务。 当上面说的异步操作完成后如ajax接受完响应、setTimeout到达指定延时；这些任务 即回调函数会被放入到任务队列中。一般不同的异步任务的回调函数会放入不同的任务队列之中。（分为宏任务和微任务；优先执行微任务队列） 只有当执行栈为空时，执行引擎才会去看任务队列有无可执行的任务；如果有，就取一个放入到执行栈中执行。执行完后，执行栈为空，便又去检查任务队列。 不断地循环重复上述过程的机制，就是“事件循环(event loop)机制”。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-07 13:19:25 "},"Javascript/基础1.3：面向对象之理解对象.html":{"url":"Javascript/基础1.3：面向对象之理解对象.html","title":"基础1.3：面向对象之理解对象 ✔","keywords":"","body":"基础1.3：面向对象之理解对象 一.理解对象属性  1. 属性类型  2. 数据属性  3. 访问器属性 二.多个属性 三.读取属性的特性 理解对象属性 属性类型 首先理解特性与属性的关系? 特性是内部值，描述了属性的特征，ECMA-262第五版把特性放在两对方括号中 数据属性 包含一个数据值的位置，这个位置可以读取和写入值，数据属性有4个描述其行为的特性。 [[Configurable]] 能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为访问器属性。直接在对象上定义的属性默认为true。 [[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。 [[Writeable]] 能否修改属性的值 直接在对象上定义的属性默认为true。 [[Value]] 包含这个属性的数据值，这个特性默认为undefined。 Object.defineProperty()方法 要修改这四个，默认属性必须使用这个方法 这个方法接受三个参数（\"属性所在的对象\"，\"属性的名字\"，描述符对象），其中描述符对象属性必须是上面四个的一个或多个。可以修改对应的特性值。 访问器属性 它不包含数据值，包含getter和setter(这两个 不是必须的)，在读取访问器属性时会调用getter函数，在写入访问器属性时会调用setter函数并传入新值，负责处理数据。 [[Configurable]] 能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为数据属性。直接在对象上定义的属性默认为true。 [[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。 [[Get]] 读取属性时调用的函数，默认undefined。 [[Value]] 设置属性时调用的函数，默认undefined。var book = { _year: 2004, edition: 1 }; Object.defineProperty(book, \"year\", { get: function(){ return this._year; }, set: function(newValue){ if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } }); book.year = 2005; alert(book.edition); //2 以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition._year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此， 把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方 式，即设置一个属性的值会导致其他属性发生变化。 多个属性 Object.defineProperties()方法 。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应。例如： var book = {}; Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 }, year: { get: function(){ return this._year; }, set: function(newValue){ if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); 以上代码在 book对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。 最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。 支持 Object.defineProperties()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 读取属性的特性 Object.getOwnPropertyDescriptor() 可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value。例如： var book = {}; Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 }, year: { get: function(){ return this._year; }, set: function(newValue){ if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\"); alert(descriptor.value); //2004 alert(descriptor.configurable); //false alert(typeof descriptor.get); //\"undefined\" var descriptor = Object.getOwnPropertyDescriptor(book, \"year\"); alert(descriptor.value); //undefined alert(descriptor.enumerable); //false alert(typeof descriptor.get); //\"function\" 对于数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined。 对于访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter 函数的指针。 在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor()方法。支持这个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 总结：本节应该知道以下三点： 属性类型。 定义多个属性 读取属性特性 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-15 22:45:37 "},"Javascript/基础1.4：面向对象之创建对象的八种模式.html":{"url":"Javascript/基础1.4：面向对象之创建对象的八种模式.html","title":"基础1.4：面向对象之创建对象的八种模式 ✔","keywords":"","body":"创建对象八种模式 1.工厂模式 2.构造函数模式 3.原型模式 4.组合使用构造函数模式和原型模式(最佳) 5.动态原型模式 6.寄生构造函数模式（和工厂模式差不多） 7.稳妥构造函数模式（遵循与寄生构造函数类似的模式） 8.class的extend 工厂模式 1.工厂模式 考虑到在 ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示： 　　function createPerson(name,age,job){ 　　　　var o = new Object(); 　　　　o.name = name; 　　　　o.age = age; 　　　　o.job = job; 　　　　o.sayName = function(){ 　　　　　　alert(this.name); 　　　　} 　　　　return o; 　　} 　　var person1 = createPerson('Grey',27,'Doctor'); 函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建\\多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型？）。 什么是对象类型？ JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。 1 内部对象 js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。 其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。 2 宿主对象 宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度。 浏览器对象有很多，如Window和Document等等。 3 自定义对象 顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充。 优点：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 缺点：工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例. 构造函数模式 二.构造函数模式 function Person(name,age,job){ 　　　　this.name = name; 　　　　this.age = age; 　　　　this.job = job; 　　　　this.sayName = function(){ 　　　　　　alert(this.name); 　　　　} 　　} 　　var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); 　　var person2 = new Person('Grey',27,'Doctor'); 不同： 1 没有显式地创建对象 2 直接将属性和方法赋给了 this 对象 3 没有 return 语句 经历的步骤 (1) 创建一个新对象； (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； (3) 执行构造函数中的代码（为这个新对象添加属性）； (4) 返回新对象。 person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person，如下所示。 alert(person1.constructor == Person); //true alert(person2.constructor == Person); //true 对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person的实例，这一点通过 instanceof 操作符可以得到验证。 alert(person1 instanceof Object); //true alert(person1 instanceof Person); //true alert(person2 instanceof Object); //true alert(person2 instanceof Person); //true 优点：实例标识为一种特定的类型，即知道person1（person2）是Person对象的实例 弊端：也就是说相同的Person实例都有不同Function的实例，造成作用域链和标识符解析不同。如： alert(person1.sayName == person2.sayName); //false 三.原型模式 prototype（原型）属性：我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); person1.sayName(); //\"Nicholas\" var person2 = new Person(); person2.sayName(); //\"Nicholas\" alert(person1.sayName == person2.sayName); //true 与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，必须先理解 ECMAScript 中原型对象的性质。 1. 理解原型对象? 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从 Object继承而来的。m 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。 虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 isPrototypeOf(): 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之 间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象 （Person.prototype），那么这个方法就返回 true，如下所示： alert(Person.prototype.isPrototypeOf(person1)); //true alert(Person.prototype.isPrototypeOf(person2)); //true ES5:Object.getPrototypeOf() ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如： alert(Object.getPrototypeOf(person1) == Person.prototype); //true alert(Object.getPrototypeOf(person1).name); //\"Nicholas\" 这里的第一行代码只是确定 Object.getPrototypeOf()返回的对象实际就是这个对象的原型。 第二行代码取得了原型对象中 name 属性的值，也就是\"Nicholas\"。使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型 查找对象属性的过程 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值.这正是多个对象实例共享原型所保存的属性和方法的基本原理。 注意：前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问 前面的构造函数模式说person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person 问题这个constructor属性到底是在实例中还是在构造函数中？ 尝试解答 alert(person1.hasOwnProperty(\"constructor\")); //false 以上说明person1的constructor（构造函数）属性不是实例属性 （1）.通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值（2）.如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。（3）.修改后的例子中，我们使用 delete 操作符删除了 person1.name，之前它保存的\"Greg\" 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.name = \"Greg\"; alert(person1.name); //\"Greg\"——来自实例 alert(person2.name); //\"Nicholas\"——来自原型 delete person1.name; alert(person1.name); //\"Nicholas\"——来自原型 hasOwnProperty()方法 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); alert(person1.hasOwnProperty(\"name\")); //false person1.name = \"Greg\"; alert(person1.name); //\"Greg\"——来自实例 alert(person1.hasOwnProperty(\"name\")); //true alert(person2.name); //\"Nicholas\"——来自原型 alert(person2.hasOwnProperty(\"name\")); //false delete person1.name; alert(person1.name); //\"Nicholas\"——来自原型 alert(person1.hasOwnProperty(\"name\")); //false ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属 性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。 2. 原型与 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在通 过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。看一看下面的例子。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); alert(person1.hasOwnProperty(\"name\")); //false alert(\"name\" in person1); //true person1.name = \"Greg\"; alert(person1.name); //\"Greg\" ——来自实例 alert(person1.hasOwnProperty(\"name\")); //true alert(\"name\" in person1); //true alert(person2.name); //\"Nicholas\" ——来自原型 alert(person2.hasOwnProperty(\"name\")); //false alert(\"name\" in person2); //true delete person1.name; alert(person1.name); //\"Nicholas\" ——来自原型 alert(person1.hasOwnProperty(\"name\")); //false alert(\"name\" in person1); //true 无论该属性存在于实例中还是存在于原型中。 同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于 原型中，如下所示。 function hasPrototypeProperty(object, name){ return !object.hasOwnProperty(name) && (name in object); } 由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于 实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确 定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty()的用法。 function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var person = new Person(); alert(hasPrototypeProperty(person, \"name\")); //true person.name = \"Greg\"; alert(hasPrototypeProperty(person, \"name\")); //false 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中 既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了(重写或其他)原型中不可枚举属性（即将 [[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所 有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。 IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。 例如： var o = { toString : function(){ return \"My Object\"; } }; for (var prop in o){ if (prop == \"toString\"){ alert(\"Found toString\"); //在 IE 中不会显示 } } 这里的对象 o 定义了 一个名为 toString()的方法，该方法屏蔽了原型中（不可枚举）的 toString()方法。在 IE 中，由 于其实现认为原型的 toString()方法被打上了值为 false 的[[Enumerable]]标记，因此应该跳过 该属性，结果我们就不会看到警告框。该 bug 会影响默认不可枚举的所有属性和方法，包括： hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和 valueOf()。 ECMAScript 5 也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不 是所有浏览器都照此实现。 Object.keys() 这个方法可以取得对象上所有可枚举的实例属性， 接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如： function Person(){ } Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){ alert(this.name); }; var keys = Object.keys(Person.prototype); alert(keys); //\"name,age,job,sayName\" var p1 = new Person(); p1.name = \"Rob\"; p1.age = 31; var p1keys = Object.keys(p1); alert(p1keys); //\"name,age 变量 keys 中将保存一个数组，数组中是字符串\"name\"、\"age\"、\"job\"和\"sayName\"。这 个顺序也是它们在 for-in 循环中出现的顺序。如果是通过 Person 的实例调用，则 Object.keys() 返回的数组只包含\"name\"和\"age\"这两个实例属性。 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。 var keys = Object.getOwnPropertyNames(Person.prototype); alert(keys); //\"constructor,name,age,job,sayName\" 注意结果中包含了不可枚举的 constructor 属性。Object.keys()和 Object.getOwnProperty￾Names()方法都可以用来替代 for-in 循环。支持这两个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 3. 更简单的原型语法 每添加一个属性和方法就要敲一遍 Person.prototype。为减少 不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的 对象字面量来重写整个原型对象，如下面的例子所示。 function Person(){ } Person.prototype = { name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () { alert(this.name); } }; 将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。 最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一 个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在 这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新 对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了，如下所示。 var friend = new Person(); alert(friend instanceof Object); //true alert(friend instanceof Person); //true alert(friend.constructor == Person); //false alert(friend.constructor == Object); //true 解决方法： 在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则 等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设 置回适当的值。 function Person(){ } Person.prototype = { constructor : Person, name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () { alert(this.name); } }; 又有个问题： 以上代码特意包含了一个 constructor 属性，并将它的值设置为 Person，从而确保了通过该属 性能够访问到适当的值。 注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。默认 情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引 擎，可以试一试 Object.defineProperty()。 function Person(){ } Person.prototype = { name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () { alert(this.name); } }; //重设构造函数，只适用于 ECMAScript 5 兼容的浏览器 Object.defineProperty(Person.prototype, \"constructor\", { enumerable: false, value: Person }); 4. 原型的动态性 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。 var friend = new Person(); Person.prototype.sayHi = function(){ alert(\"hi\"); }; friend.sayHi(); //\"hi\"（没有问题！） 以上代码先创建了 Person 的一个实例，并将其保存在 person 中。然后，下一条语句在 Person. prototype 中添加了一个方法 sayHi()。即使 person 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi() 时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存 在那里的函数。 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重 写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。 function Person(){ } var friend = new Person(); Person.prototype = { constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () { alert(this.name); } }; friend.sayName(); //error 在这个例子中，我们先创建了 Person 的一个实例，然后又重写了其原型对象。然后在调用 friend.sayName()时发生了错误，因为 friend 指向的原型中不包含以该名字命名的属性。图 6-3 展示了这个过程的内幕。 从图 6-3 可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它 们引用的仍然是最初的原型。 5. 原生对象的原型 原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式 创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。 例如，在 Array.prototype 中可以找到 sort()方法，而在 String.prototype 中可以找到 substring()方法，如下所示。 alert(typeof Array.prototype.sort); //\"function\" alert(typeof String.prototype.substring); //\"function\" 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自 定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型 String 添加了一个名为 startsWith()的方法。 String.prototype.startsWith = function (text) { return this.indexOf(text) == 0; }; var msg = \"Hello world!\"; alert(msg.startsWith(\"Hello\")); //true 这里新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。既然方法被 添加给了 String.prototype，那么当前环境中的所有字符串就都可以调用它。由于 msg 是字符串， 而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。 缺点6. 原型对象的问题 原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。 function Person(){ } Person.prototype = { constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", friends : [\"Shelby\", \"Court\"], sayName : function () { alert(this.name); } }; var person1 = new Person(); var person2 = new Person(); person1.friends.push(\"Van\"); alert(person1.friends); //\"Shelby,Court,Van\" alert(person2.friends); //\"Shelby,Court,Van\" alert(person1.friends === person2.friends); //true 假如我们的初衷就是像这样 在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部 属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。 四.组合使用构造函数模式和原型模式 组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。下面的代码重写了前面的例子。 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; } Person.prototype = { constructor : Person, sayName : function(){ alert(this.name); } } var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); var person2 = new Person(\"Greg\", 27, \"Doctor\"); person1.friends.push(\"Van\"); alert(person1.friends); //\"Shelby,Count,Van\" alert(person2.friends); //\"Shelby,Count\" alert(person1.friends === person2.friends); //false alert(person1.sayName === person2.sayName); //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组。 这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自 定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 五. 动态原型模式 有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原 型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数 中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。 function Person(name, age, job){ //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\"){ Person.prototype.sayName = function(){ alert(this.name); }; } } var friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); 注意构造函数代码中加粗的部分。这里只在 sayName()方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可 以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆 if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使 用 instanceof 操作符确定它的类型。 使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果 在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 六.寄生构造函数模式（和工厂模式差不多） 通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式 的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但 从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。 function Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); //\"Nicholas\" 在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返 回了这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实 是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。 这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。 function SpecialArray(){ //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments); //添加方法 values.toPipedString = function(){ return this.join(\"|\"); }; //返回数组 return values; } var colors = new SpecialArray(\"red\", \"blue\", \"green\"); alert(colors.toPipedString()); //\"red|blue|green\" 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。 七.稳妥构造函数模式（遵循与寄生构造函数类似的模式） 道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这 个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在 一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的 实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面 的 Person 构造函数重写如下。 function Person(name, age, job){ //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function(){ alert(name); }; //返回对象 return o; } 注意，在以这种模式创建的对象中，除了使用 sayName()方法之外，没有其他办法访问 name 的值。可以像下面使用稳妥的 Person 构造函数。 var friend = Person(\"Nicholas\", 29, \"Software Engineer\"); friend.sayName(); //\"Nicholas\" 这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName()方法外，没有别的方式可 以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传 入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环 境——例如，ADsafe（www.adsafe.org）和 Caja（http://code.google.com/p/google-caja/）提供的环境—— 下使用。 与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也 没有什么关系，因此 instanceof 操作符对这种对象也没有意义。 八.ES6类继承extends extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。 class Rectangle { // constructor constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea() } // Method calcArea() { return this.height * this.width; } } const rectangle = new Rectangle(10, 20); console.log(rectangle.area); // 输出 200 // 继承 class Square extends Rectangle { constructor(length) { super(length, length); // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 this.name = 'Square'; } get area() { return this.height * this.width; } } const square = new Square(10); console.log(square.area); // 输出 100 extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样 function _inherits(subType, superType) { // 创建对象，创建父类原型的一个副本 // 增强对象，弥补因重写原型而失去的默认的constructor 属性 // 指定对象，将新创建的对象赋值给子类的原型 subType.prototype = Object.create(superType && superType.prototype, { constructor: { value: subType, enumerable: false, writable: true, configurable: true } }); if (superType) { Object.setPrototypeOf ? Object.setPrototypeOf(subType, superType) : subType.__proto__ = superType; } } 1. 函数声明和类声明的区别 函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。 let p = new Rectangle(); // ReferenceError class Rectangle {} 2. ES5继承和ES6继承的区别 ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）. ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-15 23:10:03 "},"Javascript/基础1.5：面向对象之继承的的八种方式.html":{"url":"Javascript/基础1.5：面向对象之继承的的八种方式.html","title":"基础1.5：面向对象之继承的的八种方式 ✔","keywords":"","body":" title: 基础1.5.：面向对象之继承的的八种方式 categories: \"基础1.5.：面向对象之继承的的八种方式\" tags: JavaScript 基础 八种方式： 1 .原型链继承 2 .借用构造函数继承 3 .组合继承 4 .原型式继承 5 .寄生式继承 6 .寄生组合式继承(最佳方式) 7 .混入方式继承多个对象 8 .ES6类继承extends 一.原型链继承 基本思想： 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1.1构造函数、原型和实例的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。我们让原型对象等于另一个类型的实例,此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进,就构成了实例与原型的链条。这就是所谓原型链的基本概念。 function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function (){ return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); //true 1.2搜索机制 上一节中说到，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在 通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用 instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype； 3）搜索supertype.prototype, 1.3确定原型和实例的关系两种方式 alert(instance instanceof Object); //true alert(instance instanceof SuperType); //true alert(instance instanceof SubType); //true 由于原型链的关系，我们可以说 instance 是 Object、SuperType 或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了 true。 第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。 alert(Object.prototype.isPrototypeOf(instance)); //true alert(SuperType.prototype.isPrototypeOf(instance)); //true alert(SubType.prototype.isPrototypeOf(instance)); //true 1.4 谨慎地定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎 样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。 function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承了 SuperType SubType.prototype = new SuperType(); //添加新方法 SubType.prototype.getSubValue = function (){ return this.subproperty; }; //重写超类型中的方法 SubType.prototype.getSuperValue = function (){ return false; }; var instance = new SubType(); alert(instance.getSuperValue()); //false 1.5 缺点(主要两方面) 最主要的问题来自包含引 用类型值的原型。上一节说过包含引用类型值的原型属性会被所有实例共享；而 这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。function SuperType(){ this.colors = [\"red\", \"blue\", \"green\"]; } function SubType(){ } //继承了 SuperType SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green,black\" 当 SubType 通过原型链继承了 SuperType 之后，SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自 己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么 呢？结果是 SubType 的所有实例都会共享这一个 colors 属性。 第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上， 应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上 前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 二.借用构造函数 解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数,即在子类型构造函数的内部调用超类型构造函数。因为，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和call()方法也可以在（将来）新创建的对象上执行构造函数 function SuperType(){ this.colors = [\"red\", \"blue\", \"green\"]; } function SubType(){ //继承了 SuperType SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green\" 新创建的 SubType 实例的环境下调用了 SuperType 构造函数。 这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。 2.1. 传递参数 相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。 function SuperType(name){ this.name = name; } function SubType(){ //继承了 SuperType，同时还传递了参数 SuperType.call(this, \"Nicholas\"); //实例属性 this.age = 29; } var instance = new SubType(); alert(instance.name); //\"Nicholas\"; alert(instance.age); //29 以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造 函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。 2.2. 缺点 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现复用，每个子类都有父类实例函数的副本，影响性能 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 三 组合继承 是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ //继承属性 // 第二次调用SuperType() SuperType.call(this, name); this.age = age; } // 继承方法 // 构建原型链 // 第一次调用SuperType() SubType.prototype = new SuperType(); // 重写SubType.prototype的constructor属性，指向自己的构造函数SubType SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){ alert(this.age); }; var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" instance1.sayName(); //\"Nicholas\"; instance1.sayAge(); //29 var instance2 = new SubType(\"Greg\", 27); alert(instance2.colors); //\"red,blue,green\" instance2.sayName(); //\"Greg\"; instance2.sayAge(); //27 缺点： 第一次调用SuperType()：给SubType.prototype写入两个属性name，color。 第二次调用SuperType()：给instance1写入两个属性name，color。 实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 四 原型式继承 是借助原型可以基于已有的对象创建新对象 function object(o){ function F(){} F.prototype = o; return new F(); } 在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。 var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = object(person); anotherPerson.name = \"Greg\"; anotherPerson.friends.push(\"Rob\"); var yetAnotherPerson = object(person); yetAnotherPerson.name = \"Linda\"; yetAnotherPerson.friends.push(\"Barbie\"); alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" 这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到 object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends 不仅属于 person 所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。es5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。 var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = Object.create(person); anotherPerson.name = \"Greg\"; anotherPerson.friends.push(\"Rob\"); var yetAnotherPerson = Object.create(person); yetAnotherPerson.name = \"Linda\"; yetAnotherPerson.friends.push(\"Barbie\"); alert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\" Object.create()方法的第二个参数与Object.defineProperties()(理解对象的定义多个属性)方法的第二个参数格式相 同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属 性。例如： var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = Object.create(person, { name: { value: \"Greg\" } }); alert(anotherPerson.name); //\"Greg\" 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的 缺点： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数五 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 function createAnother(original){ var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function(){ //以某种方式来增强这个对象 alert(\"hi\"); }; return clone; //返回这个对象 } var person = { name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"] }; var anotherPerson = createAnother(person); anotherPerson.sayHi(); //\"hi\" 这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。 缺点（同原型式继承）： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数六 寄生组合式继承 结合借用构造函数传递参数和寄生模式实现继承 背景 前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; function SubType(name, age){ SuperType.call(this, name); //第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); //第一次调用 SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){ alert(this.age); }; 加粗字体的行中是调用 SuperType 构造函数的代码。在第一次调用 SuperType 构造函数时， SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过 现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这 一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属 性。图 6-6 展示了上述过程。 有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。（上面有图说明这就是调 用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型。寄生组合式继承的基本模式如下所示。 function inheritPrototype(subType, superType){ var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本 prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性 subType.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型 } // 父类初始化实例属性和原型属性 function SuperType(name){ this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function(){ alert(this.name); }; // 借用构造函数传递增强子类实例属性（支持传参和避免篡改） function SubType(name, age){ SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); // 新增子类原型属性 SubType.prototype.sayAge = function(){ alert(this.age); } var instance1 = new SubType(\"xyc\", 23); var instance2 = new SubType(\"lxy\", 23); instance1.colors.push(\"2\"); // [\"red\", \"blue\", \"green\", \"2\"] instance1.colors.push(\"3\"); // [\"red\", \"blue\", \"green\", \"3\"] 这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf() 简单写法容易看懂 function Person (name, age) { this.name = name, this.age = age } Person.prototype.setAge = function () { console.log(\"111\") } function Student (name, age, price) { Person.call(this, name, age) this.price = price this.setScore = function () { } } Student.prototype = Object.create(Person.prototype)//核心代码 Student.prototype.constructor = Student//核心代码 var s1 = new Student('Tom', 20, 15000) console.log(s1 instanceof Student, s1 instanceof Person) // true true console.log(s1.constructor) //Student console.log(s1) 这是最成熟的方法，也是现在库实现的方法 七 混入方式继承多个对象 function MyClass() { SuperClass.call(this); OtherSuperClass.call(this); } // 继承一个类 MyClass.prototype = Object.create(SuperClass.prototype); // 混合其它 Object.assign(MyClass.prototype, OtherSuperClass.prototype); // 重新指定constructor MyClass.prototype.constructor = MyClass; MyClass.prototype.myMethod = function() { // do something }; Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。 八、ES6类继承extends 本质仍然是构造函数+原型链的组合式继承。 class A { constructor(name, age) { this.name = name; this.age = age; } getName() { return this.name; } } class B extends A { constructor(name, age) { super(name, age); this.job = \"IT\"; } getJob() { return this.job; } getNameAndJob() { return super.getName() + this.job; } } var b = new B(\"Tom\", 20); console.log(b.name); console.log(b.age); console.log(b.getName()); console.log(b.getJob()); console.log(b.getNameAndJob()); //输出：Tom，20，Tom，IT，TomIT extends关键字 上面代码定义了一个B类（class），该类通过extends关键字，继承了A类的所有属性和方法。A类中的所有方法默认是添加到B的原型上，所以extends继承的实质仍然是原型链。 console.log(\"constructor\" in b); console.log(\"getName\" in b); console.log(b.hasOwnProperty(\"getName\")); console.log(b.hasOwnProperty(\"constructor\")); //输出：true，true，false，false super关键字 super这个关键字，既可以当作函数使用，也可以当作对象使用。当作函数使用时，super代表父类的构造函数，并在子类中执行Parent.apply(this)，从而将父类实例对象的属性和方法，添加到子类的this上面。以下三点需要特别注意： 1、子类必须在constructor方法中调用super方法，如果子类没有定义constructor方法，constructor方法以及其内部的super方法会被默认添加。 class A { constructor(name, age) { this.name = name; this.age = age; } getName() { return this.name; } } class B extends A {} var b = new B(\"Tom\", 20); console.log(b.name); console.log(b.age); console.log(b.getName()); console.log(b.hasOwnProperty(\"name\")); //输出：Tom，20，Tom，true 2、在子类的constructor方法中，只有调用super之后，才可以使用this关键字，否则会报错。 class A { constructor(name, age) { this.name = name; this.age = age; } } class B extends A { constructor(name, age) { this.job = \"IT\"; super(name, age); } } var b = new B(\"Tom\", 20) //输出：报错 3、super()只能用在子类的constructor方法之中，用在其他地方就会报错。 测试代码： class A { constructor(name, age) { this.name = name; this.age = age; } } class B extends A { toStr(name, age) { super(name, age) } } var b = new B(\"Tom\", 20) //输出：报错 super作为对象时，在子类中指向父类的原型对象。 class A { constructor(name, age) { this.name = name; this.age = age; } getName() { console.log(this.name); } } A.prototype.n = 2; class B extends A { constructor(name, age) { super(name, age); } toStr() { return super.n; } activeGetName() { super.getName(); } } var b = new B(\"Tom\", 20); console.log(b.toStr()); console.log(b.activeGetName()); //输出：2，Tom 静态方法的继承 在一个方法前加上关键字static，就表示该方法不会被实例继承，但是父类的静态方法，会被子类继承。 例子： class A { static say() { console.log(\"hello\"); } } class B extends A {} console.log(B.say()); //输出：hello 也可以使用super在子类的静态方法中调用父类的静态方法。super在静态方法中指向父类本身，而不是父类的原型对象。 class A { static say() { console.log(\"hello\"); } } class B extends A { static toStr() { super.say(); } } var b = new B(); console.log(B.toStr()); //输出：hello 也可以使用super在子类的静态方法中调用父类的静态方法。super在静态方法中指向父类本身，而不是父类的原型对象。 class A { static say() { console.log(\"hello\"); } } class B extends A { static toStr() { super.say(); } } var b = new B(); console.log(B.toStr()); //输出：hello 继承表达式的类 类不但可以继承自其他类，也可以继承表达式。只要表达式可以被解析为一个函数并且通过new关键字可以创建新的实例对象即可。 let Obj = function(name) { this.name = name; } Obj.prototype.getName = function() { console.log(this.name); } class Person extends Obj { constructor(name, age) { super(name); this.age = age; } } const p = new Person(\"Tom\", 19); console.log(p.name); //输出：Tom console.log(p.age); //输出：19 p.getName(); //输出：Tom 继承函数返回结果 let fn = function() { return class Person { constructor(name) { return { name } } } } class SomeOne extends fn() { constructor(name) { super(name); } } let p = new SomeOne(\"Tom\"); console.log(p.name); //输出：Tom New.target 我们知道，函数内部有一个new.target对象用于判断函数是否通过new关键字调用。类构造函数也可以通过new.target来确定类的调用形式。 例子： class Obj { //new Obj()时，new.target的值为 Obj constructor() { if (new.target === Obj) { console.log(\"不可以直接调用基类！\"); } } fn() { console.log(this.name); } } class Person extends Obj { //new Person(\"Tom\")时，new.target的值为 Person constructor(name) { super(); this.name = name; } } let p1 = new Person(\"Tom\"); p1.fn(); //输出：Tom let p2 = new Obj(); //输出：不可以直接调用基类！ *因为类必须通过new关键字调用，所以在类的构造函数中new.target的值永远不会是undefined。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-28 00:32:38 "},"Javascript/基础2.1：原型和原型链（继承）.html":{"url":"Javascript/基础2.1：原型和原型链（继承）.html","title":"基础2.1：原型和原型链(继承) ✔","keywords":"","body":" 2.1原型与原型链(继承) https://github.com/mqyqingfeng/Blog/issues/2  1. 原型  2. 原型链  3. 继承 题目 1 var A = function() {}; A.prototype.n = 1; var b = new A(); A.prototype = { n: 2, m: 3 } var c = new A(); console.log(b.n); console.log(b.m); console.log(c.n); console.log(c.m); 请写出上面编程的输出结果是什么？ 题目 2 var F = function() {}; Object.prototype.a = function() { console.log('a'); }; Function.prototype.b = function() { console.log('b'); } var f = new F(); f.a(); f.b(); F.a(); F.b(); 请写出上面编程的输出结果是什么？ 题目 3 function Person(name) { this.name = name } let p = new Person('Tom'); 问题1：1. p.proto等于什么？ 问题2：Person.proto等于什么？ 题目 4 var foo = {}, F = function(){}; Object.prototype.a = 'value a'; Function.prototype.b = 'value b'; console.log(foo.a); console.log(foo.b); console.log(F.a); console.log(F.b); 请写出上面编程的输出结果是什么？ 解题 题目 1 答案： b.n -> 1 b.m -> undefined; c.n -> 2; c.m -> 3; 题目 2 答案： f.a() -> a f.b() -> f.b is not a function F.a() -> a F.b() -> b 题目 3 答案 答案1：Person.prototype 答案2：Function.prototype 题目 4 答案 foo.a => value a foo.b => undefined F.a => value a F.b => value b 如果小伙伴们查看完答案，仍不知道怎么回事，那么，我们扩展下自己的知识点，畅快了解更多地知识吧！ 前因后果 原因 OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承， 所以 其实现 继承 主要是依靠原型链 继续 原型链是用来实现继承的，因為沒有類的結構，用prototype實現有類語言的繼承特性(創建構造器，指向對象)原型的作用，则是实现对象的继承 1. 原型 每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个proto，可称为隐式原型。 每个对象都有一个proto属性，指向创建该对象的函数的prototype。 函数也是一种对象，函数也有proto，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的proto指向了自身的Prototype。 自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，Function.proto指向Function.prototype 函数.Object.prototype确实一个特例——它的proto指向的是null，切记切记！ 原型 传送门 2. 原型链 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 原型链是实现继承的\b主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 概念： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例\b都包含一个指向原型对象的指针。假如原型对象是另一个\b构造函数的实例，那么原型对象也包含一个指向另一个原型的指针，如此层层递进，就叫原型链。 简而言之：因为没有类的结构，用prototype实现有类语言的继承特性（创建构造器，指向对象） 注：所有引用类型都默认继承自 object ，object 的原型为null。 确定原型与实例之间的关系：instanceof isPrototypeOf 一张图总结： 3. 继承 八种继承的方式传送门 使用原型继承的缺陷 缺陷一：引用类型值的原型属性会被所有实例共享 举个例： function SuperType() { this.colors = [\"red\", \"blue\", \"green\"]; } function SubType() { } SubType.prototype = new SuperType(); var instance1 = new SuperType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green,black\" 例子中，SubType（子类）通过原型链继承了SuperType，SubType.prototype就变成了SuperType（超类，也就是我们所说的父类）的一个实例。也就是说，SubType.prototype中会有一个colors的数组，SubType的所有实例都将共享colors这个数组（引用类型值）。因此只要SubType其中一个实例对colors做了修改，就会影响到其他所有SubType的实例。 缺陷二：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 针对问题二中的第一句话，“在创建子类型的实例时，不能向超类型的构造函数中传递参数”，我举个例子： function SuperType(name) { // 超类型 this.name = name; } function SubType(age) { //子类型 this.age = age; } SubType.prototype = new SuperType(\"Allan\"); var instance1 = new SubType(10); console.log(instance1.name); // Allan console.log(instance1.age); // 10 var instance2 = new SubType(20); console.log(instance2.name); // Allan 上面代码中构造函数SuperType完全等价于下面声明的形式。 function SuperType() { name = \"Allan\"; } instance1通过原型链继承的name属性值，在instance1创建之前就已经被确定为Allan了。无论怎么new SuperType()都更改不了name属性值，这就是所谓的“在创建子类型的实例时，不能向超类型的构造函数中传递参数”。 针对问题二中的第二句话，“实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”,这句话应该怎么理解？ 其实在上面的代码中，我在创建SuperType实例的时候，向它传递了一个”Allan”的字符串参数。但是我们看到后面所有的SubType的实例，无论是instance1还是instance2的name属性都是Allan，也就是说SuperType创建实例时传递的参数，影响了后面所有SubType的实例。这就是所谓“没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”。 js通过沿着作用域链还是原型链查找变量? 首先，要分清作用域链与原型链的区别，简单来说 作用域链是相对于函数的，原型链是相对于对象的 js中访问变量有多种方式 直接通过标识符访问 通过 . 或 [] 访问对象中的标识符 猜想访问方式不同，导致了查找的方式不同： 直接通过标识符访问，访问的可能是函数中的标识符，也可能是全局对象（浏览器中是 window）的标识符，也就是说，可能沿着作用域链也可能沿着原型链访问 通过 . 或 [] 访问对象中的标识符，js会沿着原型链查找 对于第二点，以下的小测试可以证明 Object.prototype.a = 1; a = 2 var o = { a: 3 } function test() { console.log(this.a) } test(); // 2 (1) test.call(o); // 3 (2) delete o.a; test.call(o); // 1 (3) delete a; test(); // 1 (4) ① 相当于调用 window.test（），this 指向 window，访问的是 window.a； ② 中 this 指向 o，访问的是 o.a； 将全局的 a， 也就是 window.a 和 o.a 删除之后，得到的结果均是 1。 因此，通过 . 或 [] 访问对象中的标识符，js会沿着原型链查找。 第一点，直接通过标识符访问，也就是访问当前执行上下文EC的作用域中的变量，这一过程称为标识符解析，依赖于作用域链。 作用域链Scope其实就是对执行上下文EC中的变量对象VO|AO有序访问的链表 关于作用域链与执行上下文 EC 的关系，请看这里 测试 Object.prototype.a = 1; Window.prototype.a = 4 a = 2 var o = { a: 3 } function test() { console.log(a) } test(); // 2 (1) test.call(o); // 2 (2) delete a; test() // 4 (3) test.call(o); // 4 (4) delete Window.prototype.a test() //1 (6) test.call(o) //1 (6) 把 this.a 改为 a，②的结果就变啦。 ① 和 ② 的执行上下文EC（即 this 的指向）分别为 window 和 o，但作用域链都是 test变量对象 + 全局变量对象。而test变量对象中没有 a，全局变量对象含有 a 。这就说明，在函数中直接通过标识符变量，js会沿着作用域中查找。 有趣的是，当删除了全局变量对象中的 a，再访问 a，浏览器并没有报错，而是输出 4；删除 Window.prototype.a 之后，输出的这是 1. 在 test 中添加一下代码 ： console.log(a === Window.prototype.a) console.log(a === Object.prototype.a) 由结果可知，访问到的a 分别为 Window.prototype 和 Object.prototype 中的变量。 为什么呢？因为在浏览器中，全局变量对象在浏览器中指向 window， window 也是对象，且位于作用域链的末尾；作用域链查找完，仍然找不到，js 就会沿着全局变量对象的原型链查找。 结论 直接通过标识符访问变量，首先沿着作用域链查找每一个变量对象，直到全局变量对象（window）仍没有，就沿着全局变量对象（window）的原型链查找 通过 . 或 [] 访问对象中的标识符，就直接沿着原型链查找 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-29 00:37:03 "},"Javascript/基础2.2：作用域和作用域链.html":{"url":"Javascript/基础2.2：作用域和作用域链.html","title":"基础2.2：作用域和作用域链 ✔","keywords":"","body":"2.2作用域与作用域链 https://github.com/mqyqingfeng/Blog/issues/3 1.作用域？ 变量a的作用域是什么？一会儿又问：函数a的作用域是什么？变量和函数的作用域分别是啥玩意？ 我们先来看看“作用域”是什么意思，“作用域”拆开来就是“作用”和“域” 作用：访问、操作、调用…… 域：区域、范围、空间…… 作用域: 就是变量和函数的可访问范围，或者说变量或函数起作用的区域。 作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 作用域的类型 Javascript中有三种作用域： 全局作用域； 函数作用域； 块级作用域； 全局作用域 任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。例如： // 全局变量 var greeting = 'Hello World!'; function greet() { console.log(greeting); } // 打印 'Hello World!' greet(); 2. 函数作用域 函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。例如： function greet() { var greeting = 'Hello World!'; console.log(greeting); } // 打印 'Hello World!' greet(); // 报错： Uncaught ReferenceError: greeting is not defined console.log(greeting); 3. 块级作用域 块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建： 在一个函数内部 在一个代码块（由一对花括号包裹）内部 let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点： 声明变量不会提升到代码块顶部 let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。 function getValue(condition) { if (condition) { let value = \"blue\"; return value; } else { // value 在此处不可用 return null; } // value 在此处不可用 } 禁止重复声明 如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如： var count = 30; let count = 40; // Uncaught SyntaxError: Identifier 'count' has already been declared 在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。 var count = 30; // 不会抛出错误 if (condition) { let count = 40; // 其他代码 } 循环中的绑定块作用域的妙用 开发者可能最希望实现 for 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如，以下代码在 JS 经常见到： 测试1 测试2 测试3 var btns = document.getElementsByTagName('button') for (var i = 0; i 我们要实现这样的一个需求: 点击某个按钮, 提示\"点击的是第 n 个按钮\",此处我们先不考虑事件代理,万万没想到，点击任意一个按钮，后台都是弹出“第四个”,这是因为 i 是全局变量,执行到点击事件时，此时 i 的值为 3。那该如何修改，最简单的是用 let 声明 i for (let i = 0; i 简单地理解，JS源代码被函数{ }划分成一块一块的区域，这些区域换个身份就是某函数或某变量的作用域，变量的作用域和函数的作用域在源代码中有可能指的是同一块区域。 javascript除了全局作用域之外，只有函数可以创建的作用域。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 作用域在函数定义时就已经确定了。而不是在函数调用时确定。 一张图总结作用域： 作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。 所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 词法作用域是 作用域的一种工作模型”，作用域有两种工作模型，在JavaScript中的词法作用域是比较主流的一种，另一种动态作用域（比较少的语言在用）。词法作用域是在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了。 2.作用域链 作用域链（Scope Chain）是javascript内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域链 作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式结构，也可理解为是一个对象列表，所以我们称之为作用域链。 定义 当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链。 产生过程 函数在创建的时候同时也会创建一个包含全局变量对象的作用域链，别急，这时候这个链子上只有一个全局变量对象。 下一步，调用函数（不然创建函数干嘛~），此时会有相应的函数执行环境产生，理所当然地会产生一个该执行环境的变量对象（因为每个执行环境都有一个变量对象），那么它就会被当做活动对象被推入作用域链的前端。到这里，一个完整的作用域链产生了，它包含两个变量对象：本地活动对象和全局变量对象。 每个函数在执行时都会有一个执行环境，而每个执行环境中都有相应的变量对象，其实作用域链正是由这些变量对象连接得到。在搜索变量时，会沿着作用域链自下而上进行搜索，如果该变量存在于活动对象中则停止搜索，否则继续向上搜索，直至找到该变量。 原理 作用域链的形成原理，通过1999年的ECMAScript-262-3th第三版来说明作用域链的形成原理，将会介绍执行环境，变量对象和活动对象，arguments对象，作用域链等几个概念。2009年发布了ECMAScript-262-5th第五版，不同的是取消了变量对象和活动对象等概念，引入了词法环境（Lexical Environments）、环境记录（EnviromentRecord）等新的概念，所以两个版本的概念不要混淆了。 几个概念 自由变量 当前作用域没有定义的变量，这成为自由变量。在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量,如下图： 注：自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域” [[scope]]：每个JavaScript函数都是一个对象，对象中有些属性我们可以访问，也有些不可以访问，这些属性仅供JavaScript引擎存取，[[scope]]就是其中的一个,内部属性[[scope]]指向当前的作用域对象，。 [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。 运行期上下文指的是：当函数执行时，创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文会被销毁。也就是在预编译过程的时候所产生的（上一篇文章上所说的AO）。 函数被定义的时候，就已经再[[scope]]上创建了一个GO对象（在[[scope]]上存储了一个Global Object对象，在[[scope]]的第一位），接着函数被执行的时候又在[[scope]]上创建了一个AO对象，此时AO对象会被放在[[scope]]作用域链的顶端，GO对象排在函数自身的AO对象的后面；此时AO对象的变量会覆盖同名的GO对象的变量。函数执行过程中，查找变量的时候是从作用域链的最顶端（第一个对象）开始往后查找，就是说先从自身的AO对象查找，如果没有找到的话再沿着作用域链去GO（未必是GO对象，当函数内还嵌套了其它函数的话，[[scope]]上至少存在3个对象，反正就是会继续往下一个对象查找）对象查找；如果在整个作用域链上都找不到想要的属性的话，会抛出一个引用错误异常（ReferenceError）。 var name = 'globalName'; function funcA() { //当funcA()被调用时，刚进入funcA的执行环境，其作用域链最前端的funA activation object里有name属性，值为undefined。 console.log(name); var name = 'funAName'; console.log(name); console.log(age); } funcA(); 执行环境：函数被调用时会创建一个执行环境和执行环境相应的作用域链 对于每个执行环境，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 函数对象 ​ 在一个函数定义的时候， 会创建一个这个函数对象的[[scope]]属性（内部属性,只有JS引擎可以访问, 但FireFox的几个引擎（SpiderMonkey和Rhino）提供了私有属性parent来访问它)，并将这个[[scope]]属性指向定义它的作用域链上。 在这里的问题中，因为funcA定义在全局环境, 所以此时的[[scope]]只是指向全局活动对象window active object。 变量对象：每个执行环境都有一个表示变量的对象即变量对象，全局环境的变量对象一直存在，而像函数那样的局部环境的变量对象只会在执行的过程中存在 活动对象：在一个函数对象被调用的时候，会创建一个活动对象，首先将该函数的每个形参和实参，都添加为该活动对象的属性和值；将该函数体内显示声明的变量和函数，也添加为该活动的的属性（在刚进入该函数执行环境时，未赋值，所以值为undefined，这个是JS的提前声明机制）。 ​ 然后将这个活动对象做为该函数执行环境的作用域链的最前端，并将这个函数对象的[[scope]]属性里作用域链接入到该函数执行环境作用域链的后端。 在作用域 链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，......直至作 为作用域链终点的全局执行环境。 在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。 var name = 'globalName'; function funcA() { //当funcA()被调用时，刚进入funcA的执行环境，其作用域链最前端的funA activation object里有name属性，值为undefined。 console.log(name); var name = 'funAName'; console.log(name); console.log(age); } funcA(); 作用域与执行上下文 许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。 我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样： 解释阶段： 词法分析 语法分析 作用域规则确定 执行阶段： 创建执行上下文 执行函数代码 垃圾回收 JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。 作用域和执行上下文之间最大的区别是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。 一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。 延长作用域 延长作用域 有两种方法可以将作用域进行延长: ①、try-catch 语句的catch块 ②、with 语句 两个语句都是在原本的作用域最前端进行添加一个变量对象；例如： var name = \"global\"; function test(){ var name = \"sub\"; with(window){ console.log(name); } } test(); // -- \"global\" 所以检索变量时，会先在最前端的window变量对象中检索；当然，在严格模式下已经禁用了with语句，编程时，最好向后兼容，废弃使用with语句； 什么是with? 首先来看一段代码: function validate_email(field, alerttxt) { with(field) { apos = value.indexOf(\"@\") dotpos = value.lastIndexOf(\".\") if(apos Email: 这个是一个网站教程的例子,相信很多人都会有疑问,里面在with ( )中嵌套了if,这个with()是什么方法?这个with()就是和if 一起用的吗? 其实with()和if()没有关系。 with(obj)作用就是将后面的{}中的语句块中的缺省对象设置为obj，那么在其后面的{}语句块中引用obj的方法或属性时可以省略obj.的输入而直接使用方法或属性的名称。比如： 不用with()时： function validate_email(field,alerttxt){ field.apos=value.indexOf(\"@\") field.dotpos=value.lastIndexOf(\".\") if (field.apos用了with(field)后，上面函数中的field.都可以省略了，减少了输入的工作量。 with对象能够使我们很方便的使用某个对象的一些属性，而不用每次都去写 对象名.属性 的形式，直接使用对象名 变量在作用域链与原型链中的查找顺序？ function C1(name){ if(name){ this.name = name; } } function C2(name){ this.name = name; } function C3(name){ this.name = name || \"John\"; } C1.prototype.name = \"Tom\"; C2.prototype.name = \"Tom\"; C3.prototype.name = \"John\"; console.log(new C1().name + \",\" + new C2().name + \",\" + new C3().name); 不运行，求答案！^_^，这道题目对于理解js作用域链十分有用，拿出来和大家分享一下 要做出这道题，最重要是理解js中变量在作用域链和原型链中查找的顺序， 从内到外大致如下： 本地属性 ---> prototype 变量查找顺序： 能在本地属性中找到的绝不去prototype中找 先来分析第一个 new C1().name function C1(name){ if(name){ this.name = name; } } C1.prototype.name = \"Tom\"; 分析： 由于这里没有参数，默认被赋值成了undefined，所以到了if这里就进不去了，因此在C1本地 属性中找不到name这个属性，只能傻逼兮兮的往外找了，又因为C1.prototype.name = \"Tom\"的 存在，在prototype中找到了name属性，所以最后打印出来的答案是\"Tom\" 接着来分析第二个 new C2().name function C2(name){ this.name = name; } C2.prototype.name = \"Tom\"; 分析： 由于这次还是没有参数，同样默认被赋值成了undefined，于是本地属性name被赋值成了 undefined。于是在查找的时候一下子就查到了name的值为undefined, 因此C2.prototype.name = \"Tom\"并没有什么卵用，最终答案为undefined 最后来分析第三个 new C3().name function C3(name){ this.name = name || \"John\"; } C3.prototype.name = \"John\"; 分析： 同样是没有参数，undefined作为参数进来以后情况变成了这样： this.name = undefined || \"John\"，然后结果很明显了本地属性name被赋值成\"John\"。 接着是从内往外查找，一下子就锁定了本地属性name，此时的值为\"John\"。 因此C3.prototype.name = \"John\"同样没有什么用 总结： 如果原型链，作用域链上有相同的方法。那么会优先找作用域链上的，找到并执行，原型链上的方法就不执行了。 同样的，属性的查找也是这么个顺序。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-07 22:05:27 "},"Javascript/基础2.3：闭包，作用域链理解闭包.html":{"url":"Javascript/基础2.3：闭包，作用域链理解闭包.html","title":"基础2.3：闭包，作用域链理解闭包 ✔","keywords":"","body":"定义 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数， MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。 简洁版：保护一个可重用的局部变量的词法结构 闭包的特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 闭包的模式 函数模式的闭包：函数中包含函数。 对象模式的闭包：函数中包含对象 / 函数闭包 function A() { var num = 10; return function () { return num++; } } var func = A(); console.log(func()); console.log(func()); console.log(func()); // 对象闭包 function A() { var num = 10; return { age: num++ }; } var func = A(); console.log(func.age); 闭包的优点 使一个变量长期驻扎在内存中 避免全局变量的污染 作为私有成员的存在 延长作用域链。闭包的缺点 闭包的缺点，更多地是在内存性能的方面。 由于变量长期驻扎在内存中，在复杂程序中可能会出现内存不足，但这也不算非常严重，我们需要在内存使用与开发方式上做好取舍。在不需要的时候清理掉变量 在某些时候（对象与DOM存在互相引用，GC使用引用计数法）会造成内存泄漏，要记得在退出函数前清理变量 window.onload = function() { var elem = document.querySelector('.txt'); // elem的onclick指向了匿名函数，匿名函数的闭包也引用着elem elem.onclick = function() { console.log(this.innerHTML); }; // 清理 elem = null; }; 除此之外，由于闭包中的变量可以在函数外部进行修改（通过暴露出去的接口方法），所有不经意间也内部的变量会被修改，所以也要注意 只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。 1.函数作为返回值 2.函数作为参数传递 fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。 自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点 当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。 核心内容 函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。 第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。 第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。 因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。 ——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图： 第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。 执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。 这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。 使用闭包会增加内容开销！ 第五步，执行完20行就是上下文环境的销毁过程。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-25 12:08:23 "},"Javascript/基础2.4：this.html":{"url":"Javascript/基础2.4：this.html","title":"基础2.4：this ✔","keywords":"","body":"this https://blog.csdn.net/lisummit/article/details/80561758 http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html https://www.cnblogs.com/hjson/archive/2019/01/11/10254555.html 先来一道题 var a = 10;//全局变量 值为10 function foo() { console.log(this)//此处this一直指向window, 所以this.a一直是10 console.log(a); //a全局变量 打印10 } (function() {//自执行函数 此处this指代window,自执行函数其实是window对象调用它！函数分普通函数和构造函数普通函数的this指向window，构造函数的this指向它本身，谁调用它this就指向谁！ var a = 20; console.log(this.a)//10 foo();//依然打印10 })(); (function (func) {//自执行函数 此处this指代window var a = 30; console.log(this.a)//10 func();//依然打印10 })(foo) 注意：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。 再一道 var value = 1; var foo = { value: 2, bar: function () { return this.value; } } //示例1 console.log(foo.bar()); //示例2 console.log((foo.bar)()); //示例3 console.log((foo.bar = foo.bar)()); //示例4 console.log((false || foo.bar)()); //示例5 console.log((foo.bar, foo.bar)()); 情况1：构造函数(实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。) 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如： function foo(a) { this.a = a; } var bar = new foo(2); // bar和foo(..)调用中的this进行绑定 console.log( bar.a ); // 2 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个新对象。 这个新对象会被执行[[Prototype]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 使用new来调用foo(..)时，会构造一个新对象并把它（bar）绑定到foo(..)调用中的this。 情况2：函数作为对象的一个属性 如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象 var obj = { x: 10, fn: function() { console.log(this) //obj {x: 10, fn: ƒ} console.log(this.x) //10 } } obj.fn() 注意:如果fn函数不作为obj的一个属性被调用，会是什么结果呢？ var obj = { x: 10, fn: function() { console.log(this) //Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …} console.log(this.x) //undefined } } var fn = obj.fn fn() 如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。 var value = 1 var foo = { value: 2, bar: function() { return this.value } } console.log((foo.bar)()) // 2 情况3：函数用call或者apply调用 当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用看下一节 var obj = { x: 10, } var fn = function() { console.log(this) //obj {x: 10} console.log(this.x) //10 } fn.call(obj) 情况4：全局 以及 调用普通函数 在全局环境下，this永远是window console.log(this === window) //true 普通函数在调用时，其中的this也都是window。 var x = 10 var fn = function() { console.log(this) //window console.log(this.x) //10 } fn() 注意： var obj = { x: 10, fn: function() { function f(){ console.log(this) //window console.log(this.x) //undefined } f() } } obj.fn() 函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。 情况5:箭头函数绑定 箭头函数根本没有自己的this，导致内部的this就是外层代码块的this，是根据外层（函数或者全局）作用域（词法作用域）来决定this。 对于箭头函数的this总结如下： 箭头函数不绑定this，箭头函数中的this相当于普通变量。 箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。 箭头函数的this无法通过bind（直接返回一个新函数，不直接执行），call，apply来直接修改（可以间接修改）。 改变作用域中this的指向可以改变箭头函数的this。 注意： setInterval和setTimeout中传入函数时，函数中的this会指向window对象 var num = 0; function Obj (){ this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(function(){ console.log(this.num); }, 1000) } } var obj = new Obj; obj.getNum();//1　　打印的是obj.num，值为1 obj.getNumLater()//0　　打印的是window.num，值为0 原因：由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致这些代码中包含的 this 关键字会指向 window (或全局)对象。 解决方法 若想要让setTimeout中的this指向正确的值，可以使用以下三种比较常用的方法来使this指向正确的值： 将当前对象的this存为一个变量，定时器内的函数利用闭包来访问这个变量，如下： var num = 0; function Obj (){ var that = this; //将this存为一个变量，此时的this指向obj this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(function(){ console.log(that.num); //利用闭包访问that，that是一个指向obj的指针 }, 1000) } } var obj = new Obj; obj.getNum();//1　　打印的是obj.num，值为1 obj.getNumLater()//1　　打印的是obj.num，值为1 这种方法是将当前对象的引用放在一个变量里，定时器内部的函数来访问到这个变量，自然就可以得到当前的对象。 利用bind()方法 var num = 0; function Obj (){ this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(function(){ console.log(this.num); }.bind(this), 1000) //利用bind()将this绑定到这个函数上 } } var obj = new Obj; obj.getNum();//1　　打印的为obj.num，值为1 obj.getNumLater()//1　　打印的为obj.num，值为1 bind()方法是在Function.prototype上的一个方法，当被绑定函数执行时，bind方法会创建一个新函数，并将第一个参数作为新函数运行时的this。在这个例子中，在调用setTimeout中的函数时，bind方法创建了一个新的函数，并将this传进新的函数，执行的结果也就是正确的了。关于bind方法可参考 MDN bind 箭头函数 var num = 0; function Obj (){ this.num = 1, this.getNum = function(){ console.log(this.num); }, this.getNumLater = function(){ setTimeout(() => { console.log(this.num); }, 1000) //箭头函数中的this总是指向外层调用者，也就是Obj } } var obj = new Obj; obj.getNum();//1　　打印的是obj.num，值为1 obj.getNumLater()//1　　打印的是obj.num，值为1 ES6中的箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj，因此利用箭头函数就可以轻松解决这个问题。 练习 /** * 非严格模式 */ var name = 'window' var person1 = { name: 'person1', show1: function () { console.log(this.name) }, show2: () => console.log(this.name), show3: function () { return function () { console.log(this.name) } }, show4: function () { return () => console.log(this.name) } } var person2 = { name: 'person2' } person1.show1() person1.show1.call(person2) person1.show2() person1.show2.call(person2) person1.show3()() person1.show3().call(person2) person1.show3.call(person2)() person1.show4()() person1.show4().call(person2) person1.show4.call(person2)() 答案 person1.show1() // person1，隐式绑定，this指向调用者 person1 person1.show1.call(person2) // person2，显式绑定，this指向 person2 person1.show2() // window，箭头函数绑定，this指向外层作用域，即全局作用域 person1.show2.call(person2) // window，箭头函数绑定，this指向外层作用域，即全局作用域 person1.show3()() // window，默认绑定，这是一个高阶函数，调用者是window // 类似于`var func = person1.show3()` 执行`func()` person1.show3().call(person2) // person2，显式绑定，this指向 person2 person1.show3.call(person2)() // window，默认绑定，调用者是window person1.show4()() // person1，箭头函数绑定，this指向外层作用域，即person1函数作用域 person1.show4().call(person2) // person1，箭头函数绑定， // this指向外层作用域，即person1函数作用域 person1.show4.call(person2)() // person2 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 19:42:20 "},"Javascript/基础3.1：js内存与内存泄漏.html":{"url":"Javascript/基础3.1：js内存与内存泄漏.html","title":"基础3.1：js内存与内存泄漏 ✔","keywords":"","body":"JS内存和内存泄漏 JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。 内存回收 JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。 局部变量和全局变量的销毁 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。 以Google的V8引擎(js引擎)为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。 V8引擎对堆内存中的JS对象进行分代管理 新生代：存活周期较短的JS对象，如临时变量、字符串等。 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。 更为详细的v8内存机制 V8 引擎会限制 JavaScript 所能使用的内存大小 性能问题：(运行时间间隔) IE7 之前的垃圾收集器是根据内存分配量运行的，达到某一个临界值就是启动垃圾回收器 缺点：如果该脚本在其生命周期需要一直保持这么多变量，垃圾回收器就不得不频繁运行。 浏览器可自动触发： window.CollectGarbage() 避免：执行代码中只保留必要的数据，一旦数据不再有用，通过设置为 null 来释放其引用(适用于大多数全局变量和全局对象的属性) V8 的堆构成 新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。 老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。 大对象区：这里存放体积超越其他区大小的对象。每个对象有自己 map 产生的内存。垃圾回收器从不移动大对象。 代码区：代码对象，也就是包含 JIT 之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。 Cell 区、属性 Cell 区、Map 区：这些区域存放 Cell、属性 Cell 和 Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单 分代回收 原因：绝大多数对象的生存期很短，只有某些对象的生存期较长 过程： 1、对象起初会被分配在新生区（通常很小，只有 1-8 MB）在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。 2、活跃超过 2 个小周期的对象，则需将其移动至老生区老生区在标记－清除或标记－紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。 垃圾回收算法 对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。 引用计数（现代浏览器不再使用） 标记清除（常用） 引用计数 引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。 // 创建一个对象person，他有两个指向属性age和name的引用 var person = { age: 12, name: 'aaaa' }; person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收 var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收 p = null; //原person对象已经没有引用，很快会被回收 引用计数有一个致命的问题，那就是循环引用 如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。 function cycle() { var o1 = {}; var o2 = {}; o1.a = o2; o2.a = o1; return \"cycle reference!\" } cycle(); cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。 但是IE依旧使用。 var div = document.createElement(\"div\"); div.onclick = function() { console.log(\"click\"); }; 上面的写法很常见，但是上面的例子就是一个循环引用。 变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。 标记清除（常用） 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 那些还存在标记的变量被视为准备删除的变量。 垃圾收集器会执行一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。 标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。 无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。 所以上面的例子就可以正确被垃圾回收处理了。 所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关： email.message = document.createElement(“div”); displayList.appendChild(email.message); // 稍后从displayList中清除DOM元素 displayList.removeAllChildren(); 上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。 内存泄漏 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak） 内存泄漏识别方法 浏览器方法 打开开发者工具，选择 Memory 在右侧的Select profiling type字段里面勾选 timeline 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。 命令行方法 使用 Node 提供的 process.memoryUsage 方法。 console.log(process.memoryUsage()); // 输出 { rss: 27709440, // resident set size，所有内存占用，包括指令区和堆栈 heapTotal: 5685248, // \"堆\"占用的内存，包括用到的和没用到的 heapUsed: 3449392, // 用到的堆的部分 external: 8772 // V8 引擎内部的 C++ 对象占用的内存 } 判断内存泄漏，以heapUsed字段为准。 WeakMap ES6 新出的两种数据结构：WeakSet 和 WeakMap，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。 const wm = new WeakMap(); const element = document.getElementById('example'); wm.set(element, 'some information'); wm.get(element) // \"some information\" 先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 思考题 var a = {n: 1}; var b = a; a.x = a = {n: 2}; a.x // --> undefined b.x // --> {n: 2} 答案已经写上面了，这道题的关键在于 优先级。.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。 赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2} 四种常见的JS内存泄漏 一. 意外的全局变量 未定义的变量会在全局对象创建一个新变量，如下。 function foo(arg) { bar = \"this is a hidden global variable\"; } 函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。 function foo(arg) { window.bar = \"this is an explicit global variable\"; } 另一个意外的全局变量可能由 this 创建。 function foo() { this.variable = \"potential accidental global\"; } // Foo 调用自己，this 指向了全局对象（window） // 而不是 undefined foo(); 解决方法： 在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。 二. 被遗忘的计时器或回调函数 计时器setInterval代码很常见 var someResource = getData(); setInterval(function() { var node = document.getElementById('Node'); if(node) { // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); } }, 1000); 上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 var element = document.getElementById('button'); function onClick(event) { element.innerHTML = 'text'; } element.addEventListener('click', onClick); 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。 三.脱离 DOM 的引用 如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。 var elements = { button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text') }; function doStuff() { image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML); // 更多逻辑 } function removeButton() { // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById('button')); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 } 如果代码中保存了表格某一个 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 以外的其它节点。实际情况并非如此：此 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。 四.闭包闭包的关键是匿名函数可以访问父级作用域的变量。 var theThing = null; var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) console.log(\"hi\"); }; theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); 每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。 解决方法： 在 replaceThing 的最后添加 originalThing = null 。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-10-27 23:42:48 "},"Javascript/高性能渲染十万条数据（DocumentFragment + requestAnimationFrame）.html":{"url":"Javascript/高性能渲染十万条数据（DocumentFragment + requestAnimationFrame）.html","title":"高性能渲染十万条数据（DocumentFragment + requestAnimationFrame） ✔","keywords":"","body":"最粗暴的做法（一次性渲染） // 记录任务开始时间 let now = Date.now(); // 插入十万条数据 const total = 100000; // 获取容器 let ul = document.getElementById('container'); // 将数据插入容器中 for (let i = 0; i { console.log('总运行时间：',Date.now() - now); },0) // print: JS运行时间： 187 // print: 总运行时间： 2844 我们对十万条记录进行循环操作，JS的运行时间为187ms，还是蛮快的，但是最终渲染完成后的总时间确是2844ms。 简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单来统计JS运行时间和总渲染时间： 在 JS 的Event Loop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染 第一个console.log的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间 第二个console.log是放到 setTimeout 中的，它的触发时间是在渲染> 依照两次console.log的结果，可以得出结论： 对于大量数据渲染的时候，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段 使用定时器 从上面的例子，我们已经知道，页面的卡顿是由于同时渲染大量DOM所引起的，所以我们考虑将渲染过程分批进行 在这里，我们使用setTimeout来实现分批渲染 复制代码 //需要插入的容器 let ul = document.getElementById('container'); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //总页数 let page = total/once //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal,curIndex){ if(curTotal { for(let i = 0; i 为什么会出现闪屏现象呢 首先，理清一些概念。FPS表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，FPS是描述帧变化速度的物理量。 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，FPS为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。 因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。 为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了， 这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。 而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁， 这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。 大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。 因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 直观感受，不同帧率的体验： 帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适； 帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异； 帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感； 帧率波动很大的动画，亦会使人感觉到卡顿。 setTimeout 和闪屏现象 setTimeout的执行时间并不是确定的。在JS中，setTimeout任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此setTimeout的实际执行时间可能会比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。 在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 requestAnimationFrame 关于requestAnimationFrame requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量。 requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。 如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。 我们使用requestAnimationFrame来进行分批渲染： 复制代码 //需要插入的容器 let ul = document.getElementById('container'); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal,curIndex){ if(curTotal 此时页面加载的速度很快，并且滚动的时候，也很流畅没有出现闪烁丢帧的现象。 DocumentFragment + requestAnimationFrame 先解释一下什么是 DocumentFragment ，文献引用自MDN DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。 可以使用document.createDocumentFragment方法或者构造函数来创建一个空的DocumentFragment 从MDN的说明中，我们得知DocumentFragments是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。 通过 DocumentFragment 的使用，减少 DOM 操作次数，降低回流对性能的影响。并且可以通过 requestAniminationFrame 保证插入新节点操作在页面重绘前执行，二者结合可以实现数据渲染优化。 最后修改代码如下： //需要插入的容器 let ul = document.getElementById('container'); // 插入十万条数据 let total = 100000; // 一次插入 20 条 let once = 20; //总页数 let page = total/once //每条记录的索引 let index = 0; //循环加载数据 function loop(curTotal,curIndex){ if(curTotal requestAnimationFrame 兼容 具体看https://github.com/darius/requestAnimationFrame // requestAnimationFrame polyfill by Erik Möller. // Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavič, Darius Bacon // MIT license if (!Date.now) Date.now = function() { return new Date().getTime(); }; (function() { 'use strict'; var vendors = ['webkit', 'moz']; for (var i = 0; i 使用 (function animate(){ requestAnimationFrame(animate); //动画 })(); Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 11:58:05 "},"Javascript/多个连续的箭头函数与柯里化.html":{"url":"Javascript/多个连续的箭头函数与柯里化.html","title":"多个连续的箭头函数与柯里化 ✔","keywords":"","body":" title: 多个连续的箭头函数与柯里化 categories: \"多个连续的箭头函数与柯里化\" tags: javascript es6 高阶函数 高阶函数定义：将函数作为参数或者返回值是函数的函数。 所以高阶函数分两种： 是我们常见的 sort,reduce 等函数。 返回值是函数的函数。 一般而言，我们要理解常见的高阶函数还是很容易的。比如： function add(a) { return function(b) { return a + b } } var add3 = add(3) add3(4) === 3 + 4 //true add 函数 在 es6 里的写法等价为 let add = a => b => a + b 其实以上就是 柯里化函数 只不过用 es6 写，变了一个样子，后面详细介绍它的原理和特点。 多个连续的箭头函数 but 当一堆箭头函数在你面前的时候，你会不会有一丝犹豫，我在此之前就是一脸懵逼。。。比如我看到下面的 redux-thunk 的源码（没错整个源码只有14行）里的多个连续箭头函数的时候。。。 // 形如 a => b => c => {xxx} 那怎么轻松理解这些箭头干了啥呢，当我看了柯里化后，瞬间就懂了， 多个连续箭头函数就是 es6的多次柯里化的写法 柯里化 我们先看 stackoverflow 的关于如何理解多个箭头函数的最高票回答, 他说 这就是柯里化函数。(This is a curried function) wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术 好，现在懂没，我来简单说一下。 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 let add = x => y => x + y let add2 = add(2) 本来完成 add 这个操作，应该是 let add = (x, y) => x + y 它需要俩参数，而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y => x + y 函数 并且此时 x = 2，所以此时调用 add2(3) === 2 + 3 回归正题 let add = x => y => x + y add 函数按照 wiki 的定义可以理解成只柯里化了一次，那么下面这种呢？ a => b => c => {xxx} n 个连续箭头组成的函数实际上就是柯里化了 n - 1次。 具体调用过程如下： 前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值。 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。 所以连续箭头函数就是多次柯里化函数的 es6 写法。 let test = a => b => c => {xxx} 调用特点 let test = a => b => c => {xxx} 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c 柯里化函数的功能 可以惰性求值 可以提前传递部分参数 出自 参考 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-06 21:23:00 "},"Javascript/函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free）.html":{"url":"Javascript/函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free）.html","title":"函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free） ✔","keywords":"","body":"主要的编程范式有三种：命令式编程(Imperative)、声明式编程(Declarative)和函数式编程(Functional) 函数式编程（纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free） 将电脑运算视为数学上的函数计算，并且避免使用程序状态和易变对象，又称泛函编程。 是一种编码风格，他通过书写函数式代码来解决问题,本质上它是一种数学运算，原始目的就是求值 函数式编程有两个最基本的运算：合成和柯里化。 react函数式定义 几个核心概念： 递归，尾递归，相互递归和蹦床函数见 纯函数，高阶函数，函数柯里化，函数组合，声明式和非声明式命令，point free(入参不用定义变量) 纯函数（输入一定时，输出一定）：输出不受外部环境影响，同时也不影响外部环境，无副作用 函数柯里化：把一个多参数的函数，转化为单参数函数（一个低阶函数转化为高阶函数的过程）。 （合成）反柯里化：将每次传入一个参数返回一个函数的形式转回,一次性传入所有参数返回结果的形势 偏函数： 偏函数就是为了复用一些每次都传入的相同的参数,等于对原来的函数做一层封装. 有点类似于我们在调用别人封装好的组件时, 需要传入很多属性,但是有些属性在我们项目中时都是一样的,这时候就可以自己对组件再一次封装,将一些属性默认传入. 声明式和命令式 声明式就像你告诉你朋友画一幅画，你不用去管他怎么画的细节 命令式就像按照你的命令，你朋友一步步把画画出来 换言之： 命令式编程(react)：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 声明式编程(jquery)：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 函数式编程（Functional） 函数式编程是声明式编程的一部分，因为他们思想是一致的：即只关注做什么而不是怎么做。但函数式编程除了对声明式编程的相似处之外，同时他也利用了js函数能够作为参数传递的特点。函数式编程最重要的特点是“函数第一位”,即函数可以出现在任何地方。 函数式编程的特性： （a）、不可变性(Immutability)：不可变性是指函数不存在副作用，如果需要修改，需要克隆新的备份数据进行处理 （b）、纯函数(Pure Functions)：纯函数是始终接受一个或多个参数并计算参数并返回数据或函数的函数 （c）、数据转换(Data Transformations)：对传递的数据克隆备份后，进行数据的处理，最终返回新的对象，避免副作用 （d）、闭包以及高阶函数 (Higher-Order Functions)：高阶函数是将函数作为参数或返回函数的函数，闭包不做解释 （e）、递归：递归是一种函数在满足一定条件之前调用自身的技术。 （f）、组合：常用的混合函数，将多个对象混合为一个新的对象。 （g）、惰性计算：在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。 来点代码 点击一个按钮，改变颜色 命令式： const container = document.getElementById(‘container’); const btn = document.createElement(‘button’); btn.className = ‘btn red’; btn.onclick = function(event) { if (this.classList.contains(‘red’)) { this.classList.remove(‘red’); this.classList.add(‘blue’); } else { this.classList.remove(‘blue’); this.classList.add(‘red’); } }; container.appendChild(btn); 声明式（react）： class Button extends React.Component{ this.state = { color: 'red' } handleChange = () => { const color = this.state.color === 'red' ? 'blue' : 'red'; this.setState({ color }); } render() { return ( ); } } 注意到什么不一样了么？ react没有去修改dom，只是声明了页面应该是什么样子（根据不同的state）. 　　 放到整个应用层面也是一样的道理，我们更加需要关心的是整个应用和页面的框架结构。 pointfree 函数式编程中的pointfree的意思就是“无参”或“无值”，pointfree style是一种编程范式，也作tacit programming，就是“无参编程”的意思了。什么是“无参编程”？ // 这就是有参的，因为有word var snakeCase = word => word.toLowerCase().replace(/\\s+/ig, '_'); // 这是pointfree var snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase); 从另一个角度看，有参的函数的目的是得到一个数据，而pointfree的函数的目的是得到另一个函数。 高阶函数：高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回 理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的\"范畴\"（category）。 范畴 范畴：彼此之间存在某种关系的概念、事物、对象等等，都构成\"范畴\"。随便什么东西，只要能找出它们之间的关系，就能定义一个\"范畴\"。范畴的数学模型 所有成员是一个集合 变形关系是函数把\"范畴\"想象成是一个容器，里面包含两样东西。 值（value） 值的变形关系，也就是函数。 下面我们使用代码，定义一个简单的范畴。 class Category { constructor(val) { this.val = val; } addOne(x) { return x + 1; } } 上面代码中，Category是一个类，也是一个容器，里面包含一个值（this.val）和一种变形关系（addOne）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。 注意，本文后面的部分，凡是提到\"容器\"的地方，全部都是指\"范畴\"。 范畴论与函数式编程的关系 范畴论使用函数，表达范畴之间的关系。 伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的\"函数式编程\"。 本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。 所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。 总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。 二.函数的合成与柯里化.反柯里化 1.合成（反柯里化）：如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做\"函数的合成\"（compose）。 const compose = function (f, g) { return function (x) { return f(g(x)); }; } 必须满足结合律 compose(f, compose(g, h)) // 等同于 compose(compose(f, g), h) // 等同于 compose(f, g, h) 面试题 手动实现一个compose函数，满足以下功能： var arr = [func1, func2, func3]; function func1 (ctx, next) { ctx.index++ next(); } function func2 (ctx, next) { setTimeout(function() { ctx.index++; next(); }); } function func3 (ctx, next) { console.log(ctx.index); } compose(arr)({index: 0}); // 输出：2 解： const compose = (arr) => { return function(ctx) { [...arr].reverse().reduce((func, item) => { return function(ctx) { item(ctx, function() { func(ctx) }) } }, ()=>{})(ctx) //因为reduce在这里返回的是函数，所以传入参数 } } function func1(ctx) { ctx.index++ (function (ctx) { func2(ctx, function() { func3(ctx) }) })(ctx); } 反人类版本！ const compose = arr => ctx => [...arr].reverse().reduce((func, item) => ctx => item(ctx, () => func(ctx)), () => {})(ctx) 2. 反柯里化 function uncurry(fn) { var args = [].slice.call(arguments, 1); return function() { var arg = [].slice.call(arguments); args = args.concat(arg); return fn.apply(this, args); } } var uncurryAdd = uncurry(curryAdd); console.log(uncurryAdd(1, 2, 3, 4)); // 10 var uncurryMul = uncurry(curryMul, 2); console.log(uncurryMul(3, 4)); // 24 2 柯里化: 把一个多参数的函数，转化为单参数函数（一个低阶函数转化为高阶函数的过程）。 f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。 这时就需要函数柯里化了。所谓\"柯里化\"，就是把一个多参数的函数，转化为单参数函数. // 柯里化之前 function add(x, y) { return x + y; } add(1, 2) // 3 // 柯里化之后 function addX(y) { return function (x) { return x + y; }; } addX(2)(1) // 3 比较经典的例子是 实现累加 add(1)(2)(3)(4) 第一种方法即是使用回调嵌套 function add(a) { // 疯狂的回调 return function(b) { return function(c) { return function(d) { // return a + b + c + d; return [a, b, c, d].reduce((v1, v2) => v1 + v2); } } } } console.log(add(1)(2)(3)(4)); // 10 既不优雅也不好扩展 修改两下，让它支持不定的参数数量 function add() { var args = [].slice.call(arguments); // 用以存储更新参数数组 function adder() { var arg = [].slice.call(arguments); args = args.concat(arg); // 每次调用，都返回自身，取值时可以通过内部的toString取到值 return adder; } // 指定 toString的值，用以隐示取值计算 adder.toString = function() { return args.reduce((v1, v2) => v1 + v2); }; return adder; } console.log(add(1, 2), add(1, 2)(3), add(1)(2)(3)(4)); // 3 6 10 上面这段代码，就能够实现了这个“柯里化” 需要注意的两个点是 arguments并不是真正的数组，所以不能使用数组的原生方法（如 slice） 在取值时，会进行隐示的求值，即先通过内部的toString()进行取值，再通过 valueOf()进行取值，valueOf优先级更高，我们可以进行覆盖初始的方法 当然，并不是所有类型的toString和toValue都一样，Number、String、Date、Function 各种类型是不完全相同的，本文不展开 上面用到了call 方法，它的作用主要是更改执行的上下文，类似的还有apply，bind 等 我们可以试着自定义一个函数的 bind方法，比如 var obj = { num: 10, getNum: function(num) { console.log(num || this.num); } }; var o = { num: 20 }; obj.getNum(); // 10 obj.getNum.call(o, 1000); // 1000 obj.getNum.bind(o)(20); // 20 // 自定义的 bind 绑定 Function.prototype.binder = function(context) { var fn = this; var args = [].slice.call(arguments, 1); return function() { return fn.apply(context, args); }; }; obj.getNum.binder(o, 100)(); // 100 还不够完善，假如要定义一个乘法的函数，就得再写一遍长长的代码 需要定义一个通用currying函数，作为包装 // 柯里化 function curry(fn) { var args = [].slice.call(arguments, 1); function inner() { var arg = [].slice.call(arguments); args = args.concat(arg); return inner; } inner.toString = function() { return fn.apply(this, args); }; return inner; } function add() { return [].slice.call(arguments).reduce(function(v1, v2) { return v1 + v2; }); } function mul() { return [].slice.call(arguments).reduce(function(v1, v2) { return v1 * v2; }); } var curryAdd = curry(add); console.log(curryAdd(1)(2)(3)(4)(5)); // 15 var curryMul = curry(mul, 1); console.log(curryMul(2, 3)(4)(5)); // 120 看起来就好多了，便于扩展 不过实际上，柯里化的应用中，不定数量的参数场景比较少，更多的情况下的参数是固定的（常见的一般也就两三个） // 柯里化 function curry(fn) { var args = [].slice.call(arguments, 1), // 函数fn的参数长度 fnLen = fn.length; // 存储参数数组，直到参数足够多了，就调用 function inner() { var arg = [].slice.call(arguments); args = args.concat(arg); if (args.length >= fnLen) { return fn.apply(this, args); } else { return inner; } } return inner; } function add(a, b, c, d) { return a + b + c + d; } function mul(a, b, c, d) { return a * b * c * d; } var curryAdd = curry(add); console.log(curryAdd(1)(2)(3)(4)); // 10 var curryMul = curry(mul, 1); console.log(curryMul(2, 3)(4)); // 24 上面定义的 add方法中，接受4个参数 在我们currying函数中，接受这个add方法，并记住这个方法需要接受的参数数量，存储传入的参数，直到符合数量要求时，便进行调用处理。 三.函子 函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。 1 函子的概念 函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。 2 函子的代码实现 任何具有map方法的数据结构，都可以当作函子的实现。 class Functor { constructor(val) { this.val = val; } map(f) { return new Functor(f(this.val)); } } 上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。 一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。 下面是一些用法的示例。 (new Functor(2)).map(function (two) { return two + 2; }); // Functor(4) (new Functor('flamethrowers')).map(function(s) { return s.toUpperCase(); }); // Functor('FLAMETHROWERS') (new Functor('bombs')).map(_.concat(' away')).map(_.prop('length')); // Functor(10) 上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。 ==因此，学习函数式编程，实际上就是学习函子的各种运算==。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。 四、of 方法 新的函子的时候，用了new命令。这实在==太不像==函数式编程了，因为new命令是面向对象编程的标志。 函数式编程一般约定，函子有一个of方法，用来生成新的容器。 下面就用of方法替换掉new。 Functor.of = function(val) { return new Functor(val); }; 然后，前面的例子就可以改成下面这样。 Functor.of(2).map(function (two) { return two + 2; }); // Functor(4) 这就更像函数式编程了。 五、Maybe 函子 函子接受各种函数，处理容器内部的值。==这里就有一个问题，容器内部的值可能是一个空值（比如null）==，而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。 Functor.of(null).map(function (s) { return s.toUpperCase(); }); // TypeError 上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。 Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查 class Maybe extends Functor { map(f) { return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); } } 有了 Maybe 函子，处理空值就不会出错了。 Maybe.of(null).map(function (s) { return s.toUpperCase(); }); // M 六、Either 函子 条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。 Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。 class Either extends Functor { constructor(left, right) { this.left = left; this.right = right; } map(f) { return this.right ? Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right); } } Either.of = function (left, right) { return new Either(left, right); }; 下面是用法。 var addOne = function (x) { return x + 1; }; Either.of(5, 6).map(addOne); // Either(5, 7); Either.of(1, null).map(addOne); // Either(2, null); 上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。 Either 函子的常见用途是提供默认值。下面是一个例子。 Either.of({address: 'xxx'}, currentUser.address).map(updateField); 上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。 Either 函子的另一个用途是代替try...catch，使用左值表示错误。 function parseJSON(json) { try { return Either.of(null, JSON.parse(json)); } catch (e: Error) { return Either.of(e, null); } } 上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象e。一般来说，所有可能出错的运算，都可以返回一个 Either 函子 七、ap 函子 函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。 function addTwo(x) { return x + 2; } const A = Functor.of(2); const B = Functor.of(addTwo) 上面代码中，函子A内部的值是2，函子B内部的值是函数addTwo。 有时，我们想==让函子B内部的函数，可以使用函子A内部的值进行运算==。这时就需要用到 ap 函子。 ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。 class Ap extends Functor { ap(F) { return Ap.of(this.val(F.val)); } } ==注意，ap方法的参数不是函数==，而是另一个函子。 因此，前面例子可以写成下面的形式。 Ap.of(addTwo).ap(Functor.of(2)) // Ap(4) ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。 function add(x) { return function (y) { return x + y; }; } Ap.of(add).ap(Maybe.of(2)).ap(Maybe.of(3)); // Ap(5) 上面代码中，函数add是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。 Ap.of(add(2)).ap(Maybe.of(3)); 八、Monad 函子 函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。 Maybe.of( Maybe.of( Maybe.of({name: 'Mulburry', number: 8402}) ) ) 上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。 ==Monad 函子的作用是，总是返回一个单层的函子==。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。 class Monad extends Functor { join() { return this.val; } flatMap(f) { return this.map(f).join(); } } 上面代码中，如果函数f返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，==join方法保证了flatMap方法总是返回一个单层的函子==。这意味着嵌套的函子会被铺平（flatten）。 九、IO 操作 Monad 函子的重要应用，就是实现 I/O （输入输出）操作。 I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成Monad函子，通过它来完成。 var fs = require('fs'); var readFile = function(filename) { return new IO(function() { return fs.readFileSync(filename, 'utf-8'); }); }; var print = function(x) { return new IO(function() { console.log(x); return x; }); } 上面代码中，读取文件和打印本身都是不纯的操作，但是readFile和print却是纯函数，因为它们总是返回 IO 函子。 如果 IO 函子是一个Monad，具有flatMap方法，那么我们就可以像下面这样调用这两个函数。 readFile('./user.txt') .flatMap(print) 这就是神奇的地方，上面的代码完成了不纯的操作，但是因为flatMap返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。 由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，flatMap方法被改名成chain。 var tail = function(x) { return new IO(function() { return x[x.length - 1]; }); } readFile('./user.txt') .flatMap(tail) .flatMap(print) // 等同于 readFile('./user.txt') .chain(tail) .chain(print) 上面代码读取了文件user.txt，然后选取最后一行输出。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-11 10:51:21 "},"Javascript/判断数据类型.html":{"url":"Javascript/判断数据类型.html","title":"判断数据类型 ✔","keywords":"","body":"使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下： 1.判断基本类型： Object.prototype.toString.call(null);//”[object Null]” Object.prototype.toString.call(undefined);//”[object Undefined]” Object.prototype.toString.call(“abc”);//”[object String]” Object.prototype.toString.call(123);//”[object Number]” Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型： 函数类型 Function fn(){console.log(“test”);} Object.prototype.toString.call(fn);//”[object Function]” 日期类型 var date = new Date(); Object.prototype.toString.call(date);//”[object Date]” 数组类型 var arr = [1,2,3]; Object.prototype.toString.call(arr);//”[object Array]” 正则表达式 var reg = /[hbc]at/gi; Object.prototype.toString.call(arr);//”[object Array]” 自定义类型 function Person(name, age) { this.name = name; this.age = age; } var person = new Person(\"Rose\", 18); Object.prototype.toString.call(arr); //”[object Object]” 很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： console.log(person instanceof Person);//输出结果为true instanceof 操作符 通俗理解就是沿着A的原型链能不能找到B 3.判断原生JSON对象： var isNativeJSON = window.JSON && Object.prototype.toString.call(JSON); console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 注意：Object.prototype.toString()本身是允许被修改的，而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-10 10:26:57 "},"Javascript/事件绑定、事件监听、事件委托（事件代理）.html":{"url":"Javascript/事件绑定、事件监听、事件委托（事件代理）.html","title":"事件绑定、事件监听、事件委托（事件代理） ✔","keywords":"","body":"事件绑定、事件监听、事件委托（事件代理）(http://www.jb51.net/article/93752.htm) 事件绑定 要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。 在JavaScript中，有三种常用的绑定事件的方法： 在DOM元素中直接绑定； 在JavaScript代码中绑定； 绑定事件监听函数。 在DOM中直接绑定事件 我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看， DOM事件 。 function hello(){ alert(\"hello world!\"); } function hello(){ alert(\"hello world!\"); } 在JavaScript代码中绑定事件 在JavaScript代码中（即 script 标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 document.getElementById(\"btn\").onclick = function(){ alert(\"hello world!\"); } 使用事件监听绑定事件 绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。 事件监听 关于事件监听，W3C规范中定义了3个事件阶段，依次是 捕获阶段 目标阶段 冒泡阶段。 起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为 捕获阶段 目标阶段 冒泡阶段 IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。 W3C规范 语法： element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有 DOM事件 。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 注：IE8以下不支持。 document.getElementById(\"btn1\").addEventListener(\"click\",hello); function hello(){ alert(\"hello world!\"); } IE标准 语法： element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数。 document.getElementById(\"btn2\").attachEvent(\"onclick\",hello); function hello(){ alert(\"hello world!\"); } 重点理论： target: 触发事件的元素。 触发事件的某个具体对象，只会出现在事件流的目标阶段（谁触发谁命中，所以肯定是目标阶段） currentTarget:事件绑定的元素。 绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中 事件委托的情况下两者不一样 通常情况下terget和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系 那就是在父子嵌套(事件委托)的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象，如下代码和截图所示： 单击子元素 one.addEventListener('click',function(e){ console.log(e.target); //three console.log(e.currentTarget); //one },false); 事件监听的优点 1、可以绑定多个事件。 var btn3 = document.getElementById(\"btn3\"); btn3.onclick = function(){ alert(\"hello 1\"); //不执行 } btn3.onclick = function(){ alert(\"hello 2\"); //执行 } 常规的事件绑定只执行最后绑定的事件。 var btn4 = document.getElementById(\"btn4\"); btn4.addEventListener(\"click\",hello1); btn4.addEventListener(\"click\",hello2); function hello1(){ alert(\"hello 1\"); } function hello2(){ alert(\"hello 2\"); } 两个事件都执行了。 2、可以解除相应的绑定 var btn5 = document.getElementById(\"btn5\"); btn5.addEventListener(\"click\",hello1);//执行了 btn5.addEventListener(\"click\",hello2);//不执行 btn5.removeEventListener(\"click\",hello2); function hello1(){ alert(\"hello 1\"); } function hello2(){ alert(\"hello 2\"); } 封装事件监听 绑定监听事件 function addEventHandler(target,type,fn){ if(target.addEventListener){ target.addEventListener(type,fn); }else{ target.attachEvent(\"on\"+type,fn); } } 移除监听事件 function removeEventHandler(target,type,fn){ if(target.removeEventListener){ target.removeEventListener(type,fn); }else{ target.detachEvent(\"on\"+type,fn); } } 测试 var btn5 = document.getElementById(\"btn5\"); addEventHandler(btn5,\"click\",hello1);//添加事件hello1 addEventHandler(btn5,\"click\",hello2);//添加事件hello2 removeEventHandler(btn5,\"click\",hello1);//移除事件hello1 事件委托 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。 var btn6 = document.getElementById(\"btn6\"); document.onclick = function(event){ event = event || window.event; var target = event.target || event.srcElement; if(target == btn6){ alert(btn5.value); } } 上面只是个例子，代码尽可能的简化了。在实际的代码中 我们可能用到jQuery的live()、delegate()、bind()、on()等。 事件委托优点 1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。 实例分析JavaScript中的事件委托和事件绑定 传统写法 item1 item2 item3 var item1 = document.getElementById(\"item1\"); var item2 = document.getElementById(\"item2\"); var item3 = document.getElementById(\"item3\"); item1.onclick = function(){ alert(\"hello item1\"); } item2.onclick = function(){ alert(\"hello item2\"); } item3.onclick = function(){ alert(\"hello item3\"); } 事件委托写法 item1 item2 item3 var item1 = document.getElementById(\"item1\"); var item2 = document.getElementById(\"item2\"); var item3 = document.getElementById(\"item3\"); document.addEventListener(\"click\",function(event){ var target = event.target; if(target == item1){ alert(\"hello item1\"); }else if(target == item2){ alert(\"hello item2\"); }else if(target == item3){ alert(\"hello item3\"); } }) 2、动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。 传统写法 item1 item2 item3 var list = document.getElementById(\"list\"); var item = list.getElementsByTagName(\"li\"); for(var i=0;i 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托写法 item1 item2 item3 var list = document.getElementById(\"list\"); document.addEventListener(\"click\",function(event){ var target = event.target; if(target.nodeName == \"LI\"){ alert(target.innerHTML); } }) var node=document.createElement(\"li\"); var textnode=document.createTextNode(\"item4\"); node.appendChild(textnode); list.appendChild(node); Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-20 15:41:39 "},"Javascript/树形数据扁平化，扁平化数据树形化.html":{"url":"Javascript/树形数据扁平化，扁平化数据树形化.html","title":"树形数据扁平化，扁平化数据树形化 ✔","keywords":"","body":"扁平化数据树形化 ,树形数据扁平化 扁平化数据树形化 var list = [ {\"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, {\"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", },{ \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Children\": [] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\", }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\", }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\" }, { \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\", }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\", }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\", }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\", }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\", }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\", } ] function listChangeTree(data) { // 删除 所有 children,以防止多次调用 data.forEach(function (item) { delete item.child; }); // 将数据存储为 以 id 为 KEY 的 map 索引数据列 let map = {}; data.forEach(function (item) { map[item.Id] = item; }); let val = []; data.forEach(function (item) { // 以当前遍历项，的pid,去map对象中找到索引的id let parent = map[item.PId]; // 如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 if (parent) { (parent.child || (parent.child = [])).push(item); } else { //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级 val.push(item); } }); return val; } listChangeTree(list) 结果得到： [{ \"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Children\": [] }] }] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\" }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\" }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\", \"child\": [{ \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\" }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\" }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\" }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\" }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\" }] }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\" }] }] }] }] 树形数据扁平化 var list = [{ \"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }] }] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\" }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\" }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\", \"child\": [{ \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\" }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\" }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\" }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\" }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\" }] }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }] }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"child\": [{ \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\" }] }] }] }] function formatConversion (parent, child, index = 0, family = [], elderIdentity = 'x') { // child如果长度等于0，则代表已经到了最低层 // let page = (this.startPage - 1) * 10 if (child&&child.length > 0) { child.map((x, i) => { // 设置 __level 标志位 用于展示区分层级 // Vue.set(x, '__level', index) // 设置 __family 为家族关系 为所有父级，包含本身在内 // Vue.set(x, '__family', [...family, elderIdentity + '_' + i]) // 本身的唯一标识 可以理解为个人的身份证咯 一定唯一。 // Vue.set(x, '__identity', elderIdentity + '_' + i) parent.push(x) // 如果仍有子集，则进行递归 if (x.child&&x.child.length > 0) this.formatConversion(parent, x.child, index + 1, [...family, elderIdentity + '_' + i], elderIdentity + '_' + i) }) } return parent } formatConversion([],list) 结果得到： var list = [ {\"Id\": 19, \"Name\": \"App\", \"PId\": null, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, {\"Id\": 1025, \"Name\": \"企业查询\", \"PId\": 19, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1051, \"Name\": \"企业列表\", \"PId\": 1025, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1029, \"Name\": \"企业明细\", \"PId\": 1025, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", },{ \"Id\": 1030, \"Name\": \"投标战绩\", \"PId\": 1025, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1026, \"Name\": \"业绩查询\", \"PId\": 19, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 1031, \"Name\": \"业绩列表\", \"PId\": 1026, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 1032, \"Name\": \"业绩明细\", \"PId\": 1026, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Children\": [] }, { \"Id\": 1, \"Name\": \"后台\", \"PId\": null, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 22, \"Name\": \"首页\", \"PId\": \"1\", \"Order\": 1, \"Class\": \"iconfont icon-home\", }, { \"Id\": 38, \"Name\": \"查询\", \"PId\": \"1\", \"Order\": 3, \"Class\": \"iconfont icon-home\", }, { \"Id\": 2, \"Name\": \"管理\", \"PId\": \"1\", \"Order\": 99, \"Class\": \"iconfont icon-home\" }, { \"Id\": 12, \"Name\": \"用户管理\", \"PId\": 2, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 3, \"Name\": \"用户管理\", \"PId\": 12, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 4, \"Name\": \"添加用户\", \"PId\": 3, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1001\", }, { \"Id\": 5, \"Name\": \"修改用户\", \"PId\": 3, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1002\", }, { \"Id\": 8, \"Name\": \"开启、关闭用户\", \"PId\": 3, \"Order\": 6, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1009\", }, { \"Id\": 9, \"Name\": \"重置密码\", \"PId\": 3, \"Order\": 7, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"2001\", }, { \"Id\": 10, \"Name\": \"导出用户信息\", \"PId\": 3, \"Order\": 8, \"Class\": \"iconfont icon-tuichu\", \"Code\": \"1008\", }, { \"Id\": 39, \"Name\": \"金币管理\", \"PId\": 12, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 40, \"Name\": \"使用量\", \"PId\": 12, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 41, \"Name\": \"业余采集\", \"PId\": 12, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 14, \"Name\": \"相关设置\", \"PId\": 2, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\" }, { \"Id\": 42, \"Name\": \"预测参数管理\", \"PId\": 14, \"Order\": 1, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 43, \"Name\": \"优惠活动\", \"PId\": 14, \"Order\": 2, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 44, \"Name\": \"统计分析\", \"PId\": 14, \"Order\": 3, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 45, \"Name\": \"CA设置\", \"PId\": 14, \"Order\": 4, \"Class\": \"iconfont icon-tuichu\", }, { \"Id\": 46, \"Name\": \"VIP价格\", \"PId\": 14, \"Order\": 5, \"Class\": \"iconfont icon-tuichu\", } ] Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 15:27:26 "},"Javascript/图片上传.html":{"url":"Javascript/图片上传.html","title":"图片上传 ✔","keywords":"","body":"图片上传（https://blog.csdn.net/qq_29712995/article/details/78839093） 安装axios的话： 1利用npm安装npm install axios –save 2使用ES6的写法引入 import axios from 'axios' 我们可能会想，如何使用axios上传照片： 一般情况上传照片有两种方式： 1.本地图片转换成base64，然后通过普通的post请求发送到服务端。操作简单，适合小图，以及如果想兼容低版本的ie没办法用此方法，还有就是最近我想应用到微信小程序中，发现小程序目前还不可以将图片转换为base64. 以下是我的代码 HTML代码： JS代码： var file = document.getElementById(\"upload_file\").files[0]; var r = new FileReader(); //本地预览 r.onload = function(){ console.log(r.result);//图片的base64 } r.readAsDataURL(file); //Base64 2.通过form表单提交。 form表单提交图片会刷新页面，也可以是form绑定到一个隐藏的iframe上，可以实现无刷新提交数据。 HTML代码： JS代码： import axios from 'axios' var file = document.getElementById(\"upload_file\").files[0]; var formdata1=new FormData();// 创建form对象 formdata1.append('img',file,file.name);// 通过append向form对象添加数据,可以通过append继续添加数据 //或formdata1.append('img',file); let config = { headers:{'Content-Type':'multipart/form-data'} }; //添加请求头 axios.post('/xapi/upimage',formdata1,config).then(response)=>{ //这里的/xapi/upimage为接口 console.log(response.data); }) 这里注意的是，设置 的==Content-Type== 查看是否成功：按F12-network-点击对应的那个请求 可以看到 同时上传文本和文件： ``` var formData = new FormData(); formData.append('file', $('#file')[0].files[0]); formData.append('name', $('#name').val()); $.ajax({ url: url, type: 'POST', cache: false, data: formData, processData: false, contentType: false, success: function () { alert(\"文件上传成功！\") }, error: function () { } }); ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-20 16:20:03 "},"Javascript/项目中第一次向数据库连续添加多条数据.html":{"url":"Javascript/项目中第一次向数据库连续添加多条数据.html","title":"项目中第一次向数据库连续添加多条数据 ✔","keywords":"","body":" title: 项目中第一次向数据库连续添加多条数据 categories: \"项目中第一次向数据库连续添加多条数据\" tags: javascript es6 记录 toPing() { if (this.n { if (data.responseCode == \"000000\" || data.responseCode == \"900116\") { console.log(this.pinData[this.n].order_id + '\\n') ++this.n setTimeout(() => { this.toPing() }, 200) // _this.$router.push('/card/success/' + 'submit_pingan'); } else { Toast(\"操作失败\"); } }) .fail(() => { Toast(\"操作失败\"); }); } } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 23:42:41 "},"Javascript/原型和闭包.html":{"url":"Javascript/原型和闭包.html","title":"原型和闭包 ✔","keywords":"","body":"1.一切（引用类型）都是对象，对象是属性的集合。 2.函数和对象的关系 函数就是对象的一种 var fn = function () { }; console.log(fn instanceof Object); // true 函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂 对象可以通过函数来创建,也可以说对象都是通过函数创建的 function Fn() { this.name = '张三'; this.year = 1988; } var fn1 = new Fn(); // var obj = { a: 10, b: 20 }; // var arr = [5, 'x', true]; var obj = new Object(); obj.a = 10; obj.b = 20; var arr = new Array(); arr[0] = 5; arr[1] = 'x'; arr[2] = true; 而其中的 Object 和 Array 都是函数： console.log(typeof (Object)); // function console.log(typeof (Array)); // function 问题来了 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系? 3.prototype原型 函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。 javascript默认的给函数一个属性——prototype。每个函数都有一个属性叫做prototype。 这个prototype的属性值是一个对象（属性的集合，强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。 SuperType是是一个函数，右侧的方框就是它的原型,即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。 那么上图中的“Object prototype”也是一个对象，它的proto指向哪里？ 原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如 有些方法怎么似曾相似？可以在自己自定义的方法的prototype中新增自己的属性 function Fn() { } Fn.prototype.name = '张三'; Fn.prototype.getYear = function () { return 1988; }; 这样就变成了 function Fn() { } Fn.prototype.name = '张三'; Fn.prototype.getYear = function () { return 1988; }; var fn = new Fn(); console.log(fn.name); console.log(fn.getYear()); Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。 因为每个对象都有一个隐藏的属性proto，这个属性引用了创建这个对象的函数的prototype。即：fn._proto **= Fn.prototype 这里的proto_成为“隐式原型”， 4.隐式原型 上节已经提到，每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个proto，可成为隐式原型。 上面图看来，obj.proto和Object.prototype的属性一样！ obj这个对象本质上是被Object函数创建的，因此obj._proto_ = Object.prototype**我们可以用一个图来表示。 即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。 那么上图中的“Object prototype”也是一个对象，它的proto指向哪里？ 在说明“Object prototype”之前，先说一下自定义函数的prototype。**自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.prototype(prototype也是一个对象)**。 但是Object.prototype确实一个特例**——它的proto指向的是null，切记切记！ 函数也是一种对象，函数也有proto吗？ 又一个好问题！——当然有。 函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 且看如下代码。 以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建 根据上面说的一句话——对象的proto指向的是创建它的函数的prototype，就会出现：Object._proto_ **= Function.prototype。用一个图来表示。 很明显的标出了：自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，唉，怎么还有一个……Function.proto指向Function.prototype？这不成了循环引用了？ 对！是一个环形结构。 其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的proto指向了自身的Prototype。 问题：Function.prototype指向的对象，它的proto是不是也指向Object.prototype？ 答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。 5.instanceof 对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。 这个时候就需要用到instanceof。例如： 上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？ instanceof判断的规则根据以上代码看下图： Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的判断规则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 按照以上规则，“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。 通过上以规则，你可以解释很多比较怪异的现象，例如： 这些看似很混乱的东西，答案却都是true，这是为何？ 正好，这里也接上了咱们上一节说的“乱”。 上一节贴了好多的图片，其实那些图片是可以联合成一个整体的，即： 问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？ 重点就这样被这位老朋友给引出来了——继承——原型链。 即，instanceof表示的就是一种继承关系，或者原型链的结构。请看下节分解。 6.继承 继承是通过原型链来体现的 原型链： 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 上图中，访问f1.b时，f1的基本属性中没有b，于是沿着proto找到了Foo.prototype.b。 我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？——hasOwnProperty，特别是在for…in…循环中，一定要注意。 f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？ 好问题。 它是从Object.prototype中来的，请看图： 对象的原型链是沿着proto这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。 由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。 当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。 说一个函数的例子吧。 我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下： 看到了吧，有call、length等这些属性。 那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.proto是否指向Object.prototype。 8简述【执行上下文】上 “执行上下文”（也叫做“执行上下文环境”） 第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。 在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟： 下面还有。先来个简单的。 有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。 与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一 下面还有。。。第三种情况。 在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。 看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。 没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。 好了，“准备工作”介绍完毕。 我们总结一下，在“准备工作”中完成了哪些工作： 1.变量、函数表达式——变量声明，默认赋值为undefined； 2.this——赋值； 3.函数声明——赋值 这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。 细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。 其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。 这里解释一下为什么代码段分为这三种。 所谓“代码段”就是一段文本形式的代码。 首先，全局代码是一种，这个应该没有非议，本来就是手写文本到标签里面的。 其次，eval代码接收的也是一段文本形式的代码。 最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 00:08:35 "},"Javascript/指数化退避.html":{"url":"Javascript/指数化退避.html","title":"指数化退避 ✔","keywords":"","body":" 指数化退避是一种失败后重试 API 的技巧，它会在每次连续的失败之后让重试时间逐渐变长，超过最大重试次数之后就会彻底放弃。 如果使用承诺和其它跟踪 AJAX 调用的方法会非常复杂，而使用可观察对象，这非常简单： ``` import { pipe, range, timer, zip } from 'rxjs'; import { ajax } from 'rxjs/ajax'; import { retryWhen, map, mergeMap } from 'rxjs/operators'; function backoff(maxTries, ms) { return pipe( retryWhen(attempts => range(1, maxTries) .pipe( zip(attempts, (i) => i), map(i => i i), mergeMap(i => timer(i ms)) ) ) ); } ajax('/api/endpoint') .pipe(backoff(3, 250)) .subscribe(data => handleData(data)); function handleData(data) { // ... } ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 23:42:41 "},"Javascript/前端模块化：AMD、CMD、ES6、CommonJS.html":{"url":"Javascript/前端模块化：AMD、CMD、ES6、CommonJS.html","title":"前端模块化：AMD、CMD、ES6、CommonJS ✔","keywords":"","body":"1、CommonJs Nodejs是Commonjs的主要实践者，它有四个重要的环境变量为模块化提供支持。module、export、require、global。在实际的使用中，使用module.exports定义当前模块对外输出接口，用require加载模块。 // 定义模块math.js var basicNum = 0; function add(a, b) { return a + b; } module.exports = { //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum } // 引用自定义的模块时，参数包含路径，可省略.js var math = require('./math'); math.add(2, 5); // 引用核心模块时，不需要带路径 var http = require('http'); http.createService(...).listen(3000); Commonjs采用同步的方式进行加载模块，在服务端，模块文件存储在本地磁盘，读取很快，所以这样是不会有问题的，但是在浏览器中，由于网络等原因，更合理的方法是使用异步加载的方法。 2、AMD和require.js AMD采用异步的模块加载机制，它的加载不影响后面文件的加载，所有依赖这个模块的语句都放在一个回调函数里面，等到所有都加载完成，才执行这个回调函数，AMD是在require.js(原理：jsonp异步加载模块，执行回调)推广过程的产物，推崇依赖前置，提前执行。即使没有用到的模块，也提前加载了。requie采用require.config()定义模块路径，define()定义依赖模块，使用require加载模块。 /** 网页中引入require.js及main.js **/ /** main.js 入口文件/主模块 **/ // 首先用config()指定各模块路径和引用名 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", } }); // 执行基本操作 require([\"jquery\",\"underscore\"],function($,_){ // some code here }); 3、CMD和sea.js CMD是另一种模块加载机制，它和AMD很像，不同点在于，AMD采用依赖前置，提前加载，CMD采用依赖就近，延迟执行，CMD是在sea.js推广过程的产物。 /** AMD写法 **/ define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } }); /** CMD写法 **/ define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); } }); /** sea.js **/ // 定义模块 math.js define(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add; }); // 加载模块 seajs.use(['math.js'], function(math){ var sum = math.add(1+2); }); 4、ES6模块系统 ES6在语言标准层面上，实现了模块功能，意在实现服务器端和浏览器端统一的模块解决方法，ES6的模块系统，主要右两个命令组成，export和import，export规范对外的接口，import引用其他模块功能。ES6模块不是对象，import命令背会javaScript引擎静态分享，在编译时引用模块，而不是在运行时。 /** 定义模块 math.js **/ var basicNum = 0; var add = function (a, b) { return a + b; }; export { basicNum, add }; /** 引用模块 **/ import { basicNum, add } from './math'; function test(ele) { ele.textContent = add(99 + basicNum); } 5、ES6模块系统和Commonjs的差异 ES6模块系统输出的是值得引用，而Commonjs输出的是值的拷贝。 Commonjs输出的是值得拷贝。一旦输出，模块内部的变化将不会影响到这个输出值。 ES6模块系统，是javaScript引擎的静态分析，使用import引用产生一个引用，在真正加载到这个引用的时候才会去模块里面加载值。 ES6模块系统是编译时输出接口，Commonjs是在加载时输出。 运行时加载：Commonjs是一个对象，即在输入时先加载整个模块，生成一个对象，然后在从这个对象读取方法。 编译时加载：ES6模块系统不是对象，而是通过export显示的输出指定的代码。import时采用静态命令形式。记在import可以指定某个输出值，而不是整个文件。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-13 21:07:11 "},"Javascript/JavaScript常用数组操作方法，包含ES6方法.html":{"url":"Javascript/JavaScript常用数组操作方法，包含ES6方法.html","title":"JavaScript常用数组操作方法，包含ES6方法 ✔","keywords":"","body":" title: JavaScript常用数组操作方法，包含ES6方法 categories: \"JavaScript常用数组操作方法，包含ES6方法\" tags: javascript es6 一、concat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。 var arr1 = [1,2,3]; var arr2 = [4,5]; var arr3 = arr1.concat(arr2); console.log(arr1); //[1, 2, 3] console.log(arr3); //[1, 2, 3, 4, 5] 二、join() join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用','号分割，不改变原数组。 var arr = [2,3,4]; console.log(arr.join()); //2,3,4 console.log(arr); //[2, 3, 4] 三、push() push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。 var a = [2,3,4]; var b = a.push(5); console.log(a); //[2,3,4,5] console.log(b); //4 push方法可以一次添加多个元素push(data1,data2....) 四、pop() pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。 var arr = [2,3,4]; console.log(arr.pop()); //4 console.log(arr); //[2,3] 五、shift() shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。 var arr = [2,3,4]; console.log(arr.shift()); //2 console.log(arr); //[3,4] 六、unshift() unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。 var arr = [2,3,4,5]; console.log(arr.unshift(3,6)); //6 console.log(arr); //[3, 6, 2, 3, 4, 5] tip:该方法可以不传参数,不传参数就是不增加元素。 七、slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组。 var arr = [2,3,4,5]; console.log(arr.slice(1,3)); //[3,4] console.log(arr); //[2,3,4,5] 八、splice() splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。 var a = [5,6,7,8]; console.log(a.splice(1,0,9)); //[] console.log(a); // [5, 9, 6, 7, 8] var b = [5,6,7,8]; console.log(b.splice(1,2,3)); //[6, 7] console.log(b); //[5, 3, 8] 九、substring() 和 substr() 相同点：如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。 substr(startIndex); substring(startIndex); var str = '123456789'; console.log(str.substr(2)); // \"3456789\" console.log(str.substring(2)) ;// \"3456789\" 不同点：第二个参数 substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）； substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）。 console.log(\"123456789\".substr(2,5)); // \"34567\" console.log(\"123456789\".substring(2,5)) ;// \"345\" 十、sort 排序 按照 Unicode code 位置排序，默认升序 var fruit = ['cherries', 'apples', 'bananas']; fruit.sort(); // ['apples', 'bananas', 'cherries'] var scores = [1, 10, 21, 2]; scores.sort(); // [1, 10, 2, 21] 十一、reverse() reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组。 var arr = [2,3,4]; console.log(arr.reverse()); //[4, 3, 2] console.log(arr); //[4, 3, 2] 十二、indexOf 和 lastIndexOf 都接受两个参数：查找的值、查找起始位置 不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。 indexOf var a = [2, 9, 9]; a.indexOf(2); // 0 a.indexOf(7); // -1 if (a.indexOf(7) === -1) { // element doesn't exist in array } lastIndexOf var numbers = [2, 5, 9, 2]; numbers.lastIndexOf(2); // 3 numbers.lastIndexOf(7); // -1 numbers.lastIndexOf(2, 3); // 3 numbers.lastIndexOf(2, 2); // 0 numbers.lastIndexOf(2, -2); // 0 numbers.lastIndexOf(2, -1); // 3 十三、every 对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true function isBigEnough(element, index, array) { return element 十四、some 对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true function compare(element, index, array) { return element > 10; } [2, 5, 8, 1, 4].some(compare); // false [12, 5, 8, 1, 4].some(compare); // true 十五、filter 对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组 var words = [\"spray\", \"limit\", \"elite\", \"exuberant\", \"destruction\", \"present\", \"happy\"]; var longWords = words.filter(function(word){ return word.length > 6; }); // Filtered array longWords is [\"exuberant\", \"destruction\", \"present\"] 十六、map 对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组 var numbers = [1, 5, 10, 15]; var doubles = numbers.map(function(x) { return x * 2; }); // doubles is now [2, 10, 20, 30] // numbers is still [1, 5, 10, 15] 十七、forEach 数组遍历 const items = ['item1', 'item2', 'item3']; const copy = []; items.forEach(function(item){ copy.push(item) }); ES6新增新操作数组的方法 1、find()： 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。 const arr = [1, \"2\", 3, 3, \"2\"] console.log(arr.find(n => typeof n === \"number\")) // 1 2、findIndex()： 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。 const arr = [1, \"2\", 3, 3, \"2\"] console.log(arr.findIndex(n => typeof n === \"number\")) // 0 3、fill()： 用新元素替换掉数组内的元素，可以指定替换下标范围。 arr.fill(value, start, end) 4、copyWithin()： 选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。 arr.copyWithin(target, start, end) const arr = [1, 2, 3, 4, 5] console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2 const arr1 = [1, 2, 3, 4, 5] console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3 const arr2 = [1, 2, 3, 4, 5] console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2 5、from 将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组 const bar = [\"a\", \"b\", \"c\"]; Array.from(bar); // [\"a\", \"b\", \"c\"] Array.from('foo'); // [\"f\", \"o\", \"o\"] 6、of 用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3] Array(7); // [ , , , , , , ] Array(1, 2, 3); // [1, 2, 3] 7、entries() 返回迭代器：返回键值对 //数组 const arr = ['a', 'b', 'c']; for(let v of arr.entries()) { console.log(v) } // [0, 'a'] [1, 'b'] [2, 'c'] //Set const arr = new Set(['a', 'b', 'c']); for(let v of arr.entries()) { console.log(v) } // ['a', 'a'] ['b', 'b'] ['c', 'c'] //Map const arr = new Map(); arr.set('a', 'a'); arr.set('b', 'b'); for(let v of arr.entries()) { console.log(v) } // ['a', 'a'] ['b', 'b'] 8、values() 返回迭代器：返回键值对的value //数组 const arr = ['a', 'b', 'c']; for(let v of arr.values()) { console.log(v) } //'a' 'b' 'c' //Set const arr = new Set(['a', 'b', 'c']); for(let v of arr.values()) { console.log(v) } // 'a' 'b' 'c' //Map const arr = new Map(); arr.set('a', 'a'); arr.set('b', 'b'); for(let v of arr.values()) { console.log(v) } // 'a' 'b' 9、keys() 返回迭代器：返回键值对的key //数组 const arr = ['a', 'b', 'c']; for(let v of arr.keys()) { console.log(v) } // 0 1 2 //Set const arr = new Set(['a', 'b', 'c']); for(let v of arr.keys()) { console.log(v) } // 'a' 'b' 'c' //Map const arr = new Map(); arr.set('a', 'a'); arr.set('b', 'b'); for(let v of arr.keys()) { console.log(v) } // 'a' 'b' 10、includes 判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。 var a = [1, 2, 3]; a.includes(2); // true a.includes(4); // false 出自(https://segmentfault.com/a/1190000016503330) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-13 23:42:41 "},"Javascript/js坑点.html":{"url":"Javascript/js坑点.html","title":"js坑点 ✘","keywords":"","body":"精度丢失问题 1. 两个简单的浮点数相加 0.1 + 0.2 != 0.3 // 0.30000000000000004 2. 大整数运算 var x = 9007199254740992 x + 1 == x // ？ // 9007199254740992 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992,大于 9007199254740992 的可能会丢失精度 3. toFixed 不会四舍五入（Chrome） 1.335.toFixed(2) // 1.33 // toFixed 修复 function toFixed(num, s) { var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des + '' } 解决方案 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。如果是id和后台商量好用String 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）// 0.1 + 0.2 (0.1*10 + 0.2*10) / 10 == 0.3 // true Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:57:59 "},"Javascript/Special/奇技淫巧.html":{"url":"Javascript/Special/奇技淫巧.html","title":"奇技淫巧part1 ✔","keywords":"","body":"tostring() function test(x){ var sum = x; var mod = function(y) { sum = sum * y; return mod; }; mod.toString =function(){ return sum; }; return mod; } console.log(test(2)(3)(4)(5)); | 取整 console.log(0.6|0)//0 console.log(1.1|0)//1 console.log(3.65555|0)//3 console.log(5.99999|0)//5 console.log(-7.777|0)//-7 | 转为数字 typeof(\"99\" | 0 ) \"number 解构 function aa(...bb){ console.log(bb) } aa(\"ryuuo\") VM7013:2 [\"ryuuo\"] ~~常用来取整 ~是按位非，就是每一位取反， ~~常用来取整 比如 ~~10.2323=10 ~~（10/3） = 3 ~~(Math.random() * 10) //4 更多： 是一种利用符号进行的类型转换,转换成数字类型 ~~true == 1 ~~false == 0 ~~\"\" == 0 ~~[] == 0 ~~undefined ==0 ~~!undefined == 1 ~~null == 0 ~~!null == 1 顺序遍历对象的key let obj = { \"十字星D\": 2750000.0, \"悠然农庄\": 2142172.1467, \"阿凡达\": 1000000.0, \"七六项目\": 0.0, \"for\": 1000000.0 } function json2arr(obj) { let arr = JSON.stringify(obj).replace(/^{|}$/g, '').split(',') return arr.map((item) => { return item.split(\":\")[0] }) } console.log(json2arr(obj)) 处理 Stream(词出现的次数) Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。 data事件：下一块数据块已经准备好了。 end事件：整个“数据流”处理完了。 error事件：发生错误。 使用Promise.race()函数，可以判断这三个事件之中哪一个最先发生，只有当data事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个while循环，完成所有数据的读取。 const co = require('co'); const fs = require('fs'); const stream = fs.createReadStream('./les_miserables.txt'); let valjeanCount = 0; co(function*() { while(true) { const res = yield Promise.race([ new Promise(resolve => stream.once('data', resolve)), new Promise(resolve => stream.once('end', resolve)), new Promise((resolve, reject) => stream.once('error', reject)) ]); if (!res) { break; } stream.removeAllListeners('data'); stream.removeAllListeners('end'); stream.removeAllListeners('error'); valjeanCount += (res.toString().match(/valjean/ig) || []).length; } console.log('count:', valjeanCount); // count: 1120 }); 上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用stream.once方法，在data、end、error三个事件上添加一次性回调函数。变量res只有在data事件发生时才有值，然后累加每个数据块之中valjean这个词出现的次数。 使用try...catch结构，实现多次重复尝试。 const superagent = require('superagent'); const NUM_RETRIES = 3; async function test() { let i; for (i = 0; i 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用nrm快速切换npm源 nrm 是一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换： 列表项目 npm cnpm strongloop enropean australia nodejitsu taobao Install sudo npm install -g nrm 如何使用？ 列出可用的源： ➜ ~ nrm ls npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - http://registry.npm.taobao.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ pt ----- http://registry.npmjs.pt/ 切换： nrm use cnpm 增加源： 比如： nrm add npmName http://registry.npm.frp.trmap.cn/ npmName是增加的npm包名（自定义） npmName后边是npm包的地址 删除源： nrm del npmName // 删除名为npmName的包 测试速度： nrm test Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-13 19:41:31 "},"Javascript/typescript/typescript面试题.html":{"url":"Javascript/typescript/typescript面试题.html","title":"typescript面试题 ✔","keywords":"","body":"typescript面试题  1. js项目如何升级为ts？有何影响？  2. tslint都能配置哪些功能？对开发流程有何影响？  3. ts 基础类型都哪些，他们跟js的区别  4. ts为什么会流行？与ECMA新规范的关系？  5. 如何理解接口，泛型? 基础： 什么是TypeScript？ TypeScript是JavaScript的加强版，它给JavaScript添加了可选的静态类型和基于类的面向对象编程，它拓展了JavaScript的语法。 而且TypeScript不存在跟浏览器不兼容的问题，因为在编译时，它产生的都是JavaScript代码。 TypeScript 和 JavaScript 的区别是什么？ Typescript 是 JavaScript 的超集，可以被编译成 JavaScript 代码。 用 JavaScript 编写的合法代码，在 TypeScript 中依然有效。Typescript 是纯面向对象的编程语言，包含类和接口的概念。 程序员可以用它来编写面向对象的服务端或客户端程序，并将它们编译成 JavaScript 代码。 TypeScript 引入了很多面向对象程序设计的特征，包括： interfaces 接口 classes 类 enumerated types 枚举类型 generics 泛型 modules 模块 主要不同点如下： TS 是一种面向对象编程语言，而 JS 是一种脚本语言（尽管 JS 是基于对象的）。 TS 支持可选参数， JS 则不支持该特性。 TS 支持静态类型，JS 不支持。 TS 支持接口，JS 不支持接口。 为什么要用 TypeScript ？ TS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。 作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。 TS 非常流行，被很多业界大佬使用。像 Asana、Circle CI 和 Slack 这些公司都在用 TS。 1. js项目如何升级为ts？有何影响？ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-05 14:16:15 "},"Javascript/typescript/typescript注意的地方.html":{"url":"Javascript/typescript/typescript注意的地方.html","title":"typescript注意的地方 ✔","keywords":"","body":"typescript注意的地方 可以在这里查看编译后的javascript的值 是否使用strictnullcheck 空指针是最常见的bug之一，而通过strictnullcheck TypeScript编译器标志可以在很大程度上避免空指针。因为strictnullcheck标志在TypeScript 2时添加的，所以它的使用还没有那么广泛。截至2017年9月，Angular项目和typeORM项目中使用了该标志，而VSCode、RxJS、ionor或Babylon.js都没有使用该标志。此外，新建一个TypeScript项目时strictnullcheck并不默认开启，以保证向后兼容，并保持TypeScript是JavaScript的超集。 如果你准备编写一个新TypeScript项目，或者有时间将strictnullcheck标志引入到现有的项目中，我建议你这样做。你的应用会因此具备更高的安全性，使用严格的null检查也不会打乱代码，因应用程序本应包含这些检查。缺点是新开发人员还需要学习一个概念。对我来说，利大于弊，所以我建议打开严格的空检查。 严格的空检查的一个例子是: tsconfig.json { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es5\", \"noImplicitAny\": true, \"strictNullChecks\": true, \"outDir\": \"./dist\" }, \"include\": [ \"src/**/*\" ] } src/user.ts interface User { name: string; age?: number; } function printUserInfo(user: User) { console.log(`${user.name}, ${user.age.toString()}`) // => error TS2532: Object is possibly 'undefined'. console.log(`${user.name}, ${user.age!.toString()}`) // => OK, you confirm that you're sure user.age is non-null. // => 好的，你已经确认user.age是非空的。 if (user.age != null) { console.log(`${user.name}, ${user.age.toString()}`) } // => OK, the if-condition checked that user.age is non-null. // => 好的，if条件检查了user.age是非空的。 console.log(user.name + ', ' + user.age != null ? user.age.toString() : 'age unknown'); // => Unfortunately TypeScript can't infer that age is non-null here. // => 不幸的是TypeScript不能在这里推断年龄是非空的。(译注：截止至2019年7月16日，TS依旧会报此错) } 如上所述： 感叹号表示你确信(例如，通过在代码中的某个地方执行检查)可能为空的变量实际上是非空的。 如果执行If条件检查, TypeScript可以推断某些内容是非空的。 然而，对于三元运算符来说，不幸的是情况并非如此。 注意：使用了strictNullChecks，可选参数会被自动地加上 | undefined: function f(x: number, y?: number) { return x + (y || 0); } f(1, 2); f(1); f(1, undefined); f(1, null); // error, 'null' is not assignable to 'number | undefined' 1.基础类型 boolean, number, string, Array, 元组 Tuple, 枚举 enum, Any, Void, Null 和 Undefined, Never,Object(object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型), 类型断言 数组 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： let list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array： let list: Array = [1, 2, 3]; 枚举 ⒈数字枚举 与后端开发约定订单的状态开始是0，未结账是1，运输中是2，运输完成是3，已收货是4。这样的纯数字会使得代码缺乏可读性。枚举就用于这样的场景。 enum OrderStatus{ Start = 1, Unpaid, Shipping, Shipped, Complete, } 当只写Start = 1时，后面的枚举变量就是递增的，当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的，但你也可以明确地写出每个枚举变量的数字，这取决于具体的业务场景。 ⒉字符串枚举 字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。这使得调试变得更容易。所以在实际的开发中，大家更喜欢使用字符串枚举。 字符串枚举的概念与数字枚举有一些细微的差别 在一个字符串枚举中，所有成员必须都是字符串字面量，且字符串枚举没有递增的含义，字符串枚举的成员都必须手动初始化。　 enum OrderStatus{ Start = 'Start', Unpaid = 'Unpaid', Shipping = 'Shipping', Shipped = 'Shipped', Complete = 'Complete', } ⒊异构枚举 枚举可以混合字符串和数字成员(不建议这样做) enum OrderStatus{ Start = 'Start', Unpaid = 1, Shipping, Shipped, Complete, } 4.枚举成员类型和联合枚举类型 枚举的每个成员和枚举本身都可以作为类型来使用(前提是： 一个枚举里所有成员的值都是字面量类型的值) 不带初始值的枚举成员，例如 enum E { A } 值为字符串字面量，例如 enum E { A = 'hello' } 值为数字字面量，或者带有一元 - 符号的数字字面量，例如 enum E { A = 1 }，enum E { A = -1 } 1.枚举成员类型 　　把符合条件的枚举成员作为类型来使用，例子： enum ShapeKind { Circle, Square } interface Circle { kind: ShapeKind.Circle // 使用 ShapeKind.Circle 作为类型，指定接口须有 kind 字段，且类型为 ShapeKind.Circle radius: number } interface Square { kind: ShapeKind.Square // 同上 sideLength: number } let c: Circle = { kind: ShapeKind.Square, // Error! 因为接口 Circle 的 kind 被指定为 ShapeKind.Circle类型，所以这里会报错 radius: 100 } 2.联合枚举类型 　　符合条件的枚举本身可以看作是一个包含所有成员的联合类型，下面例子： // 枚举 Status 里有两个状态 enum Status { Off, On } // 枚举 Animal 里有两个动物 enum Animal { Cat, Dog } // 接口 Light 中定义 status字段，它是 Status 类型，可以是 Off 或者 On 状态 interface Light { status: Status } let lg1: Light = { status: Status.Off // 正确 } let lg2: Light = { status: Animal.Cat // error 不能将类型 Animal.Cat 分配给类型 Status } 5.运行时的枚举 　　枚举是在运行时真正存在的对象，可以把枚举当作对象使用: enum E { A, B } function func(obj: { A: number }): number { return obj.A } console.log(func(E)) // 0 6.反向映射 反向映射是数字枚举的一个技巧，这得益于TypeScript在实现数字枚举时的代码编译。 　　例如当我们设定了如下一个枚举时： enum OrderStatus{ A } 　　TypeScript编译器将这段代码编译到JavaScript时是这样的： var Enum; (function (Enum) { Enum[Enum[\"A\"] = 0] = \"A\"; })(Enum || (Enum = {})); 　　生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ key -> value）和反向映射（ value -> key）。所以我们既可以通过属性名获取属性值，也可以通过属性值获取属性名。 let a = OrderStatus.A; let b = OrderStatus[0]; console.log(a);　　//0 console.log(b);　　//A 　　注意：字符串编译后并没有这样的特性，因此，在字符串枚举中没有反向映射。 7.const 枚举 　　> 定义的枚举，在经过编译器编译后是一个对象，这个对象我们可以在程序运行时使用，前面有说到。但有时定义枚举可能只是为了让程序可读性更好，而不需要编译后的代码，即不需要编译成对象。typescript中考虑到这种情况，所以加入了 const enum (完全嵌入的枚举)。typescript官网有一个在线编译器，来看看下面的例子： enum Status{ Off, On } const enum Animal{ Dog, Cat } const status = Status.On const animal = Animal.Dog 　　这段代码编译成JavaScript后是这样的： var Status; (function (Status) { Status[Status[\"Off\"] = 0] = \"Off\"; Status[Status[\"On\"] = 1] = \"On\"; })(Status || (Status = {})); var status = Status.On; var animal = 0 /* Dog */; 可以看到编译后的代码中并没有像创建Status一样创建了Animal，而是直接把 Animal 中 Dog 值 0 替换到表达式中 Animal.Dog 的位置，这样就节省了生成代码的开销。 Never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。 下面是一些返回never类型的函数： // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } Object object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 使用object类型，就可以更好的表示像Object.create这样的API。例如： declare function create(o: object | null): void; create({ prop: 0 }); // OK create(null); // OK create(42); // Error create(\"string\"); // Error create(false); // Error create(undefined); // Error 类型断言 类型断言（Type Assertion）可以用来手动指定一个值的类型。 语法§ 值 as 类型 或 值 类型断言的用途§ 类型断言的用途§ 类型断言的常见用途有以下几种： 将一个联合类型断言为其中一个类型§ 之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法： interface Cat { name: string; run(): void; } interface Fish { name: string; swim(): void; } function getName(animal: Cat | Fish) { return animal.name; } 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如： interface Cat { name: string; run(): void; } interface Fish { name: string; swim(): void; } function isFish(animal: Cat | Fish) { if (typeof animal.swim === 'function') { return true; } return false; } // index.ts:11:23 - error TS2339: Property 'swim' does not exist on type 'Cat | Fish'. // Property 'swim' does not exist on type 'Cat'. 上面的例子中，获取 animal.swim 的时候会报错。 此时可以使用类型断言，将 animal 断言成 Fish： interface Cat { name: string; run(): void; } interface Fish { name: string; swim(): void; } function isFish(animal: Cat | Fish) { if (typeof (animal as Fish).swim === 'function') { return true; } return false; } 这样就可以解决访问 animal.swim 时报错的问题了。 需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误： interface Cat { name: string; run(): void; } interface Fish { name: string; swim(): void; } function swim(animal: Cat | Fish) { (animal as Fish).swim(); } const tom: Cat = { name: 'Tom', run() { console.log('run') } }; swim(tom); // Uncaught TypeError: animal.swim is not a function` 上面的例子编译时不会报错，但在运行时会报错： Uncaught TypeError: animal.swim is not a function` 原因是 (animal as Fish).swim() 这段代码隐藏了 animal 可能为 Cat 的情况，将 animal 直接断言为 Fish 了，而 TypeScript 编译器信任了我们的断言，故在调用 swim() 时没有编译错误。 可是 swim 函数接受的参数是 Cat | Fish，一旦传入的参数是 Cat 类型的变量，由于 Cat 上没有 swim 方法，就会导致运行时错误了。 总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。 将一个父类断言为更加具体的子类§ 当类之间有继承关系时，类型断言也是很常见的： class ApiError extends Error { code: number = 0; } class HttpError extends Error { statusCode: number = 200; } function isApiError(error: Error) { if (typeof (error as ApiError).code === 'number') { return true; } return false; } 上面的例子中，我们声明了函数 isApiError，它用来判断传入的参数是不是 ApiError 类型，为了实现这样一个函数，它的参数的类型肯定得是比较抽象的父类 Error，这样的话这个函数就能接受 Error 或它的子类作为参数了。 但是由于父类 Error 中没有 code 属性，故直接获取 error.code 会报错，需要使用类型断言获取 (error as ApiError).code。 大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 ApiError，那就是使用 instanceof： class ApiError extends Error { code: number = 0; } class HttpError extends Error { statusCode: number = 200; } function isApiError(error: Error) { if (error instanceof ApiError) { return true; } return false; } 上面的例子中，确实使用 instanceof 更加合适，因为 ApiError 是一个 JavaScript 的类，能够通过 instanceof 来判断 error 是否是它的实例。 但是有的情况下 ApiError 和 HttpError 不是一个真正的类，而只是一个 TypeScript 的接口（interface），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 instanceof 来做运行时判断了： interface ApiError extends Error { code: number; } interface HttpError extends Error { statusCode: number; } function isApiError(error: Error) { if (error instanceof ApiError) { return true; } return false; } // index.ts:9:26 - error TS2693: 'ApiError' only refers to a type, but is being used as a value here. 此时就只能用类型断言，通过判断是否存在 code 属性，来判断传入的参数是不是 ApiError 了： interface ApiError extends Error { code: number; } interface HttpError extends Error { statusCode: number; } function isApiError(error: Error) { if (typeof (error as ApiError).code === 'number') { return true; } return false; } 将任何一个类型断言为 any§ 理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。 当我们引用一个在此类型上不存在的属性或方法时，就会报错： const foo: number = 1; foo.length = 1; // index.ts:2:5 - error TS2339: Property 'length' does not exist on type 'number'. 上面的例子中，数字类型的变量 foo 上是没有 length 属性的，故 TypeScript 给出了相应的错误提示。 这种错误提示显然是非常有用的。 但有的时候，我们非常确定这段代码不会出错，比如下面这个例子： window.foo = 1; // index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window & typeof globalThis'. 上面的例子中，我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。 此时我们可以使用 as any 临时将 window 断言为 any 类型： (window as any).foo = 1; 在 any 类型的变量上，访问任何属性都是允许的。 需要注意的是，将一个变量断言为 any 可以说是解决 TypeScript 中类型问题的最后一个手段。 它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any。 上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 foo 属性，as any 会更加方便。 总之，一方面不能滥用 as any，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡（这也是 TypeScript 的设计理念之一），才能发挥出 TypeScript 最大的价值。 将 any 断言为一个具体的类型§ 在日常的开发中，我们不可避免的需要处理 any 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。 遇到 any 类型的变量时，我们可以选择无视它，任由它滋生更多的 any。 我们也可以选择改进它，通过类型断言及时的把 any 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。 举例来说，历史遗留的代码中有个 getCacheData，它的返回值是 any： function getCacheData(key: string): any { return (window as any).cache[key]; } 那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作： function getCacheData(key: string): any { return (window as any).cache[key]; } interface Cat { name: string; run(): void; } const tom = getCacheData('tom') as Cat; tom.run(); 上面的例子中，我们调用完 getCacheData 之后，立即将它断言为 Cat 类型。这样的话明确了 tom 的类型，后续对 tom 的访问时就有了代码补全，提高了代码的可维护性。 类型断言的限制§ 本小结的前置知识点：[结构类型系统（TODO）][]、[类型兼容性（TODO）][] 从上面的例子中，我们可以总结出： 联合类型可以被断言为其中一个类型 父类可以被断言为子类 任何类型都可以被断言为 any any 可以被断言为任何类型 那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？ 答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。 具体来说，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。 下面我们通过一个简化的例子，来理解类型断言的限制： interface Animal { name: string; } interface Cat { name: string; run(): void; } let tom: Cat = { name: 'Tom', run: () => { console.log('run') } }; let animal: Animal = tom; 我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。 在上面的例子中，Cat 包含了 Animal 中的所有属性，除此之外，它还有一个额外的方法 run。TypeScript 并不关心 Cat 和 Animal 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 Cat extends Animal 是等价的： interface Animal { name: string; } interface Cat extends Animal { run(): void; } 那么也不难理解为什么 Cat 类型的 tom 可以赋值给 Animal 类型的 animal 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。 我们把它换成 TypeScript 中更专业的说法，即：Animal 兼容 Cat。 当 Animal 兼容 Cat 时，它们就可以互相进行类型断言了： interface Animal { name: string; } interface Cat { name: string; run(): void; } function testAnimal(animal: Animal) { return (animal as Cat); } function testCat(cat: Cat) { return (cat as Animal); } 这样的设计其实也很容易就能理解： 允许 animal as Cat 是因为「父类可以被断言为子类」，这个前面已经学习过了 允许 cat as Animal 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」 需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。 总之，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。 同理，若 B 兼容 A，那么 A 能够被断言为 B，B 也能被断言为 A。 所以这也可以换一种说法： 要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。 综上所述： 联合类型可以被断言为其中一个类型 父类可以被断言为子类 任何类型都可以被断言为 any any 可以被断言为任何类型 要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可 其实前四种情况都是最后一个的特例。 双重断言§ 既然： 任何类型都可以被断言为 any any 可以被断言为任何类型 那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？ interface Cat { run(): void; } interface Fish { swim(): void; } function testCat(cat: Cat) { return (cat as any as Fish); } 在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。 但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。 若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。 注意：除非迫不得已，千万别用双重断言。 类型断言 vs 类型转换§ 类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除： function toBoolean(something: any): boolean { return something as boolean; } toBoolean(1); // 返回值为 1 在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成： function toBoolean(something) { return something; } toBoolean(1); // 返回值为 1 所以类型断言不是类型转换，它不会真的影响到变量的类型。 若要进行类型转换，需要直接调用类型转换的方法： function toBoolean(something: any): boolean { return Boolean(something); } toBoolean(1); // 返回值为 true 类型断言 vs 类型声明§ 在这个例子中： function getCacheData(key: string): any { return (window as any).cache[key]; } interface Cat { name: string; run(): void; } const tom = getCacheData('tom') as Cat; tom.run(); 我们使用 as Cat 将 any 类型断言为了 Cat 类型。 但实际上还有其他方式可以解决这个问题： function getCacheData(key: string): any { return (window as any).cache[key]; } interface Cat { name: string; run(): void; } const tom: Cat = getCacheData('tom'); tom.run(); 上面的例子中，我们通过类型声明的方式，将 tom 声明为 Cat，然后再将 any 类型的 getCacheData('tom') 赋值给 Cat 类型的 tom。 这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 Cat 类型。 它们的区别，可以通过这个例子来理解： interface Animal { name: string; } interface Cat { name: string; run(): void; } const animal: Animal = { name: 'tom' }; let tom = animal as Cat; 在上面的例子中，由于 Animal 兼容 Cat，故可以将 animal 断言为 Cat 赋值给 tom。 但是若直接声明 tom 为 Cat 类型： interface Animal { name: string; } interface Cat { name: string; run(): void; } const animal: Animal = { name: 'tom' }; let tom: Cat = animal; // index.ts:12:5 - error TS2741: Property 'run' is missing in type 'Animal' but required in type 'Cat'. 则会报错，不允许将 animal 赋值为 Cat 类型的 tom。 这很容易理解，Animal 可以看作是 Cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。 深入的讲，它们的核心区别就在于： animal 断言为 Cat，只需要满足 Animal 兼容 Cat 或 Cat 兼容 Animal 即可 animal 赋值给 tom，需要满足 Cat 兼容 Animal 才行 但是 Cat 并不兼容 Animal。 而在前一个例子中，由于 getCacheData('tom') 是 any 类型，any 兼容 Cat，Cat 也兼容 any，故 const tom = getCacheData('tom') as Cat; 等价于 const tom: Cat = getCacheData('tom'); 知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。 所以为了增加代码的质量，注意：我们最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。 类型断言 vs 泛型§ 本小结的前置知识点：泛型 还是这个例子： function getCacheData(key: string): any { return (window as any).cache[key]; } interface Cat { name: string; run(): void; } const tom = getCacheData('tom') as Cat; tom.run(); 我们还有第三种方式可以解决这个问题，那就是泛型： function getCacheData(key: string): T { return (window as any).cache[key]; } interface Cat { name: string; run(): void; } const tom = getCacheData('tom'); tom.run(); 通过给 getCacheData 函数添加了一个泛型 ，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。 接口 作用 对值所具有的结构进行类型检查,接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约（对「对象的形状（Shape）」进行描述。）。 比如： interface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 }; 上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。 对类的一部分行为进行抽象（有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。） 比如： 门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： interface Alarm { alert(): void; } class Door { } class SecurityDoor extends Door implements Alarm { alert() { console.log('SecurityDoor alert'); } } class Car implements Alarm { alert() { console.log('Car alert'); } } 接口是如何工作的? function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label); } let myObj = { size: 10, label: \"Size 10 Object\" }; printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。 下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string： interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \"Size 10 Object\"}; printLabel(myObj); LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。 还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 可选属性 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { let newSquare = {color: \"white\", area: 100}; if (config.clor) { // Error: Property 'clor' does not exist on type 'SquareConfig' newSquare.color = config.clor; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: \"black\"}); 只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性: interface Point { readonly x: number; readonly y: number; } 你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。 let p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： a = ro as number[]; readonly vs const 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 额外的属性检查 我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。 然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { // ... } let mySquare = createSquare({ colour: \"red\", width: 100 }); 注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。 然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 // error: 'colour' not expected in type 'SquareConfig' let mySquare = createSquare({ colour: \"red\", width: 100 }); 绕开这些检查非常简单。 最简便的方法是使用类型断言： let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 然而，最佳的方式是能够添加一个字符串**索引签名((，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它： interface SquareConfig { color?: string; width?: number; [propName: string]: any; } 在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。 let squareOptions = { colour: \"red\", width: 100 }; let mySquare = createSquare(squareOptions); 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。 函数类型 接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean; } 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result > -1; } 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子： let mySearch: SearchFunc; mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result > -1; } 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。 let mySearch: SearchFunc; mySearch = function(src, sub) { let result = src.search(sub); return result > -1; } 可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [\"Bob\", \"Fred\"]; let myStr: string = myArray[0]; 上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。 TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用\"100\"（一个string）去索引，因此两者需要保持一致。 class Animal { name: string; } class Dog extends Animal { breed: string; } // 错误：使用数值型的字符串索引，有时会得到完全不同的Animal! interface NotOkay { [x: number]: Animal; [x: string]: Dog; } 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[\"property\"]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配 } 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值： interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"]; myArray[2] = \"Mallory\"; // error! 你不能设置myArray[2]，因为索引签名是只读的。 类类型 实现接口 与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 interface ClockInterface { currentTime: Date; } class Clock implements ClockInterface { currentTime: Date; constructor(h: number, m: number) { } } 你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样： interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别 当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： interface ClockConstructor { new (hour: number, minute: number); } class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) { } } // error Class 'Clock' incorrectly implements interface 'ClockConstructor'. Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'. 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。 interface ClockConstructor { new (hour: number, minute: number): ClockInterface; } interface ClockInterface { tick(); } function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute); } class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"beep beep\"); } } class AnalogClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"tick tock\"); } } let digital = createClock(DigitalClock, 12, 17); let analog = createClock(AnalogClock, 7, 32); 因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。 继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 interface Shape { color: string; } interface Square extends Shape { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; square.penWidth = 5.0; 混合类型 先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; 在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例： class Control { private state: any; } interface SelectableControl extends Control { select(): void; } class Button extends Control implements SelectableControl { select() { } } class TextBox extends Control { select() { } } // 错误：“Image”类型缺少“state”属性。 class Image implements SelectableControl { select() { } } class Location { } 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。 为什么 TypeScript 会支持接口继承类呢？常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的 类 公共，私有与受保护的修饰符 默认为 public 在TypeScript里，成员都默认为 public。 你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来写的 Animal类： class Animal { public name: string; public constructor(theName: string) { this.name = theName; } public move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } 理解 private 当成员被标记成 private时，它就不能在声明它的类的外部访问。比如： class Animal { private name: string; constructor(theName: string) { this.name = theName; } } new Animal(\"Cat\").name; // 错误: 'name' 是私有的. TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。 下面来看一个例子，更好地说明了这一点： class Animal { private name: string; constructor(theName: string) { this.name = theName; } } class Rhino extends Animal { constructor() { super(\"Rhino\"); } } class Employee { private name: string; constructor(theName: string) { this.name = theName; } } let animal = new Animal(\"Goat\"); let rhino = new Rhino(); let employee = new Employee(\"Bob\"); animal = rhino; animal = employee; // 错误: Animal 与 Employee 不兼容. 这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。 理解 protected protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如： class Person { protected name: string; constructor(name: string) { this.name = name; } } class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(\"Howard\", \"Sales\"); console.log(howard.getElevatorPitch()); console.log(howard.name); // 错误 注意，我们不能在 Person类外使用 name，但是我们仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如， class Person { protected name: string; protected constructor(theName: string) { this.name = theName; } } // Employee 能够继承 Person class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(\"Howard\", \"Sales\"); let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的. readonly修饰符 你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; } } let dad = new Octopus(\"Man with the 8 strong legs\"); dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 参数属性 在上面的例子中，我们必须在Octopus类里定义一个只读成员 name和一个参数为 theName的构造函数，并且立刻将 theName的值赋给 name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性： class Octopus { readonly numberOfLegs: number = 8; constructor(readonly name: string) { } } 注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。 参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。 存取器 TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。 class Employee { fullName: string; } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { console.log(employee.fullName); } 我们可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。 下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。 let passcode = \"secret passcode\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode && passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { alert(employee.fullName); } 我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。 对于存取器有下面几点需要注意的： 首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性 到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。 class Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } let grid1 = new Grid(1.0); // 1x scale let grid2 = new Grid(5.0); // 5x scale console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 抽象类 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。 abstract class Animal { abstract makeSound(): void; move(): void { console.log('roaming the earch...'); } } 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。 abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); } } let department: Department; // 允许创建一个对抽象类型的引用 department = new Department(); // 错误: 不能创建一个抽象类的实例 department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧 构造函数 当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 实例的类型。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter: Greeter; greeter = new Greeter(\"world\"); console.log(greeter.greet()); 这里，我们写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。 我们也创建了一个叫做 构造函数的值。 这个函数会在我们使用 new创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的： let Greeter = (function () { function Greeter(message) { this.greeting = message; } Greeter.prototype.greet = function () { return \"Hello, \" + this.greeting; }; return Greeter; })(); let greeter; greeter = new Greeter(\"world\"); console.log(greeter.greet()); 上面的代码里， let Greeter将被赋值为构造函数。 当我们调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有 实例部分与 静态部分这两个部分。 让我们稍微改写一下这个例子，看看它们之间的区别： class Greeter { static standardGreeting = \"Hello, there\"; greeting: string; greet() { if (this.greeting) { return \"Hello, \" + this.greeting; } else { return Greeter.standardGreeting; } } } let greeter1: Greeter; greeter1 = new Greeter(); console.log(greeter1.greet()); let greeterMaker: typeof Greeter = Greeter; greeterMaker.standardGreeting = \"Hey there!\"; let greeter2: Greeter = new greeterMaker(); console.log(greeter2.greet()); 这个例子里， greeter1与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。 再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，\"告诉我 Greeter标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。 把类当做接口使用 如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 class Point { x: number; y: number; } interface Point3d extends Point { z: number; } let point3d: Point3d = {x: 1, y: 2, z: 3}; 函数 函数是 JavaScript 中的一等公民 函数声明 在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）： // 函数声明（Function Declaration） function sum(x, y) { return x + y; } // 函数表达式（Function Expression） let mySum = function (x, y) { return x + y; }; 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单： function sum(x: number, y: number): number { return x + y; } 注意，输入多余的（或者少于要求的）参数，是不被允许的： function sum(x: number, y: number): number { return x + y; } sum(1, 2, 3); // index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target. function sum(x: number, y: number): number { return x + y; } sum(1); // index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target. 函数表达式§ 如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样： let mySum = function (x: number, y: number): number { return x + y; }; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。注意：如果需要我们手动给 mySum 添加类型，则应该是这样： let mySum: (x: number, y: number) => number = function (x: number, y: number): number { return x + y; }; 注意不要混淆了 TypeScript 中的 => 和 ES6 中的 =>。 在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 在 ES6 中，=> 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。 用接口定义函数的形状§ 我们也可以使用接口的方式来定义一个函数需要符合的形状： interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { return source.search(subString) !== -1; } 采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。 可选参数§ 前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + ' ' + lastName; } else { return firstName; } } let tomcat = buildName('Tom', 'Cat'); let tom = buildName('Tom'); 需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了： function buildName(firstName?: string, lastName: string) { if (firstName) { return firstName + ' ' + lastName; } else { return lastName; } } let tomcat = buildName('Tom', 'Cat'); let tom = buildName(undefined, 'Tom'); // index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter. 参数默认值§ 在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： function buildName(firstName: string, lastName: string = 'Cat') { return firstName + ' ' + lastName; } let tomcat = buildName('Tom', 'Cat'); let tom = buildName('Tom'); 此时就不受「可选参数必须接在必需参数后面」的限制了： function buildName(firstName: string = 'Tom', lastName: string) { return firstName + ' ' + lastName; } let tomcat = buildName('Tom', 'Cat'); let cat = buildName(undefined, 'Cat'); 关于默认参数，可以参考 ES6 中函数参数的默认值。 注意 与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值。 例如，我们重写最后一个例子，让 firstName是带默认值的参数： function buildName(firstName = \"Will\", lastName: string) { return firstName + \" \" + lastName; } let result1 = buildName(\"Bob\"); // error, too few parameters let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters let result3 = buildName(\"Bob\", \"Adams\"); // okay and returns \"Bob Adams\" let result4 = buildName(undefined, \"Adams\"); // okay and returns \"Will Adams\" 剩余参数§ ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）： function push(array, ...items) { items.forEach(function(item) { array.push(item); }); } let a: any[] = []; push(a, 1, 2, 3); 事实上，items 是一个数组。所以我们可以用数组的类型来定义它： function push(array: any[], ...items: any[]) { items.forEach(function(item) { array.push(item); }); } let a = []; push(a, 1, 2, 3); 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 ES6 中的 rest 参数。 this 学习如何在JavaScript里正确使用this就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 this工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 this的地方。 如果你想了解JavaScript里的 this是如何工作的，那么首先阅读Yehuda Katz写的Understanding JavaScript Function Invocation and \"this\"。 Yehuda的文章详细的阐述了 this的内部工作原理，因此我们这里只做简单介绍。 this和箭头函数 JavaScript里，this的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。 下面看一个例子： let deck = { suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() { return function() { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } } } let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。 为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 this值，而不是调用时的值： let deck = { suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() { // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () => { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } } } let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了--noImplicitThis标记。 它会指出 this.suits[pickedSuit]里的this的类型为any。 this参数 不幸的是，this.suits[pickedSuit]的类型依旧为any。 这是因为 this来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this参数。 this参数是个假的参数，它出现在参数列表的最前面： function f(this: void) { // make sure `this` is unusable in this standalone function } 让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些： interface Card { suit: string; card: number; } interface Deck { suits: string[]; cards: number[]; createCardPicker(this: Deck): () => Card; } let deck: Deck = { suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) { return () => { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } } } let cardPicker = deck.createCardPicker(); let pickedCard = cardPicker(); alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此--noImplicitThis不会报错了。 this参数在回调函数里(不太懂) 你可以也看到过在回调函数里的this报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， this将为undefined。 稍做改动，你就可以通过 this参数来避免错误。 首先，库函数的作者要指定 this的类型： interface UIElement { addClickListener(onclick: (this: void, e: Event) => void): void; } this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this: class Handler { info: string; onClickBad(this: Handler, e: Event) { // oops, used this here. using this callback would crash at runtime this.info = e.message; } } let h = new Handler(); uiElement.addClickListener(h.onClickBad); // error! 指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到 addClickListener要求函数带有this: void。 改变 this类型来修复这个错误： class Handler { info: string; onClickGood(this: void, e: Event) { // can't use this here because it's of type void! console.log('clicked!'); } } let h = new Handler(); uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用 this.info. 如果你两者都想要，你不得不使用箭头函数了： class Handler { info: string; onClickGood = (e: Event) => { this.info = e.message } } 这是可行的因为箭头函数不会捕获this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个 Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 Handler的原型链上。 它们在不同 Handler对象间是共享的。 重载 JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。 let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"]; function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; } } let myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }]; let pickedCard1 = myDeck[pickCard(myDeck)]; alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit); let pickedCard2 = pickCard(15); alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); pickCard方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。 方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickCard函数。 let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"]; function pickCard(x: {suit: string; card: number; }[]): number; function pickCard(x: number): {suit: string; card: number; }; function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; } } let myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }]; let pickedCard1 = myDeck[pickCard(myDeck)]; alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit); let pickedCard2 = pickCard(15); alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。 为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 为了考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 简单的例子§ 首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： function createArray(length: number, value: any): Array { let result = []; for (let i = 0; i 上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。 这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型： Array 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。 注意：这时候，泛型就派上用场了： function createArray(length: number, value: T): Array { let result: T[] = []; for (let i = 0; i (3, 'x'); // ['x', 'x', 'x'] 上例中，我们在函数名后添加了 ，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array 中即可使用了。 接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来： function createArray(length: number, value: T): Array { let result: T[] = []; for (let i = 0; i 多个类型参数§ 定义泛型的时候，可以一次定义多个类型参数： function swap(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]]; } swap([7, 'seven']); // ['seven', 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组。 泛型约束§ 在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法： function loggingIdentity(arg: T): T { console.log(arg.length); return arg; } // index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'. 上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。 这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束： interface Lengthwise { length: number; } function loggingIdentity(arg: T): T { console.log(arg.length); return arg; } 上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。 此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了： interface Lengthwise { length: number; } function loggingIdentity(arg: T): T { console.log(arg.length); return arg; } loggingIdentity(7); // index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'. 多个类型参数之间也可以互相约束： function copyFields(target: T, source: U): T { for (let id in source) { target[id] = (source)[id]; } return target; } let x = { a: 1, b: 2, c: 3, d: 4 }; copyFields(x, { b: 10, d: 20 }); 上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口§ 之前学习过，可以使用接口的方式来定义一个函数需要符合的形状： interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { return source.search(subString) !== -1; } 当然也可以使用含有泛型的接口来定义函数的形状： interface CreateArrayFunc { (length: number, value: T): Array; } let createArray: CreateArrayFunc; createArray = function(length: number, value: T): Array { let result: T[] = []; for (let i = 0; i 进一步，我们可以把泛型参数提前到接口名上： interface CreateArrayFunc { (length: number, value: T): Array; } let createArray: CreateArrayFunc; createArray = function(length: number, value: T): Array { let result: T[] = []; for (let i = 0; i 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类§ 与泛型接口类似，泛型也可以用于类的类型定义中： class GenericNumber { zeroValue: T; add: (x: T, y: T) => T; } let myGenericNumber = new GenericNumber(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) { return x + y; }; 泛型参数的默认类型§ 在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 function createArray(length: number, value: T): Array { let result: T[] = []; for (let i = 0; i 在泛型里使用类类型(不太懂 new()) 在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如， function create(c: {new(): T; }): T { return new c(); } 一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。 class BeeKeeper { hasMask: boolean; } class ZooKeeper { nametag: string; } class Animal { numLegs: number; } class Bee extends Animal { keeper: BeeKeeper; } class Lion extends Animal { keeper: ZooKeeper; } function createInstance(c: new () => A): A { return new c(); } createInstance(Lion).keeper.nametag; // typechecks! createInstance(Bee).keeper.hasMask; // typechecks! 类型兼容性 介绍 TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子： interface Named { name: string; } class Person { name: string; } let p: Named; // OK, because of structural typing p = new Person(); 在使用基于名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。 TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。 关于可靠性的注意事项 TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。 开始 TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。比如： interface Named { name: string; } let x: Named; // y's inferred type is { name: string; location: string; } let y = { name: 'Alice', location: 'Seattle' }; x = y; 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。 检查函数参数时使用相同的规则： function greet(n: Named) { console.log('Hello, ' + n.name); } greet(y); // OK 注意，y有个额外的location属性，但这不会引发错误。 只有目标类型（这里是Named）的成员会被一一检查是否兼容。 这个比较过程是递归进行的，检查每个成员及子成员。 比较两个函数 相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同： let x = (a: number) => 0; let y = (b: number, s: string) => 0; y = x; // OK x = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 你可能会疑惑为什么允许忽略参数，像例子y = x中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，Array#forEach给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的： let items = [1, 2, 3]; // Don't force these extra arguments items.forEach((item, index, array) => console.log(item)); // Should be OK! items.forEach((item) => console.log(item)); 下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数： let x = () => ({name: 'Alice'}); let y = () => ({name: 'Alice', location: 'Seattle'}); x = y; // OK y = x; // Error, because x() lacks a location property 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。 函数参数双向协变(不太懂) 当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如： enum EventType { Mouse, Keyboard } interface Event { timestamp: number; } interface MouseEvent extends Event { x: number; y: number } interface KeyEvent extends Event { keyCode: number } function listenEvent(eventType: EventType, handler: (n: Event) => void) { /* ... */ } // Unsound, but useful and common listenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + ',' + e.y)); // Undesirable alternatives in presence of soundness listenEvent(EventType.Mouse, (e: Event) => console.log((e).x + ',' + (e).y)); listenEvent(EventType.Mouse, void>((e: MouseEvent) => console.log(e.x + ',' + e.y))); // Still disallowed (clear error). Type safety enforced for wholly incompatible types listenEvent(EventType.Mouse, (e: number) => console.log(e)); 可选参数及剩余参数 比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。 当一个函数有剩余参数时，它被当做无限个可选参数。 这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。 有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用： function invokeLater(args: any[], callback: (...args: any[]) => void) { /* ... Invoke callback with 'args' ... */ } // Unsound - invokeLater \"might\" provide any number of arguments invokeLater([1, 2], (x, y) => console.log(x + ', ' + y)); // Confusing (x and y are actually required) and undiscoverable invokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y)); 函数重载 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。 枚举 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如， enum Status { Ready, Waiting }; enum Color { Red, Blue, Green }; let status = Status.Ready; status = Color.Green; // Error 类 类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。 class Animal { feet: number; constructor(name: string, numFeet: number) { } } class Size { feet: number; constructor(numFeet: number) { } } let a: Animal; let s: Size; a = s; // OK s = a; // OK 类的私有成员和受保护成员 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型 因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如， interface Empty { } let x: Empty; let y: Empty; x = y; // OK, because y matches structure of x 上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了： interface NotEmpty { data: T; } let x: NotEmpty; let y: NotEmpty; x = y; // Error, because x and y are not compatible 在这里，泛型类型在使用时就好比不是一个泛型类型。 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子。 比如， let identity = function(x: T): T { // ... } let reverse = function(y: U): U { // ... } identity = reverse; // OK, because (x: any) => any matches (y: any) => any 高级主题 子类型与赋值 目前为止，我们使用了“兼容性”，它在语言规范里没有定义。 在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和any来回赋值，以及enum和对应数字值之间的来回赋值。 语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在implements和extends语句也不例外。 高级类型 交叉类型（Intersection Types） 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子： function extend(first: T, second: U): T & U { let result = {}; for (let id in first) { (result)[id] = (first)[id]; } for (let id in second) { if (!result.hasOwnProperty(id)) { (result)[id] = (second)[id]; } } return result; } class Person { constructor(public name: string) { } } interface Loggable { log(): void; } class ConsoleLogger implements Loggable { log() { // ... } } var jim = extend(new Person(\"Jim\"), new ConsoleLogger()); var n = jim.name; jim.log(); 联合类型（Union Types） 联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number或 string类型的参数。 例如下面的函数： /** * Takes a string and adds \"padding\" to the left. * If 'padding' is a string, then 'padding' is appended to the left side. * If 'padding' is a number, then that number of spaces is added to the left side. */ function padLeft(value: string, padding: any) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } padLeft(\"Hello world\", 4); // returns \" Hello world\" padLeft存在一个问题， padding参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number也不是 string类型的参数，但是TypeScript却不报错。 let indentedString = padLeft(\"Hello world\", true); // 编译阶段通过，运行时报错 在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。 这么做显然是非常清晰的，但同时也存在了过度设计。 padLeft原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。 代替 any， 我们可以使用 联合类型做为 padding的参数： /** * Takes a string and adds \"padding\" to the left. * If 'padding' is a string, then 'padding' is appended to the left side. * If 'padding' is a number, then that number of spaces is added to the left side. */ function padLeft(value: string, padding: string | number) { // ... } let indentedString = padLeft(\"Hello world\", true); // errors during compilation 联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string | boolean表示一个值可以是 number， string，或 boolean。 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 interface Bird { fly(); layEggs(); } interface Fish { swim(); layEggs(); } function getSmallPet(): Fish | Bird { // ... } let pet = getSmallPet(); pet.layEggs(); // okay pet.swim(); // errors 这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 这个例子里， Bird具有一个 fly成员。 我们不能确定一个 Bird | Fish类型的变量是否有 fly方法。 如果变量在运行时是 Fish类型，那么调用 pet.fly()就出错了。 类型保护与区分类型（Type Guards and Differentiating Types） 联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish时怎么办？ JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。 let pet = getSmallPet(); // 每一个成员访问都会报错 if (pet.swim) { pet.swim(); } else if (pet.fly) { pet.fly(); } 为了让这段代码工作，我们要使用类型断言： let pet = getSmallPet(); if ((pet).swim) { (pet).swim(); } else { (pet).fly(); } 用户自定义的类型保护 这里可以注意到我们不得不多次使用类型断言。 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。 TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： function isFish(pet: Fish | Bird): pet is Fish { return (pet).swim !== undefined; } 在这个例子里， pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。 // 'swim' 和 'fly' 调用都没有问题了 if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型。 typeof类型保护 现在我们回过头来看看怎么使用联合类型书写 padLeft代码。 我们可以像下面这样利用类型断言来写： function isNumber(x: any): x is number { return typeof x === \"number\"; } function isString(x: any): x is string { return typeof x === \"string\"; } function padLeft(value: string, padding: string | number) { if (isNumber(padding)) { return Array(padding + 1).join(\" \") + value; } if (isString(padding)) { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } 然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将 typeof x === \"number\"抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。 function padLeft(value: string, padding: string | number) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } 这些 typeof类型保护只有两种形式能被识别： typeof v === \"typename\"和 typeof v !== \"typename\"， \"typename\"必须是 \"number\"， \"string\"， \"boolean\"或 \"symbol\"。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof类型保护 如果你已经阅读了 typeof类型保护并且对JavaScript里的 instanceof操作符熟悉的话，你可能已经猜到了这节要讲的内容。 instanceof类型保护是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子： interface Padder { getPaddingString(): string } class SpaceRepeatingPadder implements Padder { constructor(private numSpaces: number) { } getPaddingString() { return Array(this.numSpaces + 1).join(\" \"); } } class StringPadder implements Padder { constructor(private value: string) { } getPaddingString() { return this.value; } } function getRandomPadder() { return Math.random() instanceof的右侧要求是一个构造函数，TypeScript将细化为： 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 以此顺序。 可以为null的类型 TypeScript具有两种特殊的类型， null和 undefined，它们分别具有值null和undefined. 我们在基础类型一节里已经做过简要说明。 默认情况下，类型检查器认为 null与 undefined可以赋值给任何类型。 null与 undefined是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 null的发明者，Tony Hoare，称它为 价值亿万美金的错误。 --strictNullChecks标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null或 undefined。 你可以使用联合类型明确的包含它们： let s = \"foo\"; s = null; // 错误, 'null'不能赋值给'string' let sn: string | null = \"bar\"; sn = null; // 可以 sn = undefined; // error, 'undefined'不能赋值给'string | null' 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数和可选属性 注意使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: function f(x: number, y?: number) { return x + (y || 0); } f(1, 2); f(1); f(1, undefined); f(1, null); // error, 'null' is not assignable to 'number | undefined' 可选属性也会有同样的处理： class C { a: number; b?: number; } let c = new C(); c.a = 12; c.a = undefined; // error, 'undefined' is not assignable to 'number' c.b = 13; c.b = undefined; // ok c.b = null; // error, 'null' is not assignable to 'number | undefined' 类型保护和类型断言 由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 null。 幸运地是这与在JavaScript里写的代码一致： function f(sn: string | null): string { if (sn == null) { return \"default\"; } else { return sn; } } 这里很明显地去除了 null，你也可以使用短路运算符： function f(sn: string | null): string { return sn || \"default\"; } 如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier的类型里去除了 null和 undefined： function broken(name: string | null): string { function postfix(epithet: string) { return name.charAt(0) + '. the ' + epithet; // error, 'name' is possibly null } name = name || \"Bob\"; return postfix(\"great\"); } function fixed(name: string | null): string { function postfix(epithet: string) { return name!.charAt(0) + '. the ' + epithet; // ok } name = name || \"Bob\"; return postfix(\"great\"); } 本例使用了嵌套函数，因为编译器无法去除嵌套函数的null（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。 如果无法知道函数在哪里被调用，就无法知道调用时 name的类型。 类型别名 类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 type Name = string; type NameResolver = () => string; type NameOrResolver = Name | NameResolver; function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n; } else { return n(); } } 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： type Container = { value: T }; 我们也可以使用类型别名来在属性里引用自己： type Tree = { value: T; left: Tree; right: Tree; } 与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。 type LinkedList = T & { next: LinkedList }; interface Person { name: string; } var people: LinkedList; var s = people.name; var s = people.next.name; var s = people.next.next.name; var s = people.next.next.next.name; 然而，类型别名不能出现在声明右侧的任何地方。 type Yikes = Array; // error 接口 vs. 类型别名 像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。 其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。 type Alias = { num: number } interface Interface { num: number; } declare function aliased(arg: Alias): Alias; declare function interfaced(arg: Interface): Interface; 另一个重要区别是类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）。 因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。 另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。 字符串字面量类型 字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\"; class UIElement { animate(dx: number, dy: number, easing: Easing) { if (easing === \"ease-in\") { // ... } else if (easing === \"ease-out\") { } else if (easing === \"ease-in-out\") { } else { // error! should not pass null or undefined. } } } let button = new UIElement(); button.animate(0, 0, \"ease-in\"); button.animate(0, 0, \"uneasy\"); // error: \"uneasy\" is not allowed here 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"' 字符串字面量类型还可以用于区分函数重载： function createElement(tagName: \"img\"): HTMLImageElement; function createElement(tagName: \"input\"): HTMLInputElement; // ... more overloads ... function createElement(tagName: string): Element { // ... code goes here ... } 数字字面量类型 TypeScript还具有数字字面量类型。 function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 { // ... } 我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候： function foo(x: number) { if (x !== 1 || x !== 2) { // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. } } 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 枚举成员类型 如我们在 枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。 在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。 可辨识联合（Discriminated Unions） 你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 interface Square { kind: \"square\"; size: number; } interface Rectangle { kind: \"rectangle\"; width: number; height: number; } interface Circle { kind: \"circle\"; radius: number; } 首先我们声明了将要联合的接口。 每个接口都有 kind属性但有不同的字符串字面量类型。 kind属性称做 可辨识的特征或 标签。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起： type Shape = Square | Rectangle | Circle; 现在我们使用可辨识联合: function area(s: Shape) { switch (s.kind) { case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; } } 完整性检查 当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 Triangle到 Shape，我们同时还需要更新 area: type Shape = Square | Rectangle | Circle | Triangle; function area(s: Shape) { switch (s.kind) { case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; } // should error here - we didn't handle case \"triangle\" } 有两种方式可以实现。 首先是启用 --strictNullChecks并且指定一个返回值类型： function area(s: Shape): number { // error: returns number | undefined switch (s.kind) { case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; } } 因为 switch没有包涵所有情况，所以TypeScript认为这个函数有时候会返回 undefined。 如果你明确地指定了返回值类型为 number，那么你会看到一个错误，因为实际上返回值的类型为 number | undefined。 然而，这种方法存在些微妙之处且 --strictNullChecks对旧代码支持不好。 第二种方法使用 never类型，编译器用它来进行完整性检查： function assertNever(x: never): never { throw new Error(\"Unexpected object: \" + x); } function area(s: Shape) { switch (s.kind) { case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; default: return assertNever(s); // error here if there are missing cases } } 这里， assertNever检查 s是否为 never类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么 s将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。 多态的 this类型 多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回 this类型： class BasicCalculator { public constructor(protected value: number = 0) { } public currentValue(): number { return this.value; } public add(operand: number): this { this.value += operand; return this; } public multiply(operand: number): this { this.value *= operand; return this; } // ... other operations go here ... } let v = new BasicCalculator(2) .multiply(5) .add(1) .currentValue(); 由于这个类使用了 this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。 class ScientificCalculator extends BasicCalculator { public constructor(value = 0) { super(value); } public sin() { this.value = Math.sin(this.value); return this; } // ... other operations go here ... } let v = new ScientificCalculator(2) .multiply(5) .sin() .add(1) .currentValue(); 如果没有 this类型， ScientificCalculator就不能够在继承 BasicCalculator的同时还保持接口的连贯性。 multiply将会返回 BasicCalculator，它并没有 sin方法。 然而，使用 this类型， multiply会返回 this，在这里就是 ScientificCalculator。 索引类型（Index types）(不太懂) 使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。 function pluck(o, names) { return names.map(n => o[n]); } 下面是如何在TypeScript里使用此函数，通过 索引类型查询和 索引访问操作符： function pluck(o: T, names: K[]): T[K][] { return names.map(n => o[n]); } interface Person { name: string; age: number; } let person: Person = { name: 'Jarid', age: 35 }; let strings: string[] = pluck(person, ['name']); // ok, string[] 编译器会检查 name是否真的是 Person的一个属性。 本例还引入了几个新的类型操作符。 首先是 keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。 例如： let personProps: keyof Person; // 'name' | 'age' keyof Person是完全可以与 'name' | 'age'互相替换的。 不同的是如果你添加了其它的属性到 Person，例如 address: string，那么 keyof Person会自动变为 'name' | 'age' | 'address'。 你可以在像 pluck函数这类上下文里使用 keyof，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给 pluck： pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age' 第二个操作符是 T[K]， 索引访问操作符。 在这里，类型语法反映了表达式语法。 这意味着 person['name']具有类型 Person['name'] — 在我们的例子里则为 string类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 T[K]，这正是它的强大所在。 你只要确保类型变量 K extends keyof T就可以了。 例如下面 getProperty函数的例子： function getProperty(o: T, name: K): T[K] { return o[name]; // o[name] is of type T[K] } getProperty里的 o: T和 name: K，意味着 o[name]: T[K]。 当你返回 T[K]的结果，编译器会实例化键的真实类型，因此 getProperty的返回值类型会随着你需要的属性改变。 let name: string = getProperty(person, 'name'); let age: number = getProperty(person, 'age'); let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age' 索引类型和字符串索引签名 keyof和 T[K]与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么 keyof T会是 string。 并且 T[string]为索引签名的类型： interface Map { [key: string]: T; } let keys: keyof Map; // string let value: Map['foo']; // number 映射类型 一个常见的任务是将一个已知的类型每个属性都变为可选的： interface PersonPartial { name?: string; age?: number; } 或者我们想要一个只读版本： interface PersonReadonly { readonly name: string; readonly age: number; } 这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为 readonly类型或可选的。 下面是一些例子： type Readonly = { readonly [P in keyof T]: T[P]; } type Partial = { [P in keyof T]?: T[P]; } 像下面这样使用： type PersonPartial = Partial; type ReadonlyPerson = Readonly; 下面来看看最简单的映射类型和它的组成部分： type Keys = 'option1' | 'option2'; type Flags = { [K in Keys]: boolean }; 它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分： 类型变量 K，它会依次绑定到每个属性。 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。 属性的结果类型。 在个简单的例子里， Keys是硬编码的的属性名列表并且属性类型永远是 boolean，因此这个映射类型等同于： type Flags = { option1: boolean; option2: boolean; } 在真正的应用里，可能不同于上面的 Readonly或 Partial。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是 keyof和索引访问类型要做的事情： type NullablePerson = { [P in keyof Person]: Person[P] | null } type PartialPerson = { [P in keyof Person]?: Person[P] } 但它更有用的地方是可以有一些通用版本。 type Nullable = { [P in keyof T]: T[P] | null } type Partial = { [P in keyof T]?: T[P] } 在这些例子里，属性列表是 keyof T且结果类型是 T[P]的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是 同态的，映射只作用于 T的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设 Person.name是只读的，那么 Partial.name也将是只读的且为可选的。 下面是另一个例子， T[P]被包装在 Proxy类里： type Proxy = { get(): T; set(value: T): void; } type Proxify = { [P in keyof T]: Proxy; } function proxify(o: T): Proxify { // ... wrap proxies ... } let proxyProps = proxify(props); 注意 Readonly和 Partial用处不小，因此它们与 Pick和 Record一同被包含进了TypeScript的标准库里： type Pick = { [P in K]: T[P]; } type Record = { [P in K]: T; } Readonly， Partial和 Pick是同态的，但 Record不是。 因为 Record并不需要输入类型来拷贝属性，所以它不属于同态： type ThreeStringProps = Record 非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。 由映射类型进行推断 现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易： function unproxify(t: Proxify): T { let result = {} as T; for (const k in t) { result[k] = t[k].get(); } return result; } let originalProps = unproxify(proxyProps); 注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。 预定义的有条件类型 TypeScript 2.8在lib.d.ts里增加了一些预定义的有条件类型： Exclude -- 从T中剔除可以赋值给U的类型。 Extract -- 提取T中可以赋值给U的类型。 NonNullable -- 从T中剔除null和undefined。 ReturnType -- 获取函数返回值类型。 InstanceType -- 获取构造函数类型的实例类型。 示例 type T00 = Exclude; // \"b\" | \"d\" type T01 = Extract; // \"a\" | \"c\" type T02 = Exclude void), Function>; // string | number type T03 = Extract void), Function>; // () => void type T04 = NonNullable; // string | number type T05 = NonNullable string) | string[] | null | undefined>; // (() => string) | string[] function f1(s: string) { return { a: 1, b: s }; } class C { x = 0; y = 0; } type T10 = ReturnType string>; // string type T11 = ReturnType void>; // void type T12 = ReturnType() => T)>; // {} type T13 = ReturnType() => T)>; // number[] type T14 = ReturnType; // { a: number, b: string } type T15 = ReturnType; // any type T16 = ReturnType; // any type T17 = ReturnType; // Error type T18 = ReturnType; // Error type T20 = InstanceType; // C type T21 = InstanceType; // any type T22 = InstanceType; // any type T23 = InstanceType; // Error type T24 = InstanceType; // Error 注意：Exclude类型是建议的Diff类型的一种实现。我们使用Exclude这个名字是为了避免破坏已经定义了Diff的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加Omit类型，因为它可以很容易的用Pick>来表示。 装饰器 注意: 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 一、装饰器的种类 1、根据装饰器的位置（五种） 类装饰器 方法装饰器 属性装饰器 函数参数装饰器 访问器装饰器 2、根据装饰器是否有参数 无参装饰器(一般装饰器) 有参装饰器(装饰器工厂) 有一个@sealed装饰器，我们会这样定义sealed函数： function sealed(target) { // do something with \"target\" ... } 注意  后面类装饰器小节里有一个更加详细的例子。 装饰器工厂 如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。 我们可以通过下面的方式来写一个装饰器工厂函数： function color(value: string) { // 这是一个装饰器工厂 return function (target) { // 这是装饰器 // do something with \"target\" and \"value\"... } } 注意  下面方法装饰器小节里有一个更加详细的例子 装饰器组合 多个装饰器可以同时应用到一个声明上，就像下面的示例： 书写在同一行上： @f @g x 书写在多行上： @f @g x 当多个装饰器应用于一个声明上，它们求值方式与复合函数相似。在这个模型下，当复合f和g时，复合的结果(f ∘ g)(x)等同于f(g(x))。 同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作： 由上至下依次对装饰器表达式求值。 求值的结果会被当作函数，由下至上依次调用。 如果我们使用装饰器工厂的话，可以通过下面的例子来观察它们求值的顺序： function f() { console.log(\"f(): evaluated\"); return function (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log(\"f(): called\"); } } function g() { console.log(\"g(): evaluated\"); return function (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log(\"g(): called\"); } } class C { @f() @g() method() {} } 在控制台里会打印出如下结果： f(): evaluated g(): evaluated g(): called f(): called 类装饰器 类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。 注意 如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中 不会为你做这些。 下面是使用类装饰器(@sealed)的例子，应用在Greeter类： @sealed class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } 我们可以这样定义@sealed装饰器： function sealed(constructor: Function) { Object.seal(constructor); Object.seal(constructor.prototype); } 当@sealed被执行的时候，它将密封此类的构造函数和原型。(注：参见Object.seal) 下面是一个重载构造函数的例子。 function classDecorator(constructor:T) { return class extends constructor { newProperty = \"new property\"; hello = \"override\"; } } @classDecorator class Greeter { property = \"property\"; hello: string; constructor(m: string) { this.hello = m; } } console.log(new Greeter(\"world\")); 方法装饰器 方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件( .d.ts)，重载或者任何外部上下文（比如declare的类）中。 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 注意  如果代码输出目标版本小于ES5，属性描述符将会是undefined。 如果方法装饰器返回一个值，它会被用作方法的属性描述符。 注意  如果代码输出目标版本小于ES5返回值会被忽略。 下面是一个方法装饰器（@enumerable）的例子，应用于Greeter类的方法上： class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @enumerable(false) greet() { return \"Hello, \" + this.greeting; } } 我们可以用下面的函数声明来定义@enumerable装饰器： function enumerable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = value; }; } 这里的@enumerable(false)是一个装饰器工厂。 当装饰器 @enumerable(false)被调用时，它会修改属性描述符的enumerable属性。 访问器装饰器 访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。 注意  TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。 访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。 注意  如果代码输出目标版本小于ES5，Property Descriptor将会是undefined。 如果访问器装饰器返回一个值，它会被用作方法的属性描述符。 注意  如果代码输出目标版本小于ES5返回值会被忽略。 下面是使用了访问器装饰器（@configurable）的例子，应用于Point类的成员上： class Point { private _x: number; private _y: number; constructor(x: number, y: number) { this._x = x; this._y = y; } @configurable(false) get x() { return this._x; } @configurable(false) get y() { return this._y; } } 我们可以通过如下函数声明来定义@configurable装饰器： function configurable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.configurable = value; }; } 属性装饰器 属性装饰器声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 注意  属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。 我们可以用它来记录这个属性的元数据，如下例所示： class Greeter { @format(\"Hello, %s\") greeting: string; constructor(message: string) { this.greeting = message; } greet() { let formatString = getFormat(this, \"greeting\"); return formatString.replace(\"%s\", this.greeting); } } 然后定义@format装饰器和getFormat函数： import \"reflect-metadata\"; const formatMetadataKey = Symbol(\"format\"); function format(formatString: string) { return Reflect.metadata(formatMetadataKey, formatString); } function getFormat(target: any, propertyKey: string) { return Reflect.getMetadata(formatMetadataKey, target, propertyKey); } 这个@format(\"Hello, %s\")装饰器是个 装饰器工厂。 当 @format(\"Hello, %s\")被调用时，它添加一条这个属性的元数据，通过reflect-metadata库里的Reflect.metadata函数。 当 getFormat被调用时，它读取格式的元数据。 注意  这个例子需要使用reflect-metadata库。 查看 元数据了解reflect-metadata库更详细的信息。 参数装饰器 参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如 declare的类）里。 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 参数在函数参数列表中的索引。 注意  参数装饰器只能用来监视一个方法的参数是否被传入。 参数装饰器的返回值会被忽略。 下例定义了参数装饰器（@required）并应用于Greeter类方法的一个参数： class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @validate greet(@required name: string) { return \"Hello \" + name + \", \" + this.greeting; } } 然后我们使用下面的函数定义 @required 和 @validate 装饰器： import \"reflect-metadata\"; const requiredMetadataKey = Symbol(\"required\"); function required(target: Object, propertyKey: string | symbol, parameterIndex: number) { let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []; existingRequiredParameters.push(parameterIndex); Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey); } function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor) { let method = descriptor.value; descriptor.value = function () { let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName); if (requiredParameters) { for (let parameterIndex of requiredParameters) { if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) { throw new Error(\"Missing required argument.\"); } } } return method.apply(this, arguments); } } @required装饰器添加了元数据实体把参数标记为必需的。 @validate装饰器把greet方法包裹在一个函数里在调用原先的函数前验证函数参数。 注意  这个例子使用了reflect-metadata库。 查看 元数据了解reflect-metadata库的更多信息。 元数据 一些例子使用了reflect-metadata库来支持实验性的metadata API。 这个库还不是ECMAScript (JavaScript)标准的一部分。 然而，当装饰器被ECMAScript官方标准采纳后，这些扩展也将被推荐给ECMAScript以采纳。 你可以通过npm安装这个库： npm i reflect-metadata --save TypeScript支持为带有装饰器的声明生成元数据。 你需要在命令行或 tsconfig.json里启用emitDecoratorMetadata编译器选项。 Command Line: tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata tsconfig.json: { \"compilerOptions\": { \"target\": \"ES5\", \"experimentalDecorators\": true, \"emitDecoratorMetadata\": true } } 当启用后，只要reflect-metadata库被引入了，设计阶段添加的类型信息可以在运行时使用。 如下例所示： import \"reflect-metadata\"; class Point { x: number; y: number; } class Line { private _p0: Point; private _p1: Point; @validate set p0(value: Point) { this._p0 = value; } get p0() { return this._p0; } @validate set p1(value: Point) { this._p1 = value; } get p1() { return this._p1; } } function validate(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor) { let set = descriptor.set; descriptor.set = function (value: T) { let type = Reflect.getMetadata(\"design:type\", target, propertyKey); if (!(value instanceof type)) { throw new TypeError(\"Invalid type.\"); } set(value); } } TypeScript编译器可以通过@Reflect.metadata装饰器注入设计阶段的类型信息。 你可以认为它相当于下面的TypeScript： class Line { private _p0: Point; private _p1: Point; @validate @Reflect.metadata(\"design:type\", Point) set p0(value: Point) { this._p0 = value; } get p0() { return this._p0; } @validate @Reflect.metadata(\"design:type\", Point) set p1(value: Point) { this._p1 = value; } get p1() { return this._p1; } } 注意  装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变（breaking changes）。 装饰器加载顺序 function ClassDecorator() { return function (target) { console.log(\"I am class decorator\"); } } function MethodDecorator() { return function (target, methodName: string, descriptor: PropertyDescriptor) { console.log(\"I am method decorator\"); } } function Param1Decorator() { return function (target, methodName: string, paramIndex: number) { console.log(\"I am parameter1 decorator\"); } } function Param2Decorator() { return function (target, methodName: string, paramIndex: number) { console.log(\"I am parameter2 decorator\"); } } function PropertyDecorator() { return function (target, propertyName: string) { console.log(\"I am property decorator\"); } } @ClassDecorator() class Hello { @PropertyDecorator() greeting: string; @MethodDecorator() greet( @Param1Decorator() p1: string, @Param2Decorator() p2: string) { } } 输出结果： I am property decorator I am parameter2 decorator I am parameter1 decorator I am method decorator I am class decorator 从上述例子得出如下结论： 有多个参数装饰器时：从最后一个参数依次向前执行 方法和方法参数中参数装饰器先执行。 类装饰器总是最后执行。 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。上述例子中属性和方法调换位置，输出如下结果： I am parameter2 decorator I am parameter1 decorator I am method decorator I am property decorator I am class decorator Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-07 23:54:08 "},"Framework/前端/React/Interview/react面试题.html":{"url":"Framework/前端/React/Interview/react面试题.html","title":"react面试题 ✘","keywords":"","body":"目录  1. React 中 key 的重要性是什么? 2. React 中 key 的重要性是什么？ key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-10 16:52:43 "},"Framework/前端/React/Interview/react面试题复杂.html":{"url":"Framework/前端/React/Interview/react面试题复杂.html","title":"react面试题复杂 ✘","keywords":"","body":"目录  1. react virsualDOM 是什么? 如何实现? 说一下diff算法 ? 1. react virsualDOM 是什么? 如何实现? 说一下diff算法 ? 虚拟DOM 虚拟 DOM Diff 算法解析 Virtual DOM 1. 是什么？ 用Javascript对象结构描述Dom树结构,然后用它来构建真正的Dom树插入文档 当状态发生改变之后,重新构造新的Javascript对象结构和旧的作对比得出差异 针对差异之处进行重新构建更新视图 无非就是利用Js做一层映射比较,操作简单并且速度远远高于直接比较Dom树 2. 为什么？ 所有浏览器的引擎工作流程都差不多，如上图大致分5步：创建DOM tree –> 创建Style Rules -> 构建Render tree -> 布局Layout –> 绘制Painting 操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： const div = document.createElement('div'); let num = 0; for (let k in div) { num++; } console.log(num); // 241 然后浏览器根据CSS规则查找匹配节点,计算合并样式布局,为了避免重新计算一般浏览器会保存这些数据.但这是整个过程下来依然会耗费大量的内存和 CPU 资源. 虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。虚拟DOM不会立即操作DOM，而是将这多次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。3. 怎么做？ Virtual DOM 算法。包括几个步骤： 1.用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 2.当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 3.把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-18 17:24:23 "},"Framework/前端/React/源码分析/react.html":{"url":"Framework/前端/React/源码分析/react.html","title":"React ✘","keywords":"","body":"Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-14 15:03:05 "},"Framework/前端/React/react坑.html":{"url":"Framework/前端/React/react坑.html","title":"react坑 ✘","keywords":"","body":"1.antdesign 嵌套子表格获取异步数据 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 22:37:10 "},"Framework/前端/React/react技巧.html":{"url":"Framework/前端/React/react技巧.html","title":"react技巧 ✘","keywords":"","body":"简写 使用 React Fragments 来组合各个组件，为了语义化的 HTML 不会被破坏。 function Glossary(props) { return ( {props.items.map(item => ( // Fragments should also have a `key` prop when mapping collections {item.term} {item.description} ))} ); } 当你不需要在 fragment 标签中添加任何 prop 且你的工具支持的时候，你可以使用 短语法： function ListItem({ item }) { return ( <> {item.term} {item.description} ); } 关闭弹窗 window 对象中附上一个 click 事件以关闭弹窗： Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-17 01:55:25 "},"Framework/前端/Vue/Interview/持续更新面试题.html":{"url":"Framework/前端/Vue/Interview/持续更新面试题.html","title":"持续更新面试题 ✘","keywords":"","body":"30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度） 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？ SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。2、v-show 与 v-if 有什么区别？ v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？ Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： data: { isActive: true, hasError: false } 数组语法： data: { activeClass: 'active', errorClass: 'text-danger' } Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： data: { activeColor: 'red', fontSize: 30 } 数组语法： data: { styleColor: { color: 'red' }, styleSize:{ fontSize:'23px' } } 4、怎样理解 Vue 的单向数据流？ 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： props: ['initialCounter'], data: function () { return { counter: this.initialCounter } } 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 props: ['size'], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } } 5、computed 和 watch 的区别和运用的场景？ computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？ 由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： // Vue.set Vue.set(vm.items, indexOfItem, newValue) // vm.$set，Vue.set的一个别名 vm.$set(vm.items, indexOfItem, newValue) // Array.prototype.splice vm.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，Vue 提供了以下操作方法： // Array.prototype.splice vm.items.splice(newLength) 7、谈谈你对 Vue 生命周期的理解？ （1）生命周期是什么？ Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 （2）各个生命周期的作用 生命周期 描述 beforeCreate 组件实例（创建前）调用，在数据观测和初始化事件还未开始 created （创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来 beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted:在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 update 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 activited keep-alive 专属，组件被激活时调用 deadctivated keep-alive 专属，组件被销毁时调用 beforeDestory 在实例销毁之前调用。实例仍然完全可用。 destoryed 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 （3）生命周期示意图 1.png 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？ Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted 子组件更新过程 父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated 父组件更新过程 父 beforeUpdate -> 父 updated 销毁过程 父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed 9、在哪个生命周期内调用异步请求？ 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；10、在什么阶段才能访问操作DOM？ 在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 1.png 11、父组件可以监听到子组件的生命周期吗？ 比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： // Parent.vue // Child.vue mounted() { this.$emit(\"mounted\"); } 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： // Parent.vue doSomething() { console.log('父组件监听到 mounted 钩子函数 ...'); }, // Child.vue mounted(){ console.log('子组件触发 mounted 钩子函数 ...'); }, // 以上输出顺序为： // 子组件触发 mounted 钩子函数 ... // 父组件监听到 mounted 钩子函数 ... 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 12、谈谈你对 keep-alive 的了解？ keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 13、组件中 data 为什么是一个函数？ 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ // data data() { return { message: \"子组件\", childName:this.name } } // new Vue new Vue({ el: '#app', router, template: '', components: {App} }) 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 14、v-model 的原理？ 我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 相当于 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 父组件： 子组件： props:{ value: String }, methods: { test1(){ this.$emit('input', '小红') }, }, 15、Vue 组件间通信有哪几种方式？ Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 $parent / $children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 -（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4）$attrs/$listeners 适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 （7）ref，$root 16、你使用过 Vuex 吗？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （- 2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 - store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。17、使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。 18、vue-router 路由模式有几种？ vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： switch (mode) { case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') { assert(false, `invalid mode: ${mode}`) } } 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？ （1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'： https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。（2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： window.history.pushState(null, null, path); window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 20、什么是 MVVM？ Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示： 1.png （1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然： （1）View 层 {{message}} Click me （2）ViewModel 层 var app = new Vue({ el: '#app', data: { // 用于描述视图状态 message: 'Hello Vue!', }, methods: { // 用于描述视图行为 showMessage(){ let vm = this; alert(vm.message); } }, created(){ let vm = this; // Ajax 获取 Model 层的数据 ajax({ url: '/your/server/data/api', success(res){ vm.message = res; } }); } }) （3） Model 层 { \"url\": \"/your/server/data/api\", \"res\": { \"success\": true, \"name\": \"IoveC\", \"domain\": \"www.cnblogs.com\" } } 21、Vue 是如何实现数据双向绑定的？ 在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。 当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。 可以发现只要视图中添加监听事件，自动变更对应的数据变化时，就可以实现数据和视图的双向绑定了。 Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 1.png 即： 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。 1.png 22、Vue 框架怎么实现对象和数组的监听？ 如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： /** * Observe a list of Array items. */ observeArray (items: Array) { for (let i = 0, l = items.length; i 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 23、Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 - Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？ 受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？ 我们查看对应的 Vue 源码：vue/src/core/instance/index.js export function set (target: Array | Object, key: any, val: any): any { // target 为数组 if (Array.isArray(target) && isValidArrayIndex(key)) { // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误 target.length = Math.max(target.length, key) // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val } // key 已经存在，直接修改属性值 if (key in target && !(key in Object.prototype)) { target[key] = val return val } const ob = (target: any).__ob__ // target 本身就不是响应式数据, 直接赋值 if (!ob) { target[key] = val return val } // 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val } 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 25、虚拟 DOM 的优缺点？ 优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 26、虚拟 DOM 实现原理？ 虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 27、Vue 中的 key 有什么作用？为什么不能用index作为key？ key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： function createKeyToOldIdx (children, beginIdx, endIdx) { let i, key const map = {} for (i = beginIdx; i 为什么不能用index作为key？ 如果使用index作为key，删除 某个（除了最后一个） 后，剩下的元素因为与 key 的关系发生变化，会被重新渲染 28、你有对 Vue 项目进行哪些优化？ 如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。 （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 29、对于即将到来的 vue3.0 特性你有什么了解的吗？ Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。 此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改 vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。 30. vue初始化流程 创建Vue实例对象 init过程会初始化生命周期，初始化事件中心，初始化渲染、执行beforeCreate周期函数、初始化 data、props、computed、watcher、执行created周期函数等。 初始化后，调用$mount方法对Vue实例进行挂载（挂载的核心过程包括模板编译、渲染以及更新三个过程）。 如果没有在Vue实例上定义render方法而是定义了template，那么需要经历编译阶段。需要先将template 字符串编译成 render function，template 字符串编译步骤如下 ： parse正则解析template字符串形成AST（抽象语法树，是源代码的抽象语法结构的树状表现形式） optimize标记静态节点跳过diff算法（diff算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有O(n)。如果对于时间复杂度不是很清晰的，可以查看我写的文章ziyi2/algorithms-javascript/渐进记号） generate将AST转化成render function字符串 编译成render function 后，调用$mount的mountComponent方法，先执行beforeMount钩子函数，然后核心是实例化一个渲染Watcher，在它的回调函数（初始化的时候执行，以及组件实例中监测到数据发生变化时执行）中调用updateComponent方法（此方法调用render方法生成虚拟Node，最终调用update方法更新DOM）。 调用render方法将render function渲染成虚拟的Node（真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。如果频繁的去做 DOM 更新，会产生一定的性能问题，而 Virtual DOM 就是用一个原生的 JavaScript 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多，而且修改属性也很轻松，还可以做到跨平台兼容），render方法的第一个参数是createElement(或者说是h函数)，这个在官方文档也有说明。 生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用pacth方法把虚拟DOM转换成真正的DOM节点。需要注意在图中忽略了新建真实DOM的情况（如果没有旧的虚拟Node，那么可以直接通过createElm创建真实DOM节点），这里重点分析在已有虚拟Node的情况下，会通过sameVnode判断当前需要更新的Node节点是否和旧的Node节点相同（例如我们设置的key属性发生了变化，那么节点显然不同），如果节点不同那么将旧节点采用新节点替换即可，如果相同且存在子节点，需要调用patchVNode方法执行diff算法更新DOM，从而提升DOM操作的性能。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-28 13:53:18 "},"Framework/前端/Vue/Interview/vue面试题.html":{"url":"Framework/前端/Vue/Interview/vue面试题.html","title":"vue面试题 ✘","keywords":"","body":"目录  1. 说一下Vue的双向绑定数据的原理  2. 解释单向数据流和双向数据绑定  3. Vue如何去除url中的 #  4. 对 MVC、MVVM的理解  5. 介绍虚拟DOM  6. vue生命周期的理解  7. 组件通信  8. 路由实现  9. v-if 和 v-show 区别  10. $route和$router的区别  11. NextTick 是做什么的  12. Vue 组件 data 为什么必须是函数  13. 计算属性computed 和事件 methods 有什么区别  14. 对比 jQuery ，Vue 有什么优缺点  15. Vue 中怎么自定义指令  16. Vue 中怎么自定义过滤器  17. 对 keep-alive 的了解  18. Vue 中 key 的作用  19. 你觉得 Vue 的核心是什么  20. vue 等单页面应用的优缺点  21. vue-router 使用params与query传参有什么区别  22. 详解vue的diff算法  23. Vue数组监视  24. provide/inject原理  25. vue指令以及原理  26. vue插件  27. vue里extend、mixins、extends的区别  28. Vue中的$attrs和$listener  29. Vue中的slots深层传递 1. 说一下Vue的双向绑定数据的原理 Vue2.0数据双向绑定原理:Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。简述： 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。深入理解： 监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 2. 解释单向数据流和双向数据绑定 单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state 双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度 3. Vue 如何去除url中的 # vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history new Router({ mode: 'history', routes: [ ] }) 需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面 4. 对 MVC、MVVM的理解 MVC 特点： View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的 MVVM 特点： 各部分之间的通信，都是双向的 采用双向绑定：View 的变动，自动反映在 ViewModel，反之亦然 具体请移步 这里 5. 介绍虚拟DOM 参考这里 6. vue生命周期的理解 vue实例有一个完整的生命周期，生命周期也就是指一个实例从开始创建到销毁的这个过程 beforeCreated() 在实例创建之间执行，data,method 还没有初始化 created() 在实例创建、数据加载后，能初始化数据，data,method 初始化，能使用，能调用 beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据 mounted() 页面、数据渲染完成，真实dom挂载完成 beforeUpadate() 重新渲染之前触发 updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环 beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行 7. 组件通信 父组件向子组件通信 子组件通过 props 属性，绑定父组件数据，实现双方通信 子组件向父组件通信 将父组件的事件在子组件中通过 $emit 触发 非父子组件、兄弟组件之间的数据传递 /*新建一个Vue实例作为中央事件总嫌*/ let event = new Vue(); /*监听事件*/ event.$on('eventName', (val) => { //......do something }); /*触发事件*/ event.$emit('eventName', 'this is a message.') Vuex 数据管理 8. vue-router 路由实现 路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能 参考 这里 9. v-if 和 v-show 区别 使用了 v-if 的时候，如果值为 false ，那么页面将不会有这个 html 标签生成。 v-show 则是不管值为 true 还是 false ，html 元素都会存在，只是 CSS 中的 display 显示或隐藏 10. $route和$router的区别 $router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法 $route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等 11. NextTick 是做什么的 $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码； {{testMsg}} export default { name: 'HelloWorld', data () { return { testMsg:\"原始值\", } }, methods:{ changeTxt:function(){ let that=this; that.testMsg=\"修改后的文本值\"; //vue数据改变，改变dom结构 let domTxt=document.getElementById('h').innerText; //后续js对dom的操作 console.log(domTxt); //输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的 if(domTxt===\"原始值\"){ console.log(\"文本data被修改后dom内容没立即更新\"); }else { console.log(\"文本data被修改后dom内容被马上更新了\"); } }, } } 正确的用法是：vue改变dom元素结构后使用vue.$nextTick()方法来实现dom数据更新后延迟执行后续代码 changeTxt:function(){ let that=this; that.testMsg=\"修改后的文本值\"; //修改dom结构 that.$nextTick(function(){ //使用vue.$nextTick()方法可以dom数据更新后延迟执行 let domTxt=document.getElementById('h').innerText; console.log(domTxt); //输出可以看到vue数据修改后并没有DOM没有立即更新， if(domTxt===\"原始值\"){ console.log(\"文本data被修改后dom内容没立即更新\"); }else { console.log(\"文本data被修改后dom内容被马上更新了\"); } }); }, 原理 Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。 当你设置 vm.someData = 'new value'，DOM 并不会马上更新，下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 源码分析 其实就是判断使用Promise，MutationObserver，setTimeout的优先级。系统中会优先用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 nextTick的源码其实就是将传进来的函数依次放入数组中，然后找到最优的异步方法依次执行数组中的方法，vue进行DOM更新内部也是调用nextTick来做异步队列控制。而当我们自己调用nextTick的时候，它就在更新DOM的那个microtask后追加了我们自己的回调函数，从而确保我们的代码在DOM更新后执行，这就是为什么nextTick()方法可以获取最新的DOM。 具体可参考官方文档 深入响应式原理 12. Vue 组件 data 为什么必须是函数 因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了 13. 计算属性computed 和事件 methods 有什么区别 我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 不同点： computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值 对于 method ，只要发生重新渲染，method 调用总会执行该函数 14. 对比 jQuery ，Vue 有什么不同 jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作 Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发 15. Vue 中怎么自定义指令 全局注册 // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 局部注册 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 参考 官方文档-自定义指令 16. Vue 中怎么自定义过滤器 可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值 Vue.filter('reverse', function (value) { return value.split('').reverse().join('') }) 'cba' --> 过滤器也同样接受全局注册和局部注册 17. 对 keep-alive 的了解 keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 可以使用API提供的props，实现组件的动态缓存 具体参考 官方API 使用 \\ 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 \\ 相似，\\ 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 \\ 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 原理 /* keep-alive组件 */ export default { name: 'keep-alive', /* 抽象组件 */ abstract: true, props: { include: patternTypes, exclude: patternTypes }, created () { /* 缓存对象 */ this.cache = Object.create(null) }, /* destroyed钩子中销毁所有cache中的组件实例 */ destroyed () { for (const key in this.cache) { pruneCacheEntry(this.cache[key]) } }, watch: { /* 监视include以及exclude，在被修改的时候对cache进行修正 */ include (val: string | RegExp) { pruneCache(this.cache, this._vnode, name => matches(val, name)) }, exclude (val: string | RegExp) { pruneCache(this.cache, this._vnode, name => !matches(val, name)) } }, render () { /* 得到slot插槽中的第一个组件 */ const vnode: VNode = getFirstComponentChild(this.$slots.default) const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions if (componentOptions) { // check pattern /* 获取组件名称，优先获取组件的name字段，否则是组件的tag */ const name: ?string = getComponentName(componentOptions) /* name不在inlcude中或者在exlude中则直接返回vnode（没有取缓存） */ if (name && ( (this.include && !matches(this.include, name)) || (this.exclude && matches(this.exclude, name)) )) { return vnode } const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '') : vnode.key /* 如果已经做过缓存了则直接从缓存中获取组件实例给vnode，还未缓存过则进行缓存 */ if (this.cache[key]) { vnode.componentInstance = this.cache[key].componentInstance // 2.5.0 新增这段逻辑，使用 LRU 策略 make current key freshest remove(keys, key); keys.push(key); } // 不命中缓存,把 vnode 设置进缓存 else { this.cache[key] = vnode; // 2.5.0 新增这段逻辑，LRU 策略的移除。 keys.push(key); // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个 if (this.max && keys.length > parseInt(this.max)) { pruneCacheEntry(cache, keys[0], keys, this._vnode); } } /* keepAlive标记位 */ vnode.data.keepAlive = true } return vnode } } 获取 keep-alive 包裹着的第一个子组件对象及其组件名 根据设定的 include/exclude（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例 根据组件 ID 和 tag 生成缓存 Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键) 在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置值，超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key） 最后组件实例的 keepAlive 属性设置为 true，这个在渲染和执行被包裹组件的钩子函数会用到，LRU 策略 最近最久未使用算法。 每次从内存中找出最久的未使用数据用于置换新的数据。 18. Vue 中 key 的作用 key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误 具体参考 官方API 19. Vue 的核心是什么 数据驱动 组件系统 20. vue 等单页面应用的优缺点 优点： 良好的交互体验 良好的前后端工作分离模式 减轻服务器压力 缺点： SEO难度较高 前进、后退管理 初次加载耗时多 21. vue-router 使用params与query传参有什么区别 vue-router 可以通过 params 与 query 进行传参 // 传递 this.$router.push({path: './xxx', params: {xx:xxx}}) this.$router.push({path: './xxx', query: {xx:xxx}}) // 接收 this.$route.params this.$route.query params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系 params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题 22. 详解vue的diff算法 详解vue的diff算法 23. Vue数组监视 vue并不是不能利用Object.defineProperty实现对数组的监听，而是故意不去实现 Vue数组监视的只有 push()、pop()、shift()、unshift()、splice()、sort()、reverse() 7 种方法。我们可以遍历一下： var arrayProto = Array.prototype var arrayMethods = Object.create(arrayProto) ;[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ].forEach(function(item){ Object.defineProperty(arrayMethods,item,{ value:function mutator(){ //缓存原生方法，之后调用 console.log('array被访问'); var original = arrayProto[item] var args = Array.from(arguments) original.apply(this,args) // console.log(this); }, }) }) 24. provide/inject原理 父孙组件之间怎么传递数据呢？VUE提供了provide/inject 来实现此功能。 使用详解 provide：Object | () => Object inject：Array | { [key: string]: string | Symbol | Object } 完整的用法 // 父级组件提供 'foo' var Provider = { data () { return { x: 'test' } } // 可以直接使用对象，对象包含需要提供的key：“value” provide: { foo: 'bar' }, // 可是设置provide 为一个函数，函数返回一个provide属性，this指向vue实例，所以可以调用组件data里的值得 provide () { return { a: this.x } }, // ... } // 子组件注入 'foo' var Child = { // inject可以是一个数组，数组里包含需要注入的key的字面量 inject: ['foo'], // inject 可以是一个对象 inject: { foo: 'foo' }, // inject 可以设置默认值，所以可以inject的指可以在provide里不存在 inject: { foo: {default: 'default value'} }, // default 值也可是一个有返回值的函数 inject: { foo: {default: () => {return [1,2,3]}} }, // 完整的带默认值的写法, a 是provide中提供的key的字面量 inject: { foo: { from: 'a', default: 'default value' } }, created () { console.log(this.foo) // => \"bar\" } // ... } provide/inject实现响应式数据更新 将一个函数赋值给provide的一个值，这个函数返回父组件的动态数据，然后在子孙组件里面调用这个函数。 实际上这个函数存储了父组件实例的引用，所以每次子组件都能获取到最新的数据。代码长下面的样子： Parent组件： Parent组件 改变name Parent组件中 name的值: {{name}} import Child from './Child' export default { name: 'Parent', data () { return { name: 'Kevin' } }, methods: { changeName (val) { this.name = 'New Kevin' } }, provide () { return { nameFromParent: this.name, getReaciveNameFromParent: () => this.name } }, // provide: { // nameFromParent: this.name, // getReaciveNameFromParent: () => this.name // }, components: { Child } } Child组件 Child组件 import GrandSon from './GrandSon' export default { components: { GrandSon } } GrandSon组件： Grandson组件 {{nameFromParent}} {{reactiveNameFromParent}} export default { inject: ['nameFromParent', 'getReaciveNameFromParent'], computed: { reactiveNameFromParent () { return this.getReaciveNameFromParent() } }, watch: { 'reactiveNameFromParent': function (val) { console.log('来自Parent组件的name值发生了变化', val) } }, mounted () { console.log(this.nameFromParent, 'nameFromParent') } } 25. vue指令以及原理 参考(http://book.93lin.cn/UseInJob/vue自定义指令相关.html) 26. vue插件以及原理 参考(http://book.93lin.cn/UseInJob/vue插件.html) 27. vue里extend、mixins、extends的区别 1.extend Vue.extend使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 // Vue.extend // 创建构造器 var Profile = Vue.extend({ template: '{{firstName}} {{lastName}} aka {{alias}}', data: function () { return { firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' } } }) // 创建 Profile 实例，并挂载到一个元素上。 new Profile().$mount('#mount-point') 2.mixins mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。 Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。 // mixins示例 var mixin = { created: function () { console.log(1) } } var vm = new Vue({ created: function () { console.log(2) }, mixins: [mixin] }) // => 1 // => 2 mixins要点 data混入组件数据优先 钩子函数将混合为一个数组，混入对象的钩子将在组件自身钩子之前调用 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 以上合并策略可以通过Vue.config.optionMergeStrategies修改3.extends 允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。这和 mixins 类似。 extends示例 var CompA = { ... } // 在没有调用 `Vue.extend` 时候继承 CompA var CompB = { extends: CompA, ... } 4.总结： extend用于创建vue实例 mixins可以混入多个mixin，extends只能继承一个 mixins类似于面向切面的编程（AOP），extends类似于面向对象的编程 优先级Vue.extend>extends>mixins 28. Vue中的$attrs和$listener // father组件 import Child from './child' export default { component: { Child }, data() { tempdata: 'i am father' }, methods: { fatherFn: function() { console.log('father function!'); } } } // child组件 import Son from './son' export default { component: {Son}, props: { 'prop' }, data() { return {} }, mounted() { // 结果显示为$attrs.temp，不包含prop console.log(this.$attrs) this.$emit('tempFn') }, methods: {} } // son组件 {{ $attrs.temp }} export default { props: {}, data() { return {} }, mounted() { this.$emit('tempFn') }, methods: {} } 综上，可知： $listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器，它可以通过 v-on=”$listeners” 传入内部组件。 $attrs包含了父作用域中非props 特性绑定的属性 (class 和 style 除外)。当一个组件没有声明任何 props 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。 新增理解 其实$attrs，$listeners，$props都是一样的，我们可以通过当前组件实例访问到，具体包含如下： $attrs：当前组件的属性，通俗的讲也就是在组件标签定义的一系列属性，如input的value，placeholder等，但是不包括在当前组件里面定义的props属性 $listeners：当前组件监听的事件，通俗的讲也就是在使用组件的时候在标签中定义的事件，如@input，以及一些自定义事件@tempFn等 $props：当前组件从父组件那里接收的参数，通俗的讲和$attr差不多，但是只包括在当前组件中定义了的props属性 通俗的讲$attrs+$props = 在使用组件时定义的所有属性，不包括事件 那么在当前组件中使用v-bind=\"$attrs\"，v-bind=\"$props\"，v-on=\"$listeners\"也就是把之前父组件那里给它的属性再全部传到它的子组件。 29. Vue中的slots深层传递 现在假设有A，B，C三个组件，层级关系为A>B>C(爷爷，父亲，儿子) C: C组件 我是c组件(儿子)---外部没传递，我才显示 B: B组件---这是一个中间传递的slot A: A组件 {{data}}注意，我要传到C了 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-10-28 00:13:44 "},"Framework/前端/Vue/Interview/vue3.0.html":{"url":"Framework/前端/Vue/Interview/vue3.0.html","title":"vue3.0 ✘","keywords":"","body":"vue3.0为何弃用Object.defineProperty而选择Proxy 首先这两种都是基于数据劫持实现的双向绑定 vue2于vue3有什么不同，vue3有什么优势 1.vue3相比vue2更灵活了，因为vue3使用ts编写的对ts的支持更友好了 新增了composition API，可以抽离独立的业务逻辑，易于封装 2.vue3使用proxy重写了响应式系统 3.模板不用必须用根节点了 4.vue3内部使用了tree-shaking，在打包项目的时候只会把我们使用的功能打包进去，而不是将整个vue源码打包 什么是数据劫持? 当访问或者设置对象的属性的时候，触发相应的函数，并且返回或者设置属性的值。vue通过Object.defineProperty来劫持对象属性的getter和setter操作，当数据发生变化时发出通知。如下代码，实现了一个Observer const data= { name: 'xiaoming', sex: '男' } // 遍历对象,对其属性值进行劫持 Object.keys(data).forEach(key => { let val = data[key] Object.defineProperty(data, key, { enumerable: true, // 该属性可被枚举 configurable: true, // 该属性可以被删除以及属性描述符可以被改变 get () { console.log(`属性值${data}当前值为${val}`) return val }, set (newValue) { console.log(`监听到属性值${data}由${val}变为${newValue}`) val = newValue } }) }); data.name // 属性值name当前值为xiaoming data.name = 'huahua' // 监听到属性值name由xiaoming变为huahua data.sex // 属性值sex当前值为男 data.sex = '女' // 监听到属性值sex由男变为女 数据劫持的优势 不需要进行显示调用，vue的双向绑定原理就是通过数据劫持+发布订阅来实现的，比如angular的脏检查需要通过显示调用markForCheck，react则需要通过setState来进行显示调用 通过属性的劫持可以精准获得变化的内容，这部分不需要额外的diff操作，减少性能消耗 vue实现双向绑定 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。这里需要注意，递归的时候由于属性的值可能也是一个对象，在递归处理对象属性值的时候 ，递归循环引用对象很容易出现递归爆栈问题，在vue中已经通过定义ob对象记录已经被设置过setter和getter方法的对象，避免了此问题，但如果需要扩展对象，必须手动给新属性设置setter和getter方法，这就是为什么不在data中预先声明好的属性无法进行双向绑定，需要通过this.$set()来设置 this.$set(this.data.key, value) !注意，这是1.0的写法 this.$set(this.data,”key”,value) ！这个是2.0的写法 实现一个订阅者Watcher，作为连接Observer和Compile的桥梁，可以收到属性的变化通知并执行相应的函数，从而更新视图。 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 Object.defineProperty缺陷 将上文中我们的示例代码 属性值改为数组，数组也算是一种特殊的对象，下标其实就是对象的属性，理论上是可以通过Object.defineProperty来处理的，那尤大大为什么没有采用这种方式呢，猜测源于数组的使用场景，数组的主要操作场景是遍历，如果每一个元素都挂载set和get方法，会产生巨大性能消耗，而且数组下标变化频繁，操作方法居多，一旦数组长度发生变化，在无法自动检测的状态下，手动更新会是一个相当繁琐的工作 那vue中是如何实现对数组的劫持呢 肯定不能直接篡改Array.prototype 对象，因为会影响所有的数组实例，尤大大通过原型继承得到一个新的原型对象，在此基础上，劫持了7种常用的数组操作进行了重写，分别是push() 、pop() 、shift()、 unshift() 、splice() 、sort()、 reverse()，Vue.set()对于数组的处理其实就是调用了splice方法 Proxy的优势 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写，可以这样认为,Proxy是Object.defineProperty的全方位加强版 1.Proxy可以直接监听对象而非属性，并返回一个新对象 2.Proxy可以直接监听数组的变化 用法 Composition API如何替换Vue Mixins? mixin缺点： 命名冲突 const mixin = { data: () => ({ myProp: null }) } export default { mixins: [mixin], data: () => ({ // 同名! myProp: null }) } 快速入门Composition API Composition API的主要思想是，我们将它们定义为从新的 setup 函数返回的JavaScript变量，而不是将组件的功能（例如state、method、computed等）定义为对象属性。 以这个经典的Vue 2组件为例，它定义了一个“计数器”功能： //Counter.vue export default { data: () => ({ count: 0 }), methods: { increment() { this.count++; } }, computed: { double () { return this.count * 2; } } } 下面是使用Composition API定义的完全相同的组件。 // Counter.vue import { ref, computed } from \"vue\"; export default { setup() { const count = ref(0); const double = computed(() => count * 2) function increment() { count.value++; } return { count, double, increment } } } 首先会注意到，我们导入了 ref 函数，该函数允许我们定义一个响应式变量，其作用与 data 变量几乎相同。计算属性的情况与此相同。 increment 方法不是被动的，所以它可以被声明为一个普通的JavaScript函数。注意，我们需要更改子属性 count 的 value 才能更改响应式变量。这是因为使用 ref 创建的响应式变量必须是对象，以便在传递时保持其响应式。 定义完这些功能后，我们将从 setup 函数中将其返回。上面两个组件之间的功能没有区别，我们所做的只是使用替代API。 Composition API优点 1. 代码提取 Composition API的第一个明显优点是提取逻辑很容易。 让我们使用Composition API重构上面定义的组件，以使我们定义的功能位于JavaScript模块 useCounter 中（在特性描述前面加上“use”是一种Composition API命名约定。）。 //useCounter.js import { ref, computed } from \"vue\"; export default function () { const count = ref(0); const double = computed(() => count * 2) function increment() { count.value++; } return { count, double, increment } } 2. 代码重用 要在组件中使用该函数，我们只需将模块导入组件文件并调用它（注意导入是一个函数）。这将返回我们定义的变量，随后我们可以从 setup 函数中返回它们。 // MyComponent.js import useCounter from \"./useCounter.js\"; export default { setup() { const { count, double, increment } = useCounter(); return { count, double, increment } } } 乍一看，这似乎有点冗长而毫无意义，但让我们来看看这种模式如何克服了前面讨论的mixins问题。 3. 命名冲突解决了 我们之前已经了解了mixin如何使用与消费者组件中的名称相同的属性，或者甚至更隐蔽地使用了消费者组件使用的其他mixin中的属性。 这不是Composition API的问题，因为我们需要显式命名任何状态或从合成函数返回的方法。 export default { setup () { const { someVar1, someMethod1 } = useCompFunction1(); const { someVar2, someMethod2 } = useCompFunction2(); return { someVar1, someMethod1, someVar2, someMethod2 } } } 命名冲突的解决方式与其他任何JavaScript变量相同。 4.隐式依赖...解决了！ 前面还看到mixin如何使用在消费组件上定义的 data 属性，这可能会使代码变得脆弱，并且很难进行推理。 合成函数(Composition Function)还可以调用消费组件中定义的局部变量。不过，不同之处在于，现在必须将此变量显式传递给合成函数。 import useCompFunction from \"./useCompFunction\"; export default { setup () { // 某个局部值的合成函数需要用到 const myLocalVal = ref(0); // 它必须作为参数显式地传递 const { ... } = useCompFunction(myLocalVal); } } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-06-15 22:07:24 "},"Framework/前端/Vue/Interview/vuex面试题.html":{"url":"Framework/前端/Vue/Interview/vuex面试题.html","title":"vuex面试题 ✘","keywords":"","body":"vuex面试题 ===  0.vuex实现原理？  1.vuex中为什么把把异步操作封装在action，把同步操作放在mutations？  2.Vuex 模块化+命名空间后, 如何调用其他模块的 state, actions, mutations, getters ？  3.怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？  4.怎么在组件中批量给Vuex的getter属性取别名并使用?  5.在action函数中返回Promise，然后再提交时候用then处理?  6.Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现?  7.在v-model上怎么用Vuex中state的值?  8. 在v-Vuex插件有用过吗？怎么用简单介绍一下? 在Vuex插件中怎么监听组件中提交mutation和action？ 0. vuex实现原理？ store注入组件install方法 vuex是通过vue插件机制将组件注入的 首先使用vuex,需要安装插件： Vue.use(Vuex); // vue的插件机制,安装vuex插件 当ues(Vuex)时候，会调用vuex中的install方法，装在vuex! 下面时install的核心源码： Vue.mixin({ beforeCreate() { if (this.$options && this.$options.store) { //找到根组件 main 上面挂一个$store this.$store = this.$options.store // console.log(this.$store); } else { //非根组件指向其父组件的$store this.$store = this.$parent && this.$parent.$store } } }) 可见，store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期 钩子 beforeCreate 完成的。即 每个vue组件实例化过程中，会在 beforeCreate 钩子前调用 vuexInit 方法。 vuex中的数据双向绑定 this._s = new Vue({ data: { // 只有data中的数据才是响应式 state: options.state } }) getters实现 //实现getters原理 let getters = options.getters || {} // console.log(getters); // this.getters = getters; //不是直接挂载到 getters上 这样只会拿到整个 函数体 this.getters = {}; // console.log(Object.keys(getters)) // [\"myAge\",\"myName\"] Object.keys(getters).forEach((getterName) => { // console.log(getterName) // myAge // 将getterName 放到this.getters = {}中 // console.log(this.state); Object.defineProperty(this.getters, getterName, { // 当你要获取getterName（myAge）会自动调用get方法 // 箭头函数中没有this get: () => { return getters[getterName](this.state) } }) }) 从上面源码，我们可以看出Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。 mutations实现 let mutations = options.mutations || {} // console.log(mutations); this.mutations = {}; Object.keys(mutations).forEach(mutationName=>{ // console.log(mutationName); this.mutations[mutationName] = (payload) =>{ this.mutations[mutationName](this.state,payload) } }) actions实现 // actions的原理 let actions = options.actions || {} this.actions = {}; forEach(actions,(actionName,value)=>{ this.actions[actionName] = (payload)=>{ value(this,payload) } }) commit dispatch的实现 commit(type,payload){ this.mutations[type](payload) } // type是actions的类型 dispatch=(type,payload)=>{ this.actions[type](payload) } Vuex是通过全局注入store对象，来实现组件间的状态共享。在大型复杂的项目中（多级组件嵌套），需要实现一个组件更改某个数据，多个组件自动获取更改后的数据进行业务逻辑处理，这时候使用vuex比较合适。假如只是多个组件间传递数据，使用vuex未免有点大材小用，其实只用使用组件间常用的通信方法即可。 1. vuex中为什么把把异步操作封装在action，把同步操作放在mutations？ 官方回答： 正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。 2. Vuex 模块化+命名空间后, 如何调用其他模块的 state, actions, mutations, getters ? 假设有这么两个模块: 模块A: import api from '~api' const state = { vip: {}, } const actions = { async ['get']({commit, state, dispatch}, config = {}) { try { const { data: { code, data } } = await api.post('vip/getVipBaseInfo', config) if (code === 1001) commit('receive', data) } catch(error) { console.log(error) } } } const mutations = { ['receive'](state, data) { state.vip = data } } const getters = { ['get'](state) { return state.vip }, } export default { namespaced: true, state, actions, mutations, getters } 模块B: import api from '~api' const state = { shop: {}, } const actions = { async ['get']({commit, state, dispatch}, config = {}) { try { const { data: { code, data } } = await api.post('shop/getShopBaseInfo', config) if (code === 1001) commit('receive', data) } catch(error) { console.log(error) } } } const mutations = { ['receive'](state, data) { state.shop = data } } const getters = { ['get'](state) { return state.shop }, } export default { namespaced: true, state, actions, mutations, getters } 假设模块 B 的 actions 里, 需要用模块 A 的 state 该怎么办? const actions = { async ['shop'](store, config = {}) { const { commit, dispatch, state, rootState } = store console.log(rootState) // 打印根 state console.log(rootState.vip) // 打印其他模块的 state try { const { data: { code, data } } = await api.post('shop/getShopBaseInfo', config) if (code === 1001) commit('receive', data) } catch(error) { console.log(error) } } } 我们来看下上面的代码, actions 中的 shop 方法, 有 2 个参数, 第一个是 store, 第二个是 dispatch 调用时传过来的参数 store 这个对象又包含了 4 个键, 其中 commit 是调用 mutations 用的, dispatch 是调用 actions 用的, state 是当前模块的 state, 而 rootState 是根 state, 既然能拿到根 state, 想取其他模块的 state 是不是就很简单了...? 假设模块 B 的 actions 里, 需要调用模块 A 的 actions 该怎么办? const actions = { async ['shop'](store, config = {}) { const { commit, dispatch, state, rootState } = store try { const { data: { code, data } } = await api.post('shop/getShopBaseInfo', config, 'get') if (code === 1001) commit('receive', data) // 调用当前模块的 mutations dispatch('vip/get', {}, {root: true}) // 调用其他模块的 actions } catch(error) { console.log(error) } } } 上面的代码中dispatch('vip/vip', {}, {root: true})就是在模块 B 调用 模块 A 的 actions, 有 3 个参数, 第一个参数是其他模块的 actions 路径, 第二个是传给 actions 的数据, 如果不需要传数据, 也必须预留, 第三个参数是配置选项, 申明这个 acitons 不是当前模块的 假设模块 B 的 actions 里, 需要调用模块 A 的 mutations 该怎么办? const actions = { async ['shop'](store, config = {}) { const { commit, dispatch, state, rootState } = store try { const { data: { code, data } } = await api.post('shop/getShopBaseInfo', config) if (code === 1001) commit('receive', data) // 调用当前模块的 mutations commit('vip/receive', data, {root: true}) // 调用其他模块的 mutations } catch(error) { console.log(error) } } } 上面的代码中commit('vip/receive', {}, {root: true})就是在模块 B 调用 模块 A 的 mutations, 有 3 个参数, 第一个参数是其他模块的 mutations 路径, 第二个是传给 mutations 的数据, 如果不需要传数据, 也必须预留, 第三个参数是配置选项, 申明这个 mutations 不是当前模块的 假设模块 B 的 actions 里, 需要用模块 A 的 getters 该怎么办? const actions = { async ['shop'](store, config = {}) { const { commit, dispatch, state, rootState, rootGetters } = store console.log(rootGetters['vip/get']) // 打印其他模块的 getters try { const { data: { code, data } } = await api.post('shop/getShopBaseInfo', config) if (code === 1001) commit('receive', data) } catch(error) { console.log(error) } } } 我们来看下上面的代码, 相比之前的代码, store 又多了一个键: rootGetters rootGetters 就是 vuex 中所有的 getters, 你可以用 rootGetters['xxxxx'] 来取其他模块的getters 怎么在带命名空间的模块内注册全局的action？ actions: { actionA: { root: true, handler (context, data) { ... } } } 组件中怎么提交modules中的带命名空间的moduleA中的mutationA？ this.$store.commit('moduleA/mutationA',data) 怎么使用mapState，mapGetters，mapActions和mapMutations这些函数来绑定带命名空间的模块？ 首先使用createNamespacedHelpers创建基于某个命名空间辅助函数? import { createNamespacedHelpers } from 'vuex'; const { mapState, mapActions } = createNamespacedHelpers('moduleA'); export default { computed: { // 在 `module/moduleA` 中查找 ...mapState({ a: state => state.a, b: state => state.b }) }, methods: { // 在 `module/moduleA` 中查找 ...mapActions([ 'actionA', 'actionB' ]) } } 3. 怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？ 通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。 const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { getTodoById: (state) => (id) =>{ return state.todos.find(todo => todo.id === id) } }, }); 然后在组件中可以用计算属性computed通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。 computed: { getTodoById() { return this.$store.getters.getTodoById }, } mounted(){ console.log(this.getTodoById(2).done)//false } 4. 怎么在组件中批量给Vuex的getter属性取别名并使用? 使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 import {mapGetters} from 'vuex' export default{ computed:{ ...mapGetters({ myTotal:'total', myDiscountTotal:'discountTotal', }) } } Vuex中action通常是异步的，那么如何知道action什么时候结束呢？ 5. 在action函数中返回Promise，然后再提交时候用then处理? actions:{ SET_NUMBER_A({commit},data){ return new Promise((resolve,reject) =>{ setTimeout(() =>{ commit('SET_NUMBER',10); resolve(); },2000) }) } } this.$store.dispatch('SET_NUMBER_A').then(() => { // ... }) 6. Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现? 利用ES6的async和await来实现。 actions:{ async actionA({commit}){ //... }, async actionB({dispatch}){ await dispatch ('actionA')//等待actionA完成 // ... } } 7. 在v-model上怎么用Vuex中state的值? 需要通过computed计算属性来转换。 ``` // ... computed: { message: { get () { return this.$store.state.message }, set (value) { this.$store.commit('updateMessage', value) } } } ``` 8. 在v-Vuex插件有用过吗？怎么用简单介绍一下? 在Vuex插件中怎么监听组件中提交mutation和action？ Vuex插件就是一个函数，它接收 store 作为唯一参数。在Vuex.Store构造器选项plugins引入。 在store/plugin.js文件中写入 export default function createPlugin(param){ return store =>{ //... } } 然后在store/index.js文件中写入 import createPlugin from './plugin.js' const myPlugin = createPlugin() const store = new Vuex.Store({ // ... plugins: [myPlugin] }) 在Vuex插件中怎么监听组件中提交mutation和action？ 用Vuex.Store的实例方法subscribe监听组件中提交mutation 用Vuex.Store的实例方法subscribeAction监听组件中提交action 在store/plugin.js文件中写入 export default function createPlugin(param) { return store => { store.subscribe((mutation, state) => { console.log(mutation.type)//是那个mutation console.log(mutation.payload) console.log(state) }) // store.subscribeAction((action, state) => { // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // }) store.subscribeAction({ before: (action, state) => {//提交action之前 console.log(`before action ${action.type}`) }, after: (action, state) => {//提交action之后 console.log(`after action ${action.type}`) } }) } } 然后在store/index.js文件中写入 import createPlugin from './plugin.js' const myPlugin = createPlugin() const store = new Vuex.Store({ // ... plugins: [myPlugin] }) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-19 15:10:24 "},"Framework/前端/Vue/Interview/vue-router面试题.html":{"url":"Framework/前端/Vue/Interview/vue-router面试题.html","title":"vue-router面试题 ✘","keywords":"","body":"vuex面试题  1.Vue路由怎么跳转打开新窗口？  2.什么是命名视图，举个例子说明一下？  3.怎么重定向页面？  4.路由有几种模式？说说它们的区别？ 1. Vue##怎么跳转打开新窗口？ const obj = { path: xxx,//路由地址 query: { mid: data.id//可以带参数 } }; const {href} = this.$router.resolve(obj); window.open(href, '_blank'); 2. 什么是命名视图，举个例子说明一下？ 在项目中，我们想同级展示多个视图，而不是嵌套展示。例如项目首页，有头部导航，侧边栏导航、主内容区域。头部导航、侧边栏导航我们不想用组件方式引入，想用视图方式展示。那么这个首页上，就有三个视图，头部导航视图，侧边栏导航视图、主内容区域视图同级展示。 在layout.vue文件中 //...头部导航 //...侧边栏导航 //...主内容 如果 router-view 没有设置name，那么默认为default。一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (记得加上s)。 在routes.js文件中 function load(component) { return resolve => require([`views/${component}`], resolve); } const routes=[ { path: '/', redirect: '/home', name: 'layout', component: load('layout'), children: [ { path: '/home', name: 'home', components: { default: load('main'), header: load('header'), sider: load('sider') }, meta: { title: '首页' }, }, ] } ] 3. 怎么重定向页面？ 第一种方法： const router = new VueRouter({ routes: [ { path: '/a', redirect: '/b' } ] }) 第二种方法: const router = new VueRouter({ routes: [ { path: '/a', redirect: { name: 'foo' }} ] }) 第三种方法： const router = new VueRouter({ routes: [ { path: '/a', redirect: to =>{ const { hash, params, query } = to if (query.to === 'foo') { return { path: '/foo', query: null } }else{ return '/b' } } } ] }) 4. 路由有几种模式？说说它们的区别？ hash 兼容所有浏览器，包括不支持 HTML5 History Api 的浏览器，例http://www.abc.com/#/index，hash值为#/index， hash的改变会触发hashchange事件，通过监听hashchange事件来完成操作实现前端路由。hash值变化不会让浏览器向服务器请求。 // 监听hash变化，点击浏览器的前进后退会触发 window.addEventListener('hashchange', function(event){ let newURL = event.newURL; // hash 改变后的新 url let oldURL = event.oldURL; // hash 改变前的旧 url },false) history HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： window.history.pushState(null, null, path); window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染） 在history模式中，在window上监听popstate事件（浏览器的前进或后退按钮的点击触发）驱动界面变化，监听a链接点击事件用history.pushState、history.replaceState方法驱动界面变化； 没有#，路由地址跟正常的url一样，但是初次访问或者刷新都会向服务器请求，如果没有请求到对应的资源就会返回404，所以路由地址匹配不到任何静态资源，则应该返回同一个index.html 页面，需要在nginx中配置。 abstract 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-19 18:08:16 "},"Framework/前端/小程序面试.html":{"url":"Framework/前端/小程序面试.html","title":"小程序 ✘","keywords":"","body":"目录  1. 简单描述下微信小程序的相关文件类型  2. 简述微信小程序原理  3. 小程序的双向绑定和vue哪里不一样  4. 小程序的wxss和css有哪些不一样的地方  5. 小程序页面间有哪些传递数据的方法  6. 小程序的生命周期函数  7. 怎么封装微信小程序的数据请求  8. 哪些方法可以用来提高微信小程序的应用速度  9. 微信小程序的优劣势  10. 怎么解决小程序的异步请求问题  11. 小程序关联微信公众号如何确定用户的唯一性  12. 如何实现下拉刷新  13. bindtap和catchtap的区别是什么  14. 简述下wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别 1. 简单描述下微信小程序的相关文件类型 微信小程序项目结构主要有四个文件类型 WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式 js 逻辑处理，网络请求 json 小程序设置，如页面注册，页面标题及tabBar 主要文件 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景色，配置导航条样式，配置默认标题 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量 app.wxss 可选 2. 简述微信小程序原理 微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口 微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 小程序分为两个部分 webview 和 appService 。其中 webview 主要用来展现 UI，appService 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理 3. 小程序的双向绑定和vue哪里不一样 小程序直接 this.data 的属性是不可以同步到视图的，必须调用： this.setData({ // 这里设置 }) 4. 小程序的wxss和css有哪些不一样的地方 WXSS 和 CSS 类似，不过在 CSS 的基础上做了一些补充和修改 尺寸单位 rpx rpx 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素 使用 @import 标识符来导入外联样式。@import 后跟需要导入的外联样式表的相对路径，用;表示语句结束 /** index.wxss **/ @import './base.wxss'; .container{ color: red; } 5. 小程序页面间有哪些传递数据的方法 使用全局变量实现数据传递 在 app.js 文件中定义全局变量 globalData， 将需要存储的信息存放在里面 // app.js App({ // 全局变量 globalData: { userInfo: null } }) 使用的时候，直接使用 getApp() 拿到存储的信息 使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化 //pageA.js // Navigate wx.navigateTo({ url: '../pageD/pageD?name=raymond&gender=male', }) // Redirect wx.redirectTo({ url: '../pageD/pageD?name=raymond&gender=male', }) // pageB.js ... Page({ onLoad: function(option){ console.log(option.name + 'is' + option.gender) this.setData({ option: option }) } }) 需要注意的问题： wx.navigateTo 和 wx.redirectTo 不允许跳转到 tab 所包含的页面 onLoad 只执行一次 使用本地缓存 Storage 相关 6. 小程序的生命周期函数 onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数 onShow() 页面显示/切入前台时触发 onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互 onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等 onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时 详见 生命周期回调函数 7. 怎么封装微信小程序的数据请求 参考 这里 8. 哪些方法可以用来提高微信小程序的应用速度 1、提高页面加载速度 2、用户行为预测 3、减少默认 data 的大小 4、组件化方案 9. 微信小程序的优劣势 优势 即用即走，不用安装，省流量，省安装时间，不占用桌面 依托微信流量，天生推广传播优势 开发成本比 App 低 缺点 用户留存，即用即走是优势，也存在一些问题 入口相对传统 App 要深很多 限制较多,页面大小不能超过1M。不能打开超过5个层级的页面 10. 怎么解决小程序的异步请求问题 小程序支持 ES6 语法 在返回成功的回调里面处理逻辑 Promise 异步 async/await 11. 小程序关联微信公众号如何确定用户的唯一性 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid 是相同的 12. 如何实现下拉刷新 首先在全局 config 中的 window 配置 enablePullDownRefresh 在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法 请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新 参考 这里 13. bindtap和catchtap的区别是什么 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分 不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的 14. 简述下 `wx.navigateTo()`, `wx.redirectTo()`, `wx.switchTab()`, `wx.navigateBack()`, `wx.reLaunch()`的区别 wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面 wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面 wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 wx.reLaunch()：关闭所有页面，打开到应用内的某个页面 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-24 21:06:32 "},"Framework/前端/vue和react对比.html":{"url":"Framework/前端/vue和react对比.html","title":"vue和react对比 ✘","keywords":"","body":"相同点 都支持服务器端渲染 都有Virtual DOM（虚拟dom）,组件化开发,都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据,都实现webComponent规范 数据驱动视图 都有支持native的方案,React的React native,Vue的weex 构建工具 React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。都有管理状态，React有redux,Vue有自己的Vuex（自适应vue，量身定做） 区别 设计思想 react 函数式思想，all in js ,jsx语法，js操控css 单项数据流 setState重新渲染 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，如果为true继续渲染、false不渲染，但Vue将此视为默认的优化。 vue 响应式思想，也就是基于数据可变的。把html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中 双向绑定，每一个属性都需要建立watch监听（页面不用，涉及到组件更新的话需要） Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树 性能 react ----大型项目 优化需要手动去做，状态可控 vue ------中小型项目 状态改变需要watch监听，数据量太大的话会卡顿 扩展性 react 1 类式写法api少，更容易结合ts 2 可以通过高阶组件来扩展 vue 1 声明式写法，结合ts比较复杂 2 需要通过mixin方式来扩展 React刚开始也有mixin的写法，通过React.createClass的api，不过现在很少用了。 Vue也不是不能实现高阶组件，只是特别麻烦，因为Vue对与组件的option做了各种处理，想实现高阶组件就要知道每一个option是怎么处理的，然后正确的设置。具体有多复杂，可以参考下面的文章。 http://hcysun.me/2018/01/05/探索Vue高阶组件/ https://segmentfault.com/a/1190000011962150 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-14 14:44:43 "},"Framework/前端/vue2.0双向绑定原理以及简易实现.html":{"url":"Framework/前端/vue2.0双向绑定原理以及简易实现.html","title":"vue2.0双向绑定原理以及简易实现 ✘","keywords":"","body":"vue2.0双向绑定原理 前言 使用vue也好有一段时间了，虽然对其双向绑定原理也有了解个大概，但也没好好探究下其原理实现，所以这次特意花了几晚时间查阅资料和阅读相关源码，自己也实现一个简单版vue的双向绑定版本，先上个成果图来吸引各位： 代码： 效果图： 是不是看起来跟vue的使用方式差不多？接下来就来从原理到实现，从简到难一步一步来实现这个SelfVue。由于本文只是为了学习和分享，所以只是简单实现下原理，并没有考虑太多情况和设计，如果大家有什么建议，欢迎提出来。 本文主要介绍两大内容： 1. vue数据双向绑定的原理。 2. 实现简单版vue的过程，主要{{}}、v-model和事件指令的功能 相关代码地址：https://github.com/canfoo/self-vue vue数据双向绑定原理 vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，我们可以先来看一下通过控制台输出一个定义在vue初始化数据上的对象是个什么东西。 代码： var vm = new Vue({ data: { obj: { a: 1 } }, created: function () { console.log(this.obj); } }); 结果： 我们可以看到属性a有两个相对应的get和set方法，为什么会多出这两个方法呢？因为vue是通过Object.defineProperty()来实现数据劫持的。 Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set，如果还不熟悉其用法，请点击这里阅读更多用法。 在平常，我们很容易就可以打印出一个对象的属性数据： var Book = { name: 'vue权威指南' }; console.log(Book.name); // vue权威指南 如果想要在执行console.log(book.name)的同时，直接给书名加个书名号，那要怎么处理呢？或者说要通过什么监听对象 Book 的属性值。这时候Object.defineProperty( )就派上用场了，代码如下： var Book = {} var name = ''; Object.defineProperty(Book, 'name', { set: function (value) { name = value; console.log('你取了一个书名叫做' + value); }, get: function () { return '《' + name + '》' } }) Book.name = 'vue权威指南'; // 你取了一个书名叫做vue权威指南 console.log(Book.name); // 《vue权威指南》 我们通过Object.defineProperty( )设置了对象Book的name属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数，所以当执行 Book.name = 'vue权威指南' 这个语句时，控制台会打印出 \"你取了一个书名叫做vue权威指南\"，紧接着，当读取这个属性时，就会输出 \"《vue权威指南》\"，因为我们在get函数里面对该值做了加工了。如果这个时候我们执行下下面的语句，控制台会输出什么？ console.log(Book); 结果： 乍一看，是不是跟我们在上面打印vue数据长得有点类似，说明vue确实是通过这种方法来进行数据劫持的。接下来我们通过其原理来实现一个简单版的mvvm双向绑定代码。 思路分析 实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据： 关键点在于data如何更新view，因为view更新data其实可以通过事件监听即可，比如input标签监听 'input' 事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的。 数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。 思路有了，接下去就是实现过程了。 实现过程 我们已经知道实现数据的双向绑定， 首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定： 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 流程图如下： 1.实现一个Observer Observer是一个数据监听器，其实现核心方法就是前文所说的Object.defineProperty( )。如果要对所有属性都进行监听的话，那么可以通过递归方法遍历所有属性值，并对其进行Object.defineProperty( )处理。如下代码，实现了一个Observer。 function defineReactive(data, key, val) { observe(val); // 递归遍历所有子属性 Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { return val; }, set: function(newVal) { val = newVal; console.log('属性' + key + '已经被监听了，现在值为：“' + newVal.toString() + '”'); } }); } function observe(data) { if (!data || typeof data !== 'object') { return; } Object.keys(data).forEach(function(key) { defineReactive(data, key, data[key]); }); }; var library = { book1: { name: '' }, book2: '' }; observe(library); library.book1.name = 'vue权威指南'; // 属性name已经被监听了，现在值为：“vue权威指南” library.book2 = '没有此书籍'; // 属性book2已经被监听了，现在值为：“没有此书籍” 思路分析中，需要创建一个可以容纳订阅者的消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。所以显然订阅器需要有一个容器，这个容器就是list，将上面的Observer稍微改造下，植入消息订阅器： function defineReactive(data, key, val) { observe(val); // 递归遍历所有子属性 var dep = new Dep(); Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { if (是否需要添加订阅者) { dep.addSub(watcher); // 在这里添加一个订阅者 } return val; }, set: function(newVal) { if (val === newVal) { return; } val = newVal; console.log('属性' + key + '已经被监听了，现在值为：“' + newVal.toString() + '”'); dep.notify(); // 如果数据变化，通知所有订阅者 } }); } function Dep () { this.subs = []; } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; 从代码上看，我们将订阅器Dep添加一个订阅者设计在getter里面，这是为了让Watcher初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在setter函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数。到此为止，一个比较完整Observer已经实现了，接下来我们开始设计Watcher。 2.实现Watcher 订阅者Watcher在初始化的时候需要将自己添加进订阅器Dep中，那该如何添加呢？我们已经知道监听器Observer是在get函数执行了添加订阅者Wather的操作的，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作即可，那要如何触发get的函数，再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了Object.defineProperty( )进行数据监听。这里还有一个细节点需要处理，我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在Dep.target上缓存下订阅者，添加成功后再将其去掉就可以了。订阅者Watcher的实现如下： function Watcher(vm, exp, cb) { this.cb = cb; this.vm = vm; this.exp = exp; this.value = this.get(); // 将自己添加到订阅器的操作 } Watcher.prototype = { update: function() { this.run(); }, run: function() { var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); } }, get: function() { Dep.target = this; // 缓存自己 var value = this.vm.data[this.exp] // 强制执行监听器里的get函数 Dep.target = null; // 释放自己 return value; } }; 这时候，我们需要对监听器Observer也做个稍微调整，主要是对应Watcher类原型上的get函数。需要调整地方在于defineReactive函数： function defineReactive(data, key, val) { observe(val); // 递归遍历所有子属性 var dep = new Dep(); Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { if (Dep.target) {. // 判断是否需要添加订阅者 dep.addSub(Dep.target); // 在这里添加一个订阅者 } return val; }, set: function(newVal) { if (val === newVal) { return; } val = newVal; console.log('属性' + key + '已经被监听了，现在值为：“' + newVal.toString() + '”'); dep.notify(); // 如果数据变化，通知所有订阅者 } }); } Dep.target = null; 到此为止，简单版的Watcher设计完毕，这时候我们只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了。因为这里没有还没有设计解析器Compile，所以对于模板数据我们都进行写死处理，假设模板上又一个节点，且id号为'name'，并且双向绑定的绑定的变量也为'name'，且是通过两个大双括号包起来（这里只是为了演示，暂时没什么用处），模板如下： {{name}} 这时候我们需要将Observer和Watcher关联起来： function SelfVue (data, el, exp) { this.data = data; observe(data); el.innerHTML = this.data[exp]; // 初始化模板数据的值 new Watcher(this, exp, function (value) { el.innerHTML = value; }); return this; } 然后在页面上new以下SelfVue类，就可以实现数据的双向绑定了： {{name}} var ele = document.querySelector('#name'); var selfVue = new SelfVue({ name: 'hello world' }, ele, 'name'); window.setTimeout(function () { console.log('name值改变了'); selfVue.data.name = 'canfoo'; }, 2000); 这时候打开页面，可以看到页面刚开始显示了是'hello world'，过了2s后就变成'canfoo'了。到这里，总算大功告成一半了，但是还有一个细节问题，我们在赋值的时候是这样的形式 ' selfVue.data.name = 'canfoo' ' 而我们理想的形式是' selfVue.name = 'canfoo' '为了实现这样的形式，我们需要在new SelfVue的时候做一个代理处理，让访问selfVue的属性代理为访问selfVue.data的属性，实现原理还是使用Object.defineProperty( )对属性值再包一层： function SelfVue (data, el, exp) { var self = this; this.data = data; Object.keys(data).forEach(function(key) { self.proxyKeys(key); // 绑定代理属性 }); observe(data); el.innerHTML = this.data[exp]; // 初始化模板数据的值 new Watcher(this, exp, function (value) { el.innerHTML = value; }); return this; } SelfVue.prototype = { proxyKeys: function (key) { var self = this; Object.defineProperty(this, key, { enumerable: false, configurable: true, get: function proxyGetter() { return self.data[key]; }, set: function proxySetter(newVal) { self.data[key] = newVal; } }); } } 这下我们就可以直接通过' selfVue.name = 'canfoo' '的形式来进行改变模板数据了。如果想要迫切看到现象的童鞋赶快来获取代码！ 3.实现Compile 虽然上面已经实现了一个双向数据绑定的例子，但是整个过程都没有去解析dom节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器Compile来做解析和绑定工作。解析器Compile实现步骤： 解析模板指令，并替换模板数据，初始化视图 将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器 为了解析模板，首先需要获取到dom元素，然后对含有dom元素上含有指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理： function nodeToFragment (el) { var fragment = document.createDocumentFragment(); var child = el.firstChild; while (child) { // 将Dom元素移入fragment中 // appendChild这个方法是将dom节点进行移动，而不是copy fragment.appendChild(child); child = el.firstChild } return fragment; } 接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理，这里咱们先处理最简单的情况，只对带有 '' 这种形式的指令进行处理，先简道难嘛，后面再考虑更多指令情况： function compileElement (el) { var childNodes = el.childNodes; var self = this; [].slice.call(childNodes).forEach(function(node) { var reg = /\\{\\{(.*)\\}\\}/; var text = node.textContent; if (self.isTextNode(node) && reg.test(text)) { // 判断是否是符合这种形式\\{\\{\\}\\}的指令 self.compileText(node, reg.exec(text)[1]); } if (node.childNodes && node.childNodes.length) { self.compileElement(node); // 继续递归遍历子节点 } }); }, function compileText (node, exp) { var self = this; var initText = this.vm[exp]; updateText(node, initText); // 将初始化的数据初始化到视图中 new Watcher(this.vm, exp, function (value) { // 生成订阅器并绑定更新函数 self.updateText(node, value); }); }, function updateText (node, value) { node.textContent = typeof value == 'undefined' ? '' : value; } 获取到最外层节点后，调用compileElement函数，对所有子节点进行判断，如果节点是文本节点且匹配{{}}这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤2。这样就完成指令的解析、初始化、编译三个过程，一个解析器Compile也就可以正常的工作了。为了将解析器Compile与监听器Observer和订阅者Watcher关联起来，我们需要再修改一下类SelfVue函数： function SelfVue (options) { var self = this; this.vm = this; this.data = options; Object.keys(this.data).forEach(function(key) { self.proxyKeys(key); }); observe(this.data); new Compile(options, this.vm); return this; } 更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了： {{title}} {{name}} var selfVue = new SelfVue({ el: '#app', data: { title: 'hello world', name: '' } }); window.setTimeout(function () { selfVue.title = '你好'; }, 2000); window.setTimeout(function () { selfVue.name = 'canfoo'; }, 2500); 如上代码，在页面上可观察到，刚开始titile和name分别被初始化为 'hello world' 和空，2s后title被替换成 '你好' 3s后name被替换成 'canfoo' 了。废话不多说，再给你们来一个这个版本的代码（v2），获取代码！ 到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？答案很明显，只要在上文说的compileElement函数加上对其他指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性，如果有的话，就对其进行解析编译。这里我们再添加一个v-model指令和事件指令的解析编译，对于这些节点我们使用函数compile进行解析处理： function compile (node) { var nodeAttrs = node.attributes; var self = this; Array.prototype.forEach.call(nodeAttrs, function(attr) { var attrName = attr.name; if (self.isDirective(attrName)) { var exp = attr.value; var dir = attrName.substring(2); if (self.isEventDirective(dir)) { // 事件指令 self.compileEvent(node, self.vm, exp, dir); } else { // v-model 指令 self.compileModel(node, self.vm, exp, dir); } node.removeAttribute(attrName); } }); } 上面的compile函数是挂载Compile原型上的，它首先遍历所有节点属性，然后再判断属性是否是指令属性，如果是的话再区分是哪种指令，再进行相应的处理，处理方法相对来说比较简单，这里就不再列出来，想要马上看阅读代码的同学可以马上点击这里获取。 最后我们在稍微改造下类SelfVue，使它更像vue的用法： function SelfVue (options) { var self = this; this.data = options.data; this.methods = options.methods; Object.keys(this.data).forEach(function(key) { self.proxyKeys(key); }); observe(this.data); new Compile(options.el, this); options.mounted.call(this); // 所有事情处理好后执行mounted函数 } 这时候我们可以来真正测试了，在页面上设置如下东西： {{title}} {{name}} click me! new SelfVue({ el: '#app', data: { title: 'hello world', name: 'canfoo' }, methods: { clickMe: function () { this.title = 'hello world'; } }, mounted: function () { window.setTimeout(() => { this.title = '你好'; }, 1000); } }); 是不是看起来跟vue的使用方法一样，哈，真正的大功告成！想要代码，直接点击这里获取！现象还没描述？直接上图！！！请观赏 其实这个效果图，就是本文开头贴出来的效果图了，前文说着要带着大家实现，所以就在这里把图再贴一次了，这叫首尾呼应嘛。 最后希望本文对你有帮助，如果有问题请留言一起探讨。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-12 10:00:56 "},"Coding/js/手写代码.html":{"url":"Coding/js/手写代码.html","title":"js手写代码 ✘","keywords":"","body":"js手写代码  1. 函数节流  2. 函数防抖  3. 手写promise  4. 用Promise对象实现的Ajax  5. 阶乘的实现方法（递归）  6. 实现一个JSON.stringify  7. 写一个sum函数满足无限传参的条件  8. 转换成数组的方法  9. 扁平化数组  10. 实现一个div滑动的动画，由快至慢5s结束  11. 实现一个div滑动的动画，由快至慢到500px结束  12.JSONP的实现步骤  13.数组排序（先按age升序相等则按name升序）  14.阶乘实现第一项为1，后一项是（前面所有项之和）*2  15.JS实现sleep()方法  16.不借助变量交换两个数  17.大数相加  18.什么是深拷贝，和浅拷贝有什么区别，动手实现一个深拷贝 算法相关  1. JS实现的数组全排列输出算法  2. 判断一个单词是否是回文？  3. 去掉一组整型数组重复的值  4. 随机生成指定长度的字符串  5. js中的广度优先遍历（BFS）和深度优先遍历（DF） https://www.jianshu.com/p/b4d8085e84bd https://www.jianshu.com/p/5e9ea25a1aae  6.反转字符串  7.反转字符串中的单词  8.反转链表 /** @param {character[]} s @return {void} Do not return anything, modify s in-place instead. */ // 双指针 var reverseString = function(s) { let left = 0, right = s.length - 1; while( left 基础 1. 函数节流 将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。 　　也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。 function throttle(fn,delay){ let timer = null; let startTime = +new Date() return function(...args){ let curTime = +new Date() let remaining = delay - (curTime -startTime) const context = this clearTimeout(timer) if(remaining2. 函数防抖 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间 function debounce(fn,wait=50,immediate) { let timer; return function() { if(immediate) { fn.apply(this,arguments) } if(timer) clearTimeout(timer) timer = setTimeout(()=> { fn.apply(this,arguments) },wait) } } 3. 手写promise 简化版 //简易promise实现(resolve,reject) function promise(fn) { this.value = undefined // 成功状态值 this.err = undefined // 失败状态值 this.status = 'pending' // 开始状态（就绪） var t = this // 就绪 -> 成功 function resolve(val) { if (t.status === 'pending') { t.value = val t.status = 'success' } } // 就绪 -> 失败 function reject(err) { if (t.status === 'pending') { t.err = err t.status = 'fail' } } fn(resolve, reject) } promise.prototype.then = function(isSuccess, isFail) { var t = this // 实现promise的链式调用 return new promise(function(resolve, reject) { // 用setTimeout模拟实现then方法的异步操作 setTimeout(function() { if (t.status === 'success') { // 将then1回调函数返回的值传给then2回调函数，以此类推 resolve(isSuccess(t.value)) } if (t.status === 'fail') { reject(isFail(t.err)) } }) }) } // test var p = new promise(function(resolve, reject) { if (1) { resolve(\"test resolve success\") } else { reject(\"test rejecr fail\") } }) p.then(function(val) { console.log(val) return val + \"链式调用return\" }).then(function(val) { console.log(val) }) // test resolve success // test resolve success链式调用return 升级版 const PENDING = \"pending\"; const FULFILLED = \"fulfilled\"; const REJECTED = \"rejected\"; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() => { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb => cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() => { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 => rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb => cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) => { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); } } Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value => value; onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason; }; if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) => { setTimeout(() => { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) => { setTimeout(() => { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) => { that.onFulfilledCallbacks.push((value) => { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) => { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } }; 4.用Promise对象实现的 Ajax const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); }); return promise; }; getJSON(\"/posts.json\").then(function(json) { console.log('Contents: ' + json); }, function(error) { console.error('出错了', error); }); 5.阶乘的实现方法（递归）： function factorial (num) { if (num 6.实现一个JSON.stringify Boolean | Number| String 类型会自动转换成对应的原始值。 undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = [] let arr = Array.isArray(obj) for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\") } } jsonStringify({x : 5,aa: {bb: {cc: {dd: {ee:1}}}}}) \"{\"x\":5,\"aa\":{\"bb\":{\"cc\":{\"dd\":{\"ee\":1}}}}}\" 7.写一个sum函数满足无限传参的条件 一个sum函数满足无限传参的条件 sum(1) = 1;//返回的是一个函数，此时调用函数的valueOf函数 sum(1)(2)(3) = 6; sum(1, 2, 3)(4) = 10; sum(1)(2)(3)(4)(5) = 15; 解题： function sum() { var args = Array.prototype.slice.call(arguments); //将arguments转成数组 var funName = arguments.callee; //记录函数名，以便后面递归调用函数 var fn = function () { var innerArgs = Array.prototype.slice.call(arguments); 将arguments转成数组 var finals = args.concat(innerArgs); return funName.apply(null, finals); //递归 } fn.valueOf = function () {// 当函数返回的是函数时，自动调用fn.valueOf函数 return args.reduce(function (a, b) { return a + b; }) } return fn; } 8.转换成数组的方法 方法一：var args = Array.prototype.slice.call(arguments); 方法二：var args = [].slice.call(arguments, 0); 方法三： var args = []; for (var i = 1; i 最后，附个转成数组的通用函数 var toArray = function(s){ try{ return Array.prototype.slice.call(s); } catch(e){ var arr = []; for(var i = 0,len = s.length; i 方法四：Array.from(arr); 9.扁平化数组 function flatten(arr){ return arr.reduce(function(prev,item){ return prev.concat(Array.isArray(item)?flatten(item):item); },[]); } 还可以使用ES6拓展运算符 function flatten(arr){ while(arr.some(item=>Array.isArray(item)){ arr = [].concat(...arr); } return arr; } 10.实现一个div滑动的动画，由快至慢5s结束 .sj{ width:50px; height:50px; border:1px solid red; position:absolute; left:0 } //ele为要移动的盒子，target为目标位置（像素），spd为计数器的频率 var ele = document.getElementById('sj') function animate(ele,spd){ var start = Date.now(); // remember start time var timer = setInterval(function() { var timePassed = Date.now() - start; var step = Math.ceil(Math.abs(timePassed - 5000)/10) console.log(step) if (timePassed >= 5000) { clearInterval(timer); // finish the animation after 2 seconds return; } ele.style.left = ele.offsetLeft + step + 'px' }, spd); } 11.实现一个div滑动的动画，由快至慢到500px结束 function animate1(ele,target,spd){ var timer = setInterval(function() { var step = (target-ele.offsetLeft)/10; //对步长进行二次加工(大于0向上取整,小于0向下取整) step = step>0?Math.ceil(step):Math.floor(step); //动画原理： 目标位置 = 当前位置 + 步长 ele.style.left = ele.offsetLeft + step + \"px\"; //检测缓动动画有没有停止 if(Math.abs(target-ele.offsetLeft)12.JSONP的实现步骤 客户端网页网页通过添加一个\\元素，向服务器请求JSON数据，这种做法不受同源政策限制 function addScriptTag(src) { var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script); } window.onload = function () { addScriptTag('http://example.com/ip?callback=foo'); } function foo(data) { console.log('response data: ' + JSON.stringify(data)); }; 请求时,接口地址是作为构建出的脚本标签的src的,这样,当脚本标签构建出来时,最终的src是接口返回的内容 服务端对应的接口在返回参数外面添加函数包裹层 foo({ \"test\": \"testData\" }); 由于\\元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 注意,一般的JSONP接口和普通接口返回数据是有区别的,所以接口如果要做JSONO兼容,需要进行判断是否有对应callback关键字参数,如果有则是JSONP请求,返回JSONP数据,否则返回普通数据 使用注意 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,用cors或者niginx反向代理 13.数组排序（先按age升序相等则按name升序） var arr = [ {name: \"张三\", age: 12}, {name: \"李四\", age: 13}, {name: \"\b王五\", age: 14} ] arr.sort(function(a, b) { if(a.age !== b.age ){ return a.age > b.age ? 1 : -1 } return a.name > a.name ? 1 : a.name === a.name ? 0 : -1 }) 14.阶乘实现第一项为1，后一项是（前面所有项之和）*2 1，2，6，18，54 第一种(超级慢) function num(n,sum = 0) { if(n == 1) return 1 while(n > 1) { sum += 2 * num(n -1) n-- } return sum } 第二种 function sum(n) { if(n == 1) return 1 if(n == 2) return 2 return 3*sum(n-1) } sum(n) = (sum(n-1) + sum(n-2) +++ ... sum(1))*2 sum(n-1) = (sum(n-2) + sum(n-3) +++ ... sum(1))*2 sum(n) = 3*sum(n-1) 第三种 /* 动态规划解决 function sum(n) { let val = []; for(let i =1; i待优化递归 15.JS实现sleep()方法 这种实现方式是利用一个伪死循环阻塞主线程。因为JS是单线程的。所以通过这种方式可以实现真正意义上的sleep()。 function sleep(delay) { var start = (new Date()).getTime(); while ((new Date()).getTime() - start 方法二： function sleep(interval) { return new Promise(resolve => { setTimeout(resolve, interval); }) } // 用法 async function one2FiveInAsync() { for(let i = 1; i 16.不借助变量交换两个数 1.利用减法 var a = 1; var b = 2; b = a - b; a = a - b; b = a + b; 2.异或 这里用到了异或这个位运算的性质，即相同则为 0，不同则为 1. 于是对于两个数字，a 和 b。则有 a ^ a ^ b 就等于 b 。我们可以利用这个性质来完成交换。 实际上，有些算法题就可以用这个性质轻松解决。 JavaScript代码： var a = 1; var b = 2; b = a ^ b; a = a ^ b; b = a ^ b; 3.逗号表达式 逗号表达式的结果：取最后一个值 知识点： var b = (1,2,3); console.log(b); // 结果是 3 注：逗号运算符的优先级低于一般运算符，所以使用时一般要用小括号将其包起来： 什么是逗号表达式？逗号表达式是将两个及其以上的式子联接起来，从左往右逐个计算表达式，整个表达式的值为最后一个表达式的值。 因此我们可以利用这个性质，先完成一次赋值操作，然后将赋值操作的返回值变为0. 就可以完成赋值操作 JavaScript代码：： a = b + ((b = a), 0); 17.大数相加 题目描述 如何实现两个非常大的数字(已经超出了Number范围)的加法运算。 注意由于这两个已经超过了Number范围，因此不能用Number存，这里我们选择使用字符串存储。 思路 我们只要将两个数字前面补0至相同的长度，然后从低位到高位进行相加， 同时用一个变量记录进位的信息即可。 function bigNumberSum(a, b) { // 123456789 // 000009876 // padding let cur = 0; while (cur -1; i--) { const sum = carried + +a[i] + +b[i]; if (sum > 9) { carried = 1; } else { carried = 0; } res[i] = sum % 10; } if (carried === 1) { res.unshift(1); } return res.join(\"\"); } 18.什么是深拷贝，和浅拷贝有什么区别，动手实现一个深拷贝 function cloneDeep(obj) { if(obj === null) return null; if (typeof obj !== 'object') return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 获取obj的构造函数并实例化一个新的 const cloneObj = new obj.constructor(); Object.keys(obj).forEach(key => { // 递归拷贝属性 cloneObj[key] = cloneDeep(obj[key]); }); return cloneObj; } function deepClone(obj){ 　　let objClone = Array.isArray(obj) ? [] : {}; 　　if (obj && typeof obj === 'object') { 　　　　for(let key in obj){ 　　　　　　if (obj[key] && typeof obj[key] === 'object'){ 　　　　　　　　objClone[key] = deepClone(obj[key]); 　　　　　　}else{ 　　　　　　　　objClone[key] = obj[key] 　　　　　　} 　　　　} 　　} 　　return objClone; } 算法相关 1. JS实现的数组全排列输出算法 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。 function permute(input) { var permArr = [], usedChars = []; function main(input){ var i, ch; for (i = 0; i 2. 判断一个单词是否是回文？ function checkPalindrom(str) { return str == str.split('').reverse().join(''); } 3. 去掉一组整型数组重复的值 比如 输入: [1,13,24,11,11,14,1,2]， 输出: [1,13,24,11,14,2] ，需要去掉重复的11 和 1 这两个元素。 function(arr) { let hashTable = {}; let data = []; for(let i=0,l=arr.length;i// 去除数组的重复成员 [...new Set(array)] 上面的方法也可以用于，去除字符串里面的重复字符。 [...new Set('ababbc')].join('') // \"abc\" 4. 随机生成指定长度的字符串 实现一个算法，随机生成指制定长度的字符窜。 function randomString(n) { let str = 'abcdefghijklmnopqrstuvwxyz9876543210'; let tmp = '', i = 0, l = str.length; for (i = 0; i 6.反转字符串（双指针法） /** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead. */ // 双指针 var reverseString = function(s) { let left = 0, right = s.length - 1; while( left 7.反转字符串中的单词 一行代码 s.split(\"\").reverse().join(\"\").split(\" \").reverse().join(\" \") 不用js原生方法 空间复杂度 O(n) 时间复杂度O（n） 遍历字符串没有遇到 空格 就继续反转字符串 遇到空格：就把left 加到 right 上 并加上空格; ``` var reverseWords = function(s) { var right = '' var left = '' for (var i = 0; i if(s[i] != ' '){ right = s[i] + right }else { left = left + right + ' ' right = '' } } return left + right // return s.split(\"\").reverse().join(\"\").split(\" \").reverse().join(\" \") }; reverseWords(\"Let's take LeetCode contest\") \"s'teL ekat edoCteeL tsetnoc ### 8.反转链表 #### 解题思路 - 利用3个变量在循环过程中记录最后3种信息 - cur游标，一直往后循环，最后会为null - prev记录前一个节点 - oldNext，变更方向时，需要先用oldNext记住改变前的next节点，否则无法向后循环 代码 /** Definition for singly-linked list. function ListNode(val) { this.val = val; this.next = null; } / /* @param {ListNode} head @return {ListNode} */ var reverseList = function(head) { var prev = null,cur=head,temp; while(cur){ temp = cur.next;//修改前先记住下一个节点 cur.next = prev; //\b改别指向，第一个节点prev是null, prev = cur; //记录前一个节点，供下次循环使用 cur = temp; // cur通过temp指向下一节点 } return prev;//cur会多循环直到null }; ```递归，先找最里面的反过来 代码 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { function reverse(head){ if(head == null || head.next == null) return head; let newHead = reverse(head.next); head.next.next = head; head.next = null; return newHead; } head = reverse(head); return head; }; 单指针，利用辅助空间反转链表 解题思路 不改变链表指向，只通过两次遍历改变链表中的值实现反转链表。 代码 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { \"use strict\"; //辅助栈储存链表里的值 let stack =[]; let pnt = head; //第一次遍历，将链表里的值入栈 while (pnt !== null){ stack.push(pnt.val); pnt = pnt.next; }; pnt = head; //第二次遍历，将栈里的值弹出，填入链表，实现反转 while (pnt !== null){ pnt.val = stack.pop(); pnt = pnt.next; }; return head; }; 复杂度分析： 时间复杂度：对链表进行2次遍历，O(n) 空间复杂度：使用了深度为n的栈储存链表值，O(n) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-10 16:50:34 "},"Coding/js/执行结果解释原因.html":{"url":"Coding/js/执行结果解释原因.html","title":"js执行结果解释原因 ✘","keywords":"","body":"js执行结果解释原因 1 var a = 1; (function a () { a = 2; console.log(a); })(); // 写出执行结果，并解释原因 解析: 立即调用的函数表达式（IIFE） 有一个 自己独立的 作用域，如果函数名称与内部变量名称冲突，就会永远执行函数本身；所以上面的结果输出是函数本身； 2 (function () { var a = (b = 5); })(); console.log(b); console.log(a); 在这个立即执行函数表达式（IIFE）中包括两个赋值操作，其中a使用var关键字进行声明，因此其属于函数内部的局部变量（仅存在于函数中），相反，b被分配到全局命名空间。 另一个需要注意的是，这里没有在函数内部使用严格模式(use strict;)。如果启用了严格模式，代码会在输出 b 时报错Uncaught ReferenceError: b is not defined, 3 var company = { address: 'beijing' } var yideng = Object.create(company); delete yideng.address console.log(yideng.address); // 写出执行结果，并解释原因 答案 beijing 解析 这里的 yideng 通过 prototype 继承了 company的 address。yideng自己并没有address属性。所以delete操作符的作用是无效的。 知识点 1.delete使用原则：delete 操作符用来删除一个对象的属性。 2.delete在删除一个不可配置的属性时在严格模式和非严格模式下的区别: （1）在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常; （2）非严格模式下返回 false。 3.delete能删除隐式声明的全局变量：这个全局变量其实是global对象(window)的属性 4.delete能删除的： （1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在ECMAScript 6中，通过 const 或 let 声明指定的 \"temporal dead zone\" (TDZ) 对 delete 操作符也会起作用 delete不能删除的： （1）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性 5.delete删除数组元素： （1）当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成undefined （2）当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。 （3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的 6.delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。 4 var foo = function bar(){ return 12; }; console.log(typeof bar()); // 写出执行结果，并解释原因 答案 输出是抛出异常，bar is not defined。 解析 这种命名函数表达式函数只能在函数体内有效 var foo = function bar(){ // foo is visible here // bar is visible here console.log(typeof bar()); // Work here :) }; // foo is visible here // bar is undefined here 5 var a = ?; if(a == 1 && a== 2 && a== 3){ console.log(1); } var a = { i: 1, toString: function () { return a.i++; } } if(a == 1 && a == 2 && a == 3) { console.log('1'); } var val = 0; Object.defineProperty(window, 'a', { get: function() { return ++val; } }); if (a == 1 && a == 2 && a == 3) { console.log('1'); 6 var a = {n: 1}; var b = a; a.x = a = {n: 2}; console.log(a.x); //undefined console.log(b.x); //{n: 2} 要理解三个点： 此处的a，b是引用类型 在javascript中字段访问操作符\".\"的优先级高于赋值操作符\"=\" 出现多个赋值操作符\"=\"时，运算顺序为从右向左 （1）先执行\"a.x\"，此时a储存的仍然是初始地址，即指向对象{n: 1}。\"a.x\"相当于在对象{n: 1}中添加了属性\"x\"，变为{n: 1; x: undefined}，但是\"x\"还没赋值；注意，此时对象{n: 1; x: undefined}中的\"x\"属性是等待赋值的，操作挂起。 （2）再执行\"a = {n: 2}\"，由于{n: 2}是个新对象，则程序在堆中再创建一个对象{n: 2}，并且将变量a指向该对象，此时a储存的即新的的地址 （3）最后一步\"a.x = a\"，（1）中被挂起的操作继续执行，对象{n: 1; x: undefined}中的\"x\"指向对象{n: 2}。运算完成。 (function(){ var a = b = 3; })() console.log(typeof a === \"undefined\"); // false console.log(typeof b === \"undefined\"); // false // 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(=号自左向右) // 那个函数可以拆成这样 (function() var a; /* 局部变量,外部没法访问*/ b = 3; /* 全局变量,so . window.b === 3 , 外部可以访问到*/ a = b; })() // 若是改成这样,这道题应该是对的 console.log(typeof b === \"number\" && b ===3 ); // true Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-09 19:20:33 "},"DesignPattern/js实现23种设计模式.html":{"url":"DesignPattern/js实现23种设计模式.html","title":"js实现23种设计模式 ✘","keywords":"","body":"js实现23种设计模式 创建型模式 单例模式 三要素： 同一个实例 类自行创建实例对象 可向整个系统输出这个实例 分类： 饿汉式（ 类加载到实例时创建实例对象） 懒汉式（ 第一次使用时才创建实例对象） 代码示例：懒汉式 // 手机 用来打电话，玩游戏，看电影，且都是同一个手机 // 懒汉式 var Phone = (function () { // 规定只能使用 Phone.getInstance 获取实例 var res = function () { throw new Error(\"Please use Phone.getInstance() to get the object.\"); }; var has = false; var phone = null; Object.defineProperty(res, 'getInstance', { value: function () { if (has) { return phone; } else { has = true; // 调用时才创建实例 phone = { call () { console.log(\"打电话\"); }, playGame () { console.log(\"玩游戏\"); }, watchMovie () { console.log(\"看电影\"); } } return phone; } }, writable: false, configurable: false, enumerable: false }); return res; }()); var p1 = Phone.getInstance(); var p2 = Phone.getInstance(); var p3 = Phone.getInstance(); p1.call(); p2.playGame(); p3.watchMovie(); console.log(p1 === p2 && p2 === p3); 代码示例：饿汉式 // 手机 用来打电话，玩游戏，看电影，且都是同一个手机 // 饿汉式 // 规定只能使用 Phone.getInstance 获取实例 var Phone = (function () { // 在此创建实例，装入内存时 实例已创建 var phone = { call () { console.log(\"打电话\"); }, playGame () { console.log(\"玩游戏\"); }, watchMovie () { console.log(\"看电影\"); } }; var res = function () { throw new Error(\"Please use Phone.getInstance() to get the object.\"); }; Object.defineProperty(res, 'getInstance', { value: function () { return phone; }, writable: false, configurable: false, enumerable: false }); return res; }()); var p1 = Phone.getInstance(); var p2 = Phone.getInstance(); var p3 = Phone.getInstance(); p1.call(); p2.playGame(); p3.watchMovie(); console.log(p1 === p2 && p2 === p3); Phone.getInstance = function () { console.log(\"I am Groot!\"); } var p4 = Phone.getInstance(); p4.call(); 简单工厂模式 定义： 定义一个工厂，工厂定义一个方法，该方法可以根据传入的参数去返回某一个类的实例。 代码示例： // 根据参数决定去实例汽车还是摩托车 // 定义接口 const Vehicle = { run () { console.log(this.name + '跑...'); } } //汽车类 function Car () { this.name = \"汽车\"; } Car.prototype = Object.assign(Vehicle); //摩托车类 function Moto () { this.name = \"摩托车\"; } Moto.prototype = Object.assign(Vehicle); // 车库 const Garage = { chooseVehicle (constructor) { return new constructor(); } }; Object.freeze(Garage); var car = Garage.chooseVehicle(Car); var moto = Garage.chooseVehicle(Moto); car.run(); moto.run(); 工厂方法 简要： 定义一个工厂接口，接口存在一个创建产品类的方法，为每个类创建一个这样的类工厂。 代码示例： // 工厂方法，创建工厂接口，为每个类创建一个工厂 // 定义接口 const Vehicle = { run () { console.log(this.name + '跑...'); } } //汽车类 function Car () { this.name = \"汽车\"; } Car.prototype = Object.assign(Vehicle); //摩托车类 function Moto () { this.name = \"摩托车\"; } Moto.prototype = Object.assign(Vehicle); // 汽车车库 function CarGarage () { this.createVehicle = function () { return new Car(); } Object.freeze(this); } // 摩托车车库 function MotoGarage () { this.createVehicle = function () { return new Moto(); } Object.freeze(this); } // 测试 var carGarage = new CarGarage(); var motoGarage = new MotoGarage(); var car = carGarage.createVehicle(); var moto = motoGarage.createVehicle(); car.run(); moto.run(); 抽象工厂 简要： 对比于工厂方法，抽象工厂可以说是多种产品，每种产品都要用工厂方法实现。 代码示例： // 生产枪的工厂 // createGun 生产枪 // ak47 枪工厂，生产 ak47 枪 function Ak47GunCompany () { this.createGun = function () { console.log(\"生产 ak47 枪...\"); } } // 巴雷特 枪工厂，生产 巴雷特 枪 function BarrettGunCompany () { this.createGun = function () { console.log(\"生产 巴雷特 枪...\"); } } // 生产子弹的工厂 // createBubble 生产子弹 // ak47 子弹工厂，生产 ak47 子弹 function Ak47BubbleCompany () { this.createBubble = function () { console.log(\"生产 ak47 子弹...\"); } } // 巴雷特 子弹工厂，生产 巴雷特 子弹 function BarrettBubbleCompany () { this.createBubble = function () { console.log(\"生产 巴雷特 子弹...\"); } } // 武器工厂，生产枪和子弹 // createGun 生产枪 // createBubble 生产子弹 // ak47 武器工厂，生产 ak47枪 和 ak47 子弹 function Ak47Company () { var ak47GunCompany = new Ak47GunCompany(); var ak47BubbleCompany = new Ak47BubbleCompany(); this.createGun = function () { ak47GunCompany.createGun(); } this.createBubble = function () { ak47BubbleCompany.createBubble(); } } // 巴雷特 武器工厂，生产 巴雷特枪 和 巴雷特子弹 function BarrettCompany () { var barrettGunCompany = new BarrettGunCompany(); var barrettBubbleCompany = new BarrettBubbleCompany(); this.createGun = function () { barrettGunCompany.createGun(); } this.createBubble = function () { barrettBubbleCompany.createBubble(); } } var ak47Company = new Ak47Company(); var barrettCompany = new BarrettCompany(); ak47Company.createGun(); ak47Company.createBubble(); barrettCompany.createGun(); barrettCompany.createBubble(); 建造者模式 简要： 当构造一个实例的时候，需要执行多个步骤才能生成实例，并且每个步骤有多种选择从而会生成多种实例的时候使用。 代码示例： // 适用于 构造一个实例对象需要多个步骤，且每个步骤可能不同会导致不同的实例类 /** 果汁制作步骤 * StirFruit() 将水果打碎 * addWater() 加水 */ // 西瓜汁制作步骤 function WatermelonJuiceStep() { this.StirFruit = function () { console.log(\"将西瓜打碎...\"); }; this.addWater = function () { console.log(\"加水...\"); } } // 橙汁制作步骤 function OrangeJuiceStep() { this.StirFruit = function () { console.log(\"将橙子打碎...\"); }; this.addWater = function () { console.log(\"加水...\"); } } /** 果汁生成器 * make() 生成果汁 * getJuice() 获取制作的果汁 */ // 西瓜汁生成器 function WatermelonJuiceMaker () { var maker = new WatermelonJuiceStep(); this.make = function () { maker.StirFruit(); maker.addWater(); } this.getJuice = function () { return maker; } } // 橙汁生成器 function OrangeJuiceMaker () { var maker = new OrangeJuiceStep(); this.make = function () { maker.StirFruit(); maker.addWater(); } this.getJuice = function () { return maker; } } // 果汁生成器 function JuiceMaker() { var orangeJuiceMaker = new OrangeJuiceMaker(); var watermelonJuiceMaker = new WatermelonJuiceMaker(); this.makeOrangeJuice = function () { orangeJuiceMaker.make(); return orangeJuiceMaker.getJuice(); } this.makeWatermelonJuice = function () { watermelonJuiceMaker.make(); return watermelonJuiceMaker.getJuice(); } } // 使用果汁生成器 var juiceMaker = new JuiceMaker(); var watermelonJuice = juiceMaker.makeWatermelonJuice(); var orangeJuice = juiceMaker.makeOrangeJuice(); 结构型模式 代理模式 简要： 共同继承同一接口或抽象类，代理类包含被代理类（has-a) 代码示例： // 代理模式 // 共同继承同一接口或抽象类，代理类包含被代理类（has-a) // 场景：帮别人考试 /** 接口（考试人） * test() 参加考试 */ /** 被代理人考试 * */ function testSelf() { this.test = function() { console.log(\"参加考试，可是我不会.\"); } } /** 代理人考试 * */ function testOther(self) { this.test = function() { console.log(\"参加考试，我会.\"); } } // 测试 var self = new testSelf(); var other = new testOther(self); other.test(); 适配器模式 简要： 将两个不能一块工作的接口或者类，通过新建一个类继承两者，从而使得可以一起工作 代码示例： // 适配器模式 // 将两个不能一块工作的接口或者类，通过新建一个类继承两者，从而使得可以一起工作 // 比如小米8的方形耳机插口与圆形耳机接头需要耳机适配器才能工作 /** 手机接口 * access() 提供的接口类型 */ function Mi8() { this.access = function () { console.log(\"小米8提供方形插口.\"); } } /** 耳机接头 * insert() 提供的接头类型 */ function MiHeadset() { this.insert = function () { console.log(\"小米耳机提供圆形插头.\"); } } // 适配器 需要实现 手机接口与耳机接头 function HeadsetAdapter() { this.access = function () { console.log(\"耳机适配器提供圆形插口.\"); } this.insert = function () { console.log(\"耳机适配器提供方形插头.\"); } } // 测试 var mi8 = new Mi8(); var miHeadset = new MiHeadset(); var headsetAdapter = new HeadsetAdapter(); mi8.access(); headsetAdapter.insert(); headsetAdapter.access(); miHeadset.insert(); 桥接模式 简要： 主要是两个不同的类有多种种类，通过 has-a 组合方式去进行多种类的结合 示例代码： // 桥接模式，主要是两个不同的类有多种种类，通过 has-a 组合方式去进行多种类的结合 /** 场景： * 鞋子有跑鞋，篮球鞋，鞋子的品牌有李宁，耐克 */ /** 接口：鞋柜 ShoesBar * saleShoes() 出售鞋子 */ /** 继承鞋柜接口：跑鞋鞋柜 * */ function RunShoesBar() { this.saleShoes = function () { console.log(\"出售跑鞋.\"); } } /** 继承鞋柜接口：篮球鞋鞋柜 * */ function BasketballShoesBar() { this.saleShoes = function () { console.log(\"出售篮球鞋.\"); } } /** 抽象类：品牌鞋柜 * shoesBar 继承 ShoesBar 的鞋柜 * saleShoes 鞋柜 */ /** 品牌鞋柜继承类：李宁鞋柜 * */ function LiNingShoesBar(shoesBar) { var shoesBar = shoesBar; this.saleShoes = function () { console.log(\"李宁鞋柜：\"); shoesBar.saleShoes(); } } /** 品牌鞋柜继承类：耐克鞋柜 * */ function NickShoesBar(shoesBar) { var shoesBar = shoesBar; this.saleShoes = function () { console.log(\"耐克鞋柜：\"); shoesBar.saleShoes(); } } // 测试 // 定义一个跑鞋柜 var runShoesBar = new RunShoesBar(); // 定义一个李宁的跑鞋柜 var liningRunShoesBar = new LiNingShoesBar(runShoesBar); liningRunShoesBar.saleShoes(); // 定义一个耐克的跑鞋柜 var nickShoesBar = new NickShoesBar(runShoesBar); nickShoesBar.saleShoes(); 组合模式 简要： 就是不同层级的两个类具有极其相似的结构，可以只构造一个类来表示这两个类 // 组合模式：就是不同层级的两个类具有极其相似的结构，可以只构造一个类来表示这两个类 // 场景：表示爷爷，爸爸，儿子三代关系 // 接口：属于人，都有名字 const Person = { getName() { return this.name; }, setName(name) { this.name = name; }, display () { } } // 爷爷和爸爸都是父亲，都有儿子，所以... function Father(name) { this.setName(name); var sons = []; this.add = function (person) { sons.push(person); } this.display = function () { console.log(\"作为父亲：\" + this.getName()); sons.forEach((son) => { son.display(); }); } } // 继承一下 Father.prototype = Person; // 作为儿子，只能是儿子 function Son(name) { this.setName(name); this.display = function () { console.log(\"作为儿子：\" + this.getName()); } } // 继承以下 Son.prototype = Person; // 测试 var grandfather = new Father(\"张爷爷\"); var father1 = new Father(\"张伯伯\"); var father2 = new Father(\"张大爷\"); var son1 = new Son(\"张娃子\"); var son2 = new Son(\"张嘎子\"); grandfather.add(father1); grandfather.add(father2); father1.add(son1); father2.add(son2); grandfather.display(); 装饰模式 简要： 装饰模式，基本类和装饰类共同继承某个接口或者抽象类， 通过装饰类包含基本类以及在装饰类中添加装饰方法的方式去装饰基本类 代码示例： // 场景：lol 英雄buff, 普通英雄，露露buff，努努buff /** 公共接口：Hero * getBuff() 获取英雄的 buff */ function NormalHero() { this.getBuff = function () { console.log(\"初始的英雄，无 buff.\"); } } // 加露露 buff function LuLuBuffHero(hero) { this.getBuff = function() { hero.getBuff(); console.log(\"加露露 buff.\"); } } // 加努努 buff function NuNuBuffHero(hero) { this.getBuff = function () { hero.getBuff(); console.log(\"加努努 buff.\"); } } // 测试 var noBuffHero = new NormalHero(); var luluBuffHero = new LuLuBuffHero(noBuffHero); var nunuBuffHero = new NuNuBuffHero(luluBuffHero); nunuBuffHero.getBuff(); 外观模式 简要： 通过统一的管理类对内部类管理，同时暴露接口接收来自外部类的消息 代码示例： /** 外观模式 * 通过统一的管理类对内部类管理，同时暴露接口接收来自外部类的消息 */ // 场景描述： 需求人员提出需求，开发人员进行开发，测试人员进行测试 // 需求人员不需要通知开发人员去开发，测试人员去测试 // 只需要告诉小组组长这个需求就可以了 // 开发人员，负责开发需求 function Developter() { this.develop = function(demand_name) { console.log(\"开发人员开发需求：\" + demand_name); } } // 测试人员，负责测试需求 function Tester() { this.test = function (demand_name) { console.log(\"测试人员测试需求：\" + demand_name); } } // 技术部组长，负责安排开发人员开发和测试人员测试 function Leader() { var developer = new Developter(); var tester = new Tester(); this.processDemand = function (demand_name) { developer.develop(demand_name); tester.test(demand_name); } } // 需求人员，提出需求 function Demander() { var leader = new Leader(); this.demand = function (demand_name) { console.log(\"提出需求：\" + demand_name); leader.processDemand(demand_name); } } // 测试 var demand_name = \"开发一款MOBA游戏.\"; var demander = new Demander(); demander.demand(demand_name); 享元模式 简要： 对于系统中使用的一些对象可以共享使用，那么每次使用时先判断有没有，有直接使用，没有再去创建，节省内存空间 代码示例： /** 享元模式 * 对于系统中使用的一些对象可以共享使用，那么每次使用时先判断有没有 * 有直接使用，没有再去创建，节省内存空间 */ // 场景： // 土豪打英雄联盟，想用哪个皮肤，就用哪个 // 有皮肤直接使用，没有就买买买... /** 英雄皮肤类 * name 皮肤名字 * show() 皮肤展示 */ function HeroSkin(name) { console.log(\"玩家购买了\" + name + \"皮肤\"); this.show = function () { console.log(\"玩家使用了\" + name + \"皮肤\"); } } /** 玩家以及拥有的皮肤 * useSkin(skinName) 使用皮肤 */ function Player() { var mySkins = {}; this.useSkin = function (skinName) { if (!(skinName in mySkins)) { mySkins[skinName] = new HeroSkin(skinName); } mySkins[skinName].show(); } } // 测试 var player = new Player(); player.useSkin(\"伊泽瑞尔-未来战士\"); player.useSkin(\"锐雯-光明使者\"); player.useSkin(\"锐雯-光明使者\"); 行为型模式 模板方法 简要： 简单而言就是定义子类需要做什么，具体做什么交给子类去做 代码示例（java, 因为 js 没有抽象方法这些，而且我觉得模板方法主要是固定流程，实现交给子类实现） package actionModel.templateModel; // 模板方法 // 场景：召唤师选择英雄，皮肤和召唤师技能 // 步骤：选择英雄 -> 选择皮肤 -> 选择召唤师技能1 -> 选择召唤师技能2 // 角色：召唤师（就是玩家） abstract class Player { private String name; public Player(String name) { this.name = name; } public abstract void chooseHero(); public abstract void chooseSkin(); public abstract void chooseSummonerSkillFirst(); public abstract void chooseSummonerSkillSecond(); public void show() { // 显示玩家信息 System.out.println(this.name + \"的选择：\"); // 显示选择的英雄 chooseHero(); // 显示选择的皮肤 chooseSkin(); // 显示选择的召唤师技能一 chooseSummonerSkillFirst(); // 显示选择的召唤师技能二 chooseSummonerSkillSecond(); } } // 玩家小明 class XiaoMing extends Player{ public XiaoMing(){ super(\"小明\"); } @Override public void chooseHero() { System.out.println(\"英雄：奥拉夫\"); } @Override public void chooseSkin() { System.out.println(\"皮肤：铁哥们\"); } @Override public void chooseSummonerSkillFirst() { System.out.println(\"召唤师技能一：疾走\"); } @Override public void chooseSummonerSkillSecond() { System.out.println(\"召唤师技能二：闪现\"); } } // 玩家小张 class XiaoZhang extends Player { public XiaoZhang() { super(\"小张\"); } @Override public void chooseHero() { System.out.println(\"英雄：锐雯\"); } @Override public void chooseSkin() { System.out.println(\"皮肤：光明使者\"); } @Override public void chooseSummonerSkillFirst() { System.out.println(\"召唤师技能一：传送\"); } @Override public void chooseSummonerSkillSecond() { System.out.println(\"召唤师技能二：闪现\"); } } public class Test { public static void main(String[] args) { // 测试 Player xiaoming = new XiaoMing(); Player xiaozhang = new XiaoZhang(); xiaoming.show(); xiaozhang.show(); } } 中介者模式 简要： 简单来说就是通过中介者进行数据传递，一方提供数据，一方订阅数据 代码示例： // 中介者模式 // 简单来说就是通过中介者进行数据传递 // 一方提供数据，一方订阅数据 // 场景：使用第三方买二手手机 // 购买者去预定手机，当出售者卖该型号的手机时候通知购买者 /** 购买者构造函数 * * @param phoneName 购买人需要的手机 */ function Buyer(phoneName) { this.getPhoneName = function() { return phoneName; } this.callSellerPhone = function(phone) { console.log(`联系卖家：${phone}买 ${phoneName}`); } } /** 出售者构造函数 * @param phoneName 卖的的手机 * @param phone 卖主联系方式 */ function Seller(phoneName, phone) { this.getPhoneName = function() { return phoneName; } this.getPhone = function() { return phone; } } /** 中介者构造函数 * */ function Intermediary() { var buyerList = []; var sellerList = []; this.addBuyer = function(buyer) { // 若存在一个合适的卖家，直接通知买主，不添加到列表 for (let i of sellerList) { if (i.getPhoneName() === buyer.getPhoneName()) { buyer.callSellerPhone(i.getPhone()); break; } } buyerList.push(buyer); } this.addSeller = function(seller) { // 若存在一个合适的买家，直接通知买主，不添加到列表 for (let i of buyerList) { if (i.getPhoneName() === seller.getPhoneName()) { i.callSellerPhone(seller.getPhone()); break; } } sellerList.push(seller); } } var intermediary = new Intermediary(); var buyer1 = new Buyer(\"小米3\"); intermediary.addBuyer(buyer1); var buyer2 = new Buyer(\"小米8\"); intermediary.addBuyer(buyer2); var seller1 = new Seller(\"小米8\", \"15684175538\"); intermediary.addSeller(seller1); 命令模式 简要： 使用命令模式可以在扩展调度中心的时候不修改调度中心的代码 代码示例： // 命令模式 // 使用命令模式可以在扩展调度中心的时候不修改调度中心的代码 // 场景：玩具遥控汽车 /** 汽车构造函数 * */ function ToyCar() { this.goOn = function() { console.log(\"小车前进\"); } this.stop = function() { console.log(\"小车停止\"); } this.speedUp = function() { console.log(\"小车加速\"); } } /** 命令接口 CarCommand * car 遥控汽车的实例 * execute() 执行命令 */ /** 前进的命令 extends CarCommand * @param car 汽车实例 */ function GoOnCommand(car) { this.execute = function() { car.goOn(); } } /** 停止的命令 extends CarCommand * @param car 汽车实例 */ function StopCommand(car) { this.execute = function() { car.stop(); } } /** 加速的命令 extends CarCommand * @param car 汽车实例 */ function SpeedUpCommand(car) { this.execute = function() { car.speedUp(); } } /** 汽车遥控器 * setCarCommand() 设置命令 * trigger() 触发命令 */ function CarControlHandle() { var carCommand = null; this.setCommand = function(newCarCommand) { carCommand = newCarCommand; } this.trigger = function() { carCommand.execute(); } } // 测试 var car = new ToyCar(); var controlHandle = new CarControlHandle(); var goOn = new GoOnCommand(car); controlHandle.setCommand(goOn); controlHandle.trigger(); var stop = new StopCommand(car); controlHandle.setCommand(stop); controlHandle.trigger(); var speedUp = new SpeedUpCommand(car); controlHandle.setCommand(speedUp); controlHandle.trigger(); 责任链模式 简要： 将请求交给一条处理链，处理链上的有多个处理器处理，当处理链上某个处理器处理了该请求，返回处理的结果优点是添加删除处理器时不需要修改内部代码，只需要添加或者删除即可，符合开闭原则 代码示例： // 责任链模式 // 将请求交给一条处理链，处理链上的有多个处理器处理， // 当处理链上某个处理器处理了该请求，返回处理的结果 // 优点是添加删除处理器时不需要修改内部代码，只需要添加或者删除即可 // 符合开闭原则 // 场景：dnf 玩家刷图打怪，怪物有普通怪，精英怪，boss /** 怪物抽象类 * nextMonster 下一个怪物 * setNextMonster 设置下一个怪物 * battle() 和玩家战斗 * battleSuccess() 战斗胜利 * battalFail() 战斗失败 */ /** 普通怪 * */ function NomalMonster() { var nextMonster = null; this.setNextMonster = function(Monster) { nextMonster = Monster; } this.battle = function(player) { var res = Math.round(Math.random() * 10) % 2 === 0; if (res) { this.battleSuccess(); nextMonster.battle(player); } else { this.battleFail(); } } this.battleSuccess = function() { console.log(\"打败了普通怪.\"); } this.battleFail = function() { console.log(\"被普通怪打死, 请使用复活币\"); } } /** 精英怪 * */ function CreamMonster() { var nextMonster = null; this.setNextMonster = function(Monster) { nextMonster = Monster; } this.battle = function(player) { var res = Math.round(Math.random() * 10) % 2 === 0; if (res) { this.battleSuccess(); nextMonster.battle(player); } else { this.battleFail(); } } this.battleSuccess = function() { console.log(\"打败了精英怪.\"); } this.battleFail = function() { console.log(\"被精英怪打死, 请使用复活币\"); } } /** Boss怪 * */ function BossMonster() { var nextMonster = null; this.setNextMonster = function(Monster) { nextMonster = Monster; } this.battle = function(player) { var res = Math.round(Math.random() * 10) % 2 === 0; if (res) { this.battleSuccess(); } else { this.battleFail(); } } this.battleSuccess = function() { console.log(\"打败了boss怪，通关成功！\"); } this.battleFail = function() { console.log(\"被boss怪打死, 请使用复活币\"); } } /** 玩家类 * */ function Player() { } // 测试 var player = new Player(); var nomalMonster = new NomalMonster(); var creamMonster = new CreamMonster(); nomalMonster.setNextMonster(creamMonster); var bossMonster = new BossMonster(); creamMonster.setNextMonster(bossMonster); nomalMonster.battle(player); 策略模式 简要： 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换 代码示例： // 策略模式 // 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换 // 场景： 五个人租房子，要么找五室一厅，要么三室一厅 + 二室一厅 // 角色：找房人 /** 方案接口 * sayMethod() 输出方案 */ /** 方案一 五室一厅 * sayMethod() 输出方案 */ function Method1() { this.sayMethod = function() { console.log(\"找一个五室一厅.\"); } } /** 方案二 三室一厅 + 二室一厅 * sayMethod() 输出方案 */ function Method2() { this.sayMethod = function() { console.log(\"找一个三室一厅和一个二室一厅\"); } } /** 找房人 * method 方案 * findHouse() 找房子 */ function findHousePeople(method) { this.findHouse = function() { method.sayMethod(); } this.setMethod = function(newMethod) { method = newMethod; } } // 测试 var method = new Method1(); var people = new findHousePeople(method); people.findHouse(); method = new Method2(); people.setMethod(method); people.findHouse(); 迭代器模式 简要： 给定一个遍历规则，不管其数据结构实现 代码示例： // 迭代器模式 // 给定一个遍历规则，不管其数据结构实现 // 场景：排队拿快递 /** 学生构造函数 * */ function Student(name, phone, expressId) { this.getName = function() { return name; } this.getPhone = function() { return phone; } this.getExpressId = function() { return expressId; } } /** 快递点构造函数 * */ function ExpressStation() { var index = -1; var students = []; var iterator = null; iterator = { hasNext() { return index 观察者模式 简要： 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 代码示例： // 观察者模式 // 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 // 场景：订阅公众号 /** 观察者接口 Observer * update(String barName, String message) 收到消息 */ /** 被观察者接口 Observable * addObserver(Observer ob) 添加观察者 * removeObserver(Observe ob) 删除观察者 * notifyObservers(String message) 通知所有观察者 */ /** 微信用户构造函数 * */ function WxUser() { this.update = function(barName, message) { console.log(`公众号${barName}发来消息：${message}`); } } /** 微信公众号构造函数 * */ function WxBar(name) { var obs = new Set(); this.addObserver = function(ob) { obs.add(ob); } this.removeObserver = function(ob) { obs.delete(ob); } this.notifyObservers = function(message) { for (let ob of obs) { ob.update(name, message); } } } // 测试 var user1 = new WxUser(); var user2 = new WxUser(); var wxBar = new WxBar(\"党尼玛的公众号\"); wxBar.addObserver(user1); wxBar.addObserver(user2); wxBar.notifyObservers(\"这波超级帅！\"); 状态模式 简要: 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。简单讲就是一个对象有多个状态，且这个对象有几个行为，每个状态的这些行为不同 代码示例： // 状态模式 // 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 // 简单讲就是一个对象有多个状态，且这个对象有几个行为， // 每个状态的这些行为不同 // 场景：文件权限（普通用户只可读，一般管理员可读可写，超级管理员可读可写可删除） /** 状态接口 State * read() 是否可读 * write() 是否可写 * delete() 是否可删除 */ /** 普通用户状态构造函数 * */ function NomalUser() { this.read = function() { console.log(\"可读\"); } this.write = function() { console.log(\"不可写\"); } this.delete = function() { console.log(\"不可删除\"); } } /** 一般管理员状态构造函数 * */ function Admin() { this.read = function() { console.log(\"可读\"); } this.write = function() { console.log(\"可写\"); } this.delete = function() { console.log(\"不可删除\"); } } /** 超级管理员构造函数 * */ function SuperAdmin() { this.read = function() { console.log(\"可读\"); } this.write = function() { console.log(\"可写\"); } this.delete = function() { console.log(\"可删除\"); } } /** 用户构造函数 * */ function User(state) { this.setState = function(newState) { state = newState; } this.readFile = function() { state.read(); } this.writeFile = function() { state.write(); } this.deleteFile = function() { state.delete(); } } // 测试 var user = new User(new NomalUser()); user.readFile(); user.writeFile(); user.setState(new SuperAdmin()); user.readFile(); user.writeFile(); user.deleteFile(); 备忘录模式 简要： 三个角色，原发器，备忘录，备忘录守护者。原发器中暴露出两个接口，一个用于包装自己的状态成一个备忘录，另一个用于通过备忘录守护者恢复自身状态，备忘录中只保存原发器的状态，备忘录守护者中维持一个备忘录，可读可写。 代码示例： // 备忘录模式 // 设置另外的对象作为备忘录对象，保存对象的状态 // 场景：英雄联盟购买装备撤回 /** 装备备忘录构造函数 * */ function EquipmentsMemento(equipments) { this.setEquipments = function(newEquipments) { equipments = newEquipments; } this.getEquipments = function() { return equipments; } } /** 装备栏构造函数 * */ function EquipmentBar() { var equipments = []; this.buyEquipment = function(equipment) { console.log(`购买了装备：${equipment}`); equipments.push(equipment); } this.showEquipments = function() { console.log(\"已购买装备: \", equipments.join(\" \")); } this.getEquipmentsMemento = function() { return new EquipmentsMemento([...equipments]); } this.recoverEquipments = function(equipmentCaretaker) { equipments = equipmentCaretaker.getEquipmentsMemento().getEquipments(); } } /** 装备状态管理者构造函数 * */ function EquipmentCaretaker() { var equipmentsMemento = null; this.setEquipmentsMemento = function(newEquipmentsMemento) { equipmentsMemento = newEquipmentsMemento; } this.getEquipmentsMemento = function() { return equipmentsMemento; } } // 测试 // 初始化状态看守者 var equipmentCaretaker = new EquipmentCaretaker(); // 初始化装备栏 var equipmentBar = new EquipmentBar(); // 购买装备 equipmentBar.buyEquipment(\"无尽之刃\"); equipmentBar.buyEquipment(\"狂战士胫甲\"); // 保存当前 equipmentCaretaker.setEquipmentsMemento(equipmentBar.getEquipmentsMemento()); // 购买了一件不想要的装备 equipmentBar.buyEquipment(\"无用大棒\"); equipmentBar.showEquipments(); // 撤回 console.log(\"玩家买错了，撤回...\"); equipmentBar.recoverEquipments(equipmentCaretaker); equipmentBar.showEquipments(); 解析器模式 简要： 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 代码示例： // 解释器模式 // 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 // 场景：sql 解释器 /** sql 内容构造函数 * */ function Context() { var tableName = null/** string */; var params = null/** object */; var wheres = null/** object */; var fields = null/** set */; this.setTableName = function(newTableName) { tableName = newTableName; } this.getTableName = function() { return tableName; } this.setParams = function(newParams) { params = newParams; } this.getParams = function() { return params; } this.setWheres = function(newWheres) { wheres = newWheres; } this.getWheres = function() { return wheres; } this.setFields = function(newFields) { fields = newFields; } this.getFields = function() { return fields; } } /** 解释器接口 SQLExpression * string interpret(Context context) */ /** insert sql 解释器 * */ function InsertSQLExpression() { this.interpret = function(context) { var params = context.getParams(); // 拼接 key var keys = \"(\"; var allKey = Object.getOwnPropertyNames(params); allKey.forEach((key) => { keys += key + \",\"; }); keys = keys.substring(0, keys.length - 1); keys += \")\"; // 拼接 value var values = \"(\"; allKey.forEach((key) => { values += (typeof params[key] === 'string' ? `'${params[key]}'` : params[key]) + \",\"; }); values = values.substring(0, values.length - 1); values += \")\"; return `insert into ${context.getTableName()} ${keys} values ${values}`; } } // 测试 var insertSQLExpression = new InsertSQLExpression(); var context = new Context(); context.setTableName(\"student\"); context.setParams({ name: 'dcw', age: 22 }); var sql = insertSQLExpression.interpret(context); console.log(sql) 访问者模式 简要： 见人说人话，见鬼说鬼话 代码示例： // 访问者模式 // 见人说人话，见鬼说鬼话 // 场景：买衣服时服务员的引导，男生引导到男生区，女生引导到女生区 /** 服务员抽象类 Waiter * accept(Customer customer) */ /** 以纯商场服务员 extends Waiter * */ function YiChunWaiter() { this.accept = function(customer) { customer.visit(this); } // 服务女士 this.serverWoman = function() { console.log(\"带领女士到女士服装区.\"); } // 服务男士 this.serveMan = function() { console.log(\"带领男士到男士服装区.\"); } } /** 顾客接口（访问者） * visit(MarketWaiter waiter) */ /** 女士顾客 * */ function WomanCustomer() { this.visit = function(waiter) { waiter.serverWoman(); } } /** 男士顾客 * */ function ManCustomer() { this.visit = function(waiter) { waiter.serveMan(); } } // 测试 var yichunWaiter = new YiChunWaiter(); var womanCustomer = new WomanCustomer(); var manCustomer = new ManCustomer(); yichunWaiter.accept(womanCustomer); yichunWaiter.accept(manCustomer); Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-25 22:29:19 "},"Algorithms/Javascript/知识盲点.html":{"url":"Algorithms/Javascript/知识盲点.html","title":"知识盲点.md","keywords":"","body":"算法 斐波那契数列通项公式（爬楼梯leecode有矩阵推导） 特征方程，矩阵分解，差分方程 IntersectionObserver watchItem() { this.$slots.list.forEach((item, index) => { const observer = new IntersectionObserver(entries => { if (entries[0].isIntersecting) this.$emit('change', { index }) }, { threshold: 0.5 }) observer.observe(item.elm) }) } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-07-13 22:56:59 "},"Algorithms/Javascript/算法常见面试.html":{"url":"Algorithms/Javascript/算法常见面试.html","title":"面试常见","keywords":"","body":"算法 时间复杂度 通常使用最差的时间复杂度来衡量一个算法的好坏。 常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。 对于一个算法来说，可能会计算出如下操作次数 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。 位运算 位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制 33 可以看成是 32 + 1 ，并且 33 应该是六位二进制的（因为 33 近似 32，而 32 是 2 的五次方，所以是六位），那么 十进制 33 就是 100001 ，只要是 2 的次方，那么就是 1 否则都为 0 那么二进制 100001 同理，首位是 2^5 ，末位是 2^0 ，相加得出 33 左移 10 20 左移就是将二进制全部往左移动，10 在二进制中表示为 1010 ，左移一位后变成 10100 ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 a * (2 ^ b) 算数右移 >> 10 >> 1 // -> 5 算数右移就是将二进制全部往右移动并去除多余的右边，10 在二进制中表示为 1010 ，右移一位后变成 101 ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 int v = a / (2 ^ b) 右移很好用，比如可以用在二分算法中取中间值 13 >> 1 // -> 6 按位操作 按位与 每一位都为 1，结果才为 1 8 & 7 // -> 0 // 1000 & 0111 -> 0000 -> 0 按位或 其中一位为 1，结果就是 1 8 | 7 // -> 15 // 1000 | 0111 -> 1111 -> 15 按位异或 每一位都不同，结果才为 1 8 ^ 7 // -> 15 8 ^ 8 // -> 0 // 1000 ^ 0111 -> 1111 -> 15 // 1000 ^ 1000 -> 0000 -> 0 从以上代码中可以发现按位异或就是不进位加法 面试题：两个数不使用四则运算得出和 这道题中可以按位异或，因为按位异或就是不进位加法，8 ^ 8 = 0 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a & b) function sum(a, b) { if (a == 0) return b if (b == 0) return a let newA = a ^ b let newB = (a & b) 排序 以下两个函数是排序中会用到的通用函数，就不一一写了 function checkArray(array) { if (!array || array.length 冒泡排序 冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。 以下是实现该算法的代码 function bubble(array) { checkArray(array) for (let i = array.length - 1; i > 0; i--) { // 从 0 到 `length - 1` 遍历 for (let j = 0; j array[j + 1]) swap(array, j, j + 1) } } return array } ` 该算法的操作次数是一个等差数列 (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 也可以这么写看着好理解 1 比较相邻的两个元素，如果前一个比后一个大，则交换位置。 2 比较完第一轮的时候，最后一个元素是最大的元素。 3 这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。 function bSort(arr) { var len = arr.length; for (var i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr; } //举个数组 myArr = [20,18,27,19,35]; //使用函数 bSort(myArr) 插入排序（类似斗地主插排） 插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。 以下是实现该算法的代码 function insertion(array) { checkArray(array) for (let i = 1; i = 0 && array[j] > array[j + 1]; j--) swap(array, j, j + 1) } return array } 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序 选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作。 以下是实现该算法的代码 function selection(array) { checkArray(array) for (let i = 0; i 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 归并排序 归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。 以下是实现该算法的代码 function sort(array) { checkArray(array) mergeSort(array, 0, array.length - 1) return array } function mergeSort(array, left, right) { // 左右索引相同说明已经只有一个数 if (left === right) return // 等同于 `left + (right - left) / 2` // 相比 `(left + right) / 2` 来说更加安全，不会溢出 // 使用位运算是因为位运算比四则运算快 let mid = parseInt(left + ((right - left) >> 1)) mergeSort(array, left, mid) mergeSort(array, mid + 1, right) let help = [] let i = 0 let p1 = left let p2 = mid + 1 while (p1 以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下 mergeSort(data, 0, 6) // mid = 3 mergeSort(data, 0, 3) // mid = 1 mergeSort(data, 0, 1) // mid = 0 mergeSort(data, 0, 0) // 遇到终止，回退到上一步 mergeSort(data, 1, 1) // 遇到终止，回退到上一步 // 排序 p1 = 0, p2 = mid + 1 = 1 // 回退到 `mergeSort(data, 0, 3)` 执行下一个递归 mergeSort(2, 3) // mid = 2 mergeSort(3, 3) // 遇到终止，回退到上一步 // 排序 p1 = 2, p2 = mid + 1 = 3 // 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑 // 排序 p1 = 0, p2 = mid + 1 = 2 // 执行完毕回退 // 左边数组排序完毕，右边也是如上轨迹 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 O(N * logN) 快速排序 快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。 以下是实现该算法的代码 function sort(array) { checkArray(array); quickSort(array, 0, array.length - 1); return array; } function quickSort(array, left, right) { if (left array[right]) { // 当前值比基准值大，将当前值和右边的值交换 // 并且不改变 `left`，因为当前换过来的值还没有判断过大小 swap(array, --more, left); } else { // 和基准值相同，只移动下标 left++; } } // 将基准值和比基准值大的第一个值交换位置 // 这样数组就变成 `[比基准值小, 基准值, 比基准值大]` swap(array, right, more); return [less, more]; } 该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。 面试题 Sort Colors：该题目来自 LeetCode，题目需要我们将 [2,0,2,1,1,0] 排序成 [0,0,1,1,2,2] ，这个问题就可以使用三路快排的思想。 以下是代码实现 var sortColors = function(nums) { let left = -1 let right = nums.length let i = 0 // 下标如果遇到 right，说明已经排序完成 while (i Kth Largest Element in an Array：该题目来自 LeetCode，题目需要找出数组中第 K 大的元素，这问题也可以使用快排的思路。并且因为是找出第 K 大元素，所以在分离数组的过程中，可以找出需要的元素在哪边，然后只需要排序相应的一边数组就好。 以下是代码实现 var findKthLargest = function(nums, k) { let l = 0 let r = nums.length - 1 // 得出第 K 大元素的索引位置 k = nums.length - k while (l k) { r = index - 1 } else { break } } return nums[k] } function part(array, left, right) { let less = left - 1 let more = right while (left array[right]) { swap(array, --more, left) } else { left++ } } swap(array, right, more) return more } 堆排序 堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。 大根堆是某个节点的所有子节点的值都比他小 小根堆是某个节点的所有子节点的值都比他大 堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i 2 + 1，右边是 i 2 + 2，父节点是 (i - 1) /2。 首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大 然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小 对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置 重复以上操作 3 - 4 直到整个数组都是大根堆。 以下是实现该算法的代码 function heap(array) { checkArray(array) // 将最大值交换到首位 for (let i = 0; i 0) { heapify(array, 0, size) swap(array, 0, --size) } return array } function heapInsert(array, index) { // 如果当前节点比父节点大，就交换 while (array[index] > array[parseInt((index - 1) / 2)]) { swap(array, index, parseInt((index - 1) / 2)) // 将索引变成父节点 index = parseInt((index - 1) / 2) } } function heapify(array, index, size) { let left = index * 2 + 1 while (left 以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。 该算法的复杂度是 O(logN) 系统自带排序实现 每个语言的排序内部实现都是不同的。 对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 源码实现 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN)相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。 对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。 链表 反转单向链表 该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题 以下是实现该算法的代码 var reverseList = function(head) { // 判断下变量边界问题 if (!head || !head.next) return head // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null let pre = null let current = head let next // 判断当前节点是否为空 // 不为空就先获取当前节点的下一节点 // 然后把当前节点的 next 设为上一个节点 // 然后把 current 设为下一个节点，pre 设为当前节点 while (current) { next = current.next current.next = pre pre = current current = next } return pre } 树 二叉树的先序，中序，后序遍历 先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。 使用yield*语句中序遍历遍历完全二叉树。 // 下面是二叉树的构造函数， // 三个参数分别是左树、当前节点和右树 function Tree(left, label, right) { this.left = left; this.label = label; this.right = right; } // 下面是中序（inorder）遍历函数。 // 由于返回的是一个遍历器，所以要用generator函数。 // 函数体内采用递归算法，所以左树和右树要用yield*遍历 function* inorder(t) { if (t) { yield* inorder(t.left); yield t.label; yield* inorder(t.right); } } // 下面生成二叉树 function make(array) { // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2])); } let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]); // 遍历二叉树 var result = []; for (let node of inorder(tree)) { result.push(node); } result // ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。 递归实现 递归实现相当简单，代码如下 function TreeNode(val) { this.val = val this.left = this.right = null } var traversal = function(root) { if (root) { // 先序 console.log(root) traversal(root.left) // 中序 // console.log(root); traversal(root.right) // 后序 // console.log(root); } } 对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了。 非递归实现 非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。 以下是先序遍历代码实现 function pre(root) { if (root) { let stack = [] // 先将根节点 push stack.push(root) // 判断栈中是否为空 while (stack.length > 0) { // 弹出栈顶元素 root = stack.pop() console.log(root) // 因为先序遍历是先左后右，栈是先进后出结构 // 所以先 push 右边再 push 左边 if (root.right) { stack.push(root.right) } if (root.left) { stack.push(root.left) } } } } 以下是中序遍历代码实现 function mid(root) { if (root) { let stack = [] // 中序遍历是先左再根最后右 // 所以首先应该先把最左边节点遍历到底依次 push 进栈 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点 // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点 // 左边打印不出东西就把父节点拿出来打印，然后再看右节点 while (stack.length > 0 || root) { if (root) { stack.push(root) root = root.left } else { root = stack.pop() console.log(root) root = root.right } } } } 以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多 function pos(root) { if (root) { let stack1 = [] let stack2 = [] // 后序遍历是先左再右最后根 // 所以对于一个栈来说，应该先 push 根节点 // 然后 push 右节点，最后 push 左节点 stack1.push(root) while (stack1.length > 0) { root = stack1.pop() stack2.push(root) if (root.left) { stack1.push(root.left) } if (root.right) { stack1.push(root.right) } } while (stack2.length > 0) { console.log(s2.pop()) } } } 中序遍历的前驱后继节点 实现这个算法的前提是节点有一个 parent 的指针指向父节点，根节点指向 null 。 如图所示，该树的中序遍历结果是 4, 2, 5, 1, 6, 3, 7 前驱节点 对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 2 ，那么节点 2 的最右节点就是 5 如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点 如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1 ，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点 以下是算法实现 function predecessor(node) { if (!node) return // 结论 1 if (node.left) { return getRight(node.left) } else { let parent = node.parent // 结论 2 3 的判断 while (parent && parent.right === node) { node = parent parent = node.parent } return parent } } function getRight(node) { if (!node) return node = node.right while (node) node = node.right return node } 后继节点 对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6 如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点 以下是算法实现 function successor(node) { if (!node) return // 结论 1 if (node.right) { return getLeft(node.right) } else { // 结论 2 let parent = node.parent // 判断 parent 为空 while (parent && parent.left === node) { node = parent parent = node.parent } return parent } } function getLeft(node) { if (!node) return node = node.left while (node) node = node.left return node } 树的深度 树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度 以下是算法实现 var maxDepth = function(root) { if (!root) return 0 return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 } 对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到 3。 动态规划 动态规划背后的基本思想非常简单。就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。 一旦得出每个子问题的解，就存储该结果以便下次使用。 斐波那契数列 斐波那契数列就是从 0 和 1 开始，后面的数都是前两个数之和 0，1，1，2，3，5，8，13，21，34，55，89.... 那么显然易见，我们可以通过递归的方式来完成求解斐波那契数列 function fib(n) { if (n = 0) return n return fib(n - 1) + fib(n - 2) } fib(10) 尾递归优化 function Fibonacci(n, ac1 = 0, ac2 = 1) { if(n 以上第一个代码解决问题了。但是以上解法却存在很严重的性能问题，当 n 越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。 动态规划的本质其实就是两点 自底向上分解子问题 通过变量存储已经计算过的解 根据上面两点，我们的斐波那契数列的动态规划思路也就出来了 斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层 通过数组来存储每一位所对应的斐波那契数列的值 function fib(n) { let array = new Array(n + 1).fill(null) array[0] = 0 array[1] = 1 for (let i = 2; i 0 - 1 背包问题 该问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。 假设我们有以下物品 物品 ID /重量 价值 1 3 2 7 3 12 对于一个总容量为 5 的背包来说，我们可以放入重量 2 和 3 的物品来达到背包内的物品总价值最高。 对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题 物品 ID / 剩余容量 0 1 2 3 4 5 1 0 3 3 3 3 3 2 0 3 7 10 10 10 3 0 3 7 12 15 19 直接来分析能放三种物品的情况，也就是最后一行 当容量少于 3 时，只取上一行对应的数据，因为当前容量不能容纳物品 3 当容量 为 3 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，总价值为 12，所以应该放入物品 3 当容量 为 4 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 1 的价值相加，得出总价值为 15，所以应该放入物品 3 当容量 为 5 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 2 的价值相加，得出总价值为 19，所以应该放入物品 3 以下代码对照上表更容易理解 /** * @param {*} w 物品重量 * @param {*} v 物品价值 * @param {*} C 总容量 * @returns */ function knapsack(w, v, C) { let length = w.length if (length === 0) return 0 // 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量 // 第二维中的元素代表背包物品总价值 let array = new Array(length).fill(new Array(C + 1).fill(null)) // 完成底部子问题的解 for (let i = 0; i = w[0] ? v[0] : 0 } // 自底向上开始解决子问题，从物品 2 开始 for (let i = 1; i = w[i]) { // 可以放入的话，就比大小 // 放入当前物品和不放入当前物品，哪个背包总价值大 array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j - w[i]]) } } } return array[length - 1][C] } 最长递增子序列 最长递增子序列意思是在一组数字中，找出最长一串递增的数字，比如 0, 3, 4, 17, 2, 8, 6, 10 对于以上这串数字来说，最长递增子序列就是 0, 3, 4, 8, 10，可以通过以下表格更清晰的理解 数字 0 3 4 17 2 8 6 10 长度 1 2 3 4 2 4 4 5 通过以上表格可以很清晰的发现一个规律，找出刚好比当前数字小的数，并且在小的数组成的长度基础上加一。 这个问题的动态思路解法很简单，直接上代码 function lis(n) { if (n.length === 0) return 0 // 创建一个和参数相同大小的数组，并填充值为 1 let array = new Array(n.length).fill(1) // 从索引 1 开始遍历，因为数组已经所有都填充为 1 了 for (let i = 1; i n[j]) { array[i] = Math.max(array[i], 1 + array[j]) } } } let res = 1 for (let i = 0; i 字符串相关 在字符串相关算法中，Trie 树可以解决解决很多问题，同时具备良好的空间和时间复杂度，比如以下问题 词频统计 前缀匹配 如果你对于 Trie 树还不怎么了解，可以前往 这里 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 23:07:44 "},"Algorithms/Javascript/递归，尾递归，相互递归，蹦床函数.html":{"url":"Algorithms/Javascript/递归，尾递归，相互递归，蹦床函数.html","title":"递归，尾递归，相互递归，蹦床函数.md","keywords":"","body":"递归 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 我们知道，es5是没有尾递归优化的，所以在递归的时候，如果层数太多，就会报“Maximum call stack size exceeded”的错误。就连下面这个及其简单的递归函数都会报“Maximum call stack size exceeded”的错误。 function haha(a) { if(!a) return a; return haha(a-1); } haha(100); //输出0 haha(12345678); //输出“Maximum call stack size exceeded” 为什么会报“Maximum call stack size exceeded”的错误？我觉得原因是在每次递归调用的时候，会把当前作用域里面的基本类型的值推进栈中，所以一旦递归层数过多，栈就会溢出，所以会报错。 注意： js中的栈只会储存基本类型的值，比如：number, string, undefined, null, boolean。 为什么在调用下一层递归函数的时候没有释放上一层递归函数的作用域？因为在回来的时候还需要用到里面的变量。 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 尾递归（参考阮一峰） 怎么优化上面的情况呢？方法是使用尾递归。有尾递归优化的编译器会把尾递归编译成循环的形式，如果没有尾递归优化，那就自己写成循环的形式。如下面的例子所示： //尾递归函数，返回一个函数调用，并且这个函数调用是自己 function haha(a, b) { if(b) return b; return haha(a, a-1); } //优化成循环的形式 function yaya(a) { let b = a; while(b) { b = b - 1; } } 需要注意的是，看上面尾递归的代码，有一点很重要，就是用一个b变量来存上一次递归的值。这是尾递归常用的方法。另外，其实上面尾递归的代码不需要变量b，但为了便于说明，所以我加上了变量b。 // 尾递归优化阶乘 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 function restricted() { 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 尾递归优化的实现 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 function sum(x, y) { if (y > 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y > 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 trampoline(sum(1, 100000)) // 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 相互递归 但是关于递归还有一种形式，就是相互递归，如下面的代码所示： ``` function haha1(a) { if(!a) return a; return haha2(a-1); } function haha2(a) { if(!a) return a; return haha1(a-1); } haha1(100); //输出0 haha1(12345678); //输出Maximum call stack size exceeded 可以看到，当相互递归层数过多的时候，也会发生栈溢出的情况。 ## 蹦床函数 蹦床函数就是解决上面问题的方法。 **蹦床函数**（trampoline）就是将 **递归执行 转为 循环执行**。 执行的都是同样的步骤，只是反复执行，就好像在蹦床，跳上去，掉下来，在跳上去… 蹦床函数的实现： function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 首先我们改写上面的相互递归函数： function haha1(a) { if(!a) return a; return function() { return haha2(a-1); } } function haha2(a) { if(!a) return a; return function() { return haha1(a-1); } } >这个改写就是建立一个闭包来封装相互递归的函数，它的好处是由于不是直接的相互递归调用，所以不会把上一次的递归作用域推进栈中，而是把封装函数储存在堆里面，利用堆这个容量更大但读取时间更慢的储存形式来替代栈这个容量小但读取时间快的储存形式，用时间来换取空间。 我们尝试使用一下上面的函数： haha1(3)(); //输出一个函数 haha1(3)()()(); //输出0 >通过上面的示例可以看到，如果参数不是3而是很大的一个数字的时候，我们就需要写很多个括号来实现调用很多次。为了简便，我们可以把这种调用形式写成函数，这就是蹦床函数。如下所示： function trampoline(func, a) { let result = func.call(func, a); while(result && result instanceof Function) { result = result(); } return result; } >基本原理是一直调用，直到返回值不是一个函数为止。 最后来使用蹦床函数： trampoline(haha1, 12345678); //过一会儿就输出0 由于储存在堆中，所以耗时较长，过了一会儿才会输出0，但是并没有报栈溢出的错误。 ``` Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:57:52 "},"Algorithms/Javascript/动态规划.html":{"url":"Algorithms/Javascript/动态规划.html","title":"动态规划.md","keywords":"","body":"算法 动态规划 动态规划有时被认为是一种与递归相反的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。 核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。 重叠子问题、最优子结构、状态转移方程就是动态规划三要素。 应用动态规划——将动态规划拆分成三个子目标 1.建立状态转移方程 当做已经知道f(1)~f(n-1)的值，然后想办法求得f(n)的值 2.缓存并复用以往结果 依次顺序计算。因为状态方程基本限制了你只能从小到大一步步递推出最终的结果。然而当问题复杂起来的时候，你有可能乱了套，所以必须记住这也是目标之一。 3.按顺序从小往大算 爬楼梯 ``` 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 ``` /** * @param {number} n * @return {number} */ var climbStairs = function(n) { let arr = []; arr[1] = 1 //1阶台阶,只有一种方式(1) arr[2] = 2 //2阶台阶,有两种方式(1+1, 2) for(let i=3;i时间复杂度：O(n) 空间复杂度：O(n) 空间复杂度优化： 滑动数组法 /** * @param {number} n * @return {number} */ var climbStairs = function(n) { if(n == 1){ return 1 } let first = 1, second = 2 for(let i = 3; i使用最小花费爬楼梯 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 class Solution { public int minCostClimbingStairs(int[] cost) { int f1 = 0,f2 = 0; for(int i = 0;i 零钱兑换 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 「自顶向下」思想来考虑这个题目，然后用「自底向上」的方法来解题， 体验算法的冰火两重天。 - dp[i]: 表示总金额为 i 的时候最优解法的硬币数 - 我们想一下：求总金额 120 有几种方法？下面这个思路关键了 !!! 一共有 3 种方式，因为我们有 3 种不同面值的硬币。 1.拿一枚面值为 1 的硬币 + 总金额为 119 的最优解法的硬币数量 这里我们只需要假设总金额为 119 的最优解法的硬币数有人已经帮我们算好了， 不需要纠结于此。(虽然一会也是我们自己算，哈哈) 即：dp[119] + 1 2.拿一枚面值为 2 的硬币 + 总金额为 118 的最优解法的硬币数 这里我们只需要假设总金额为 118 的最优解法的硬币数有人已经帮我们算好了 即：dp[118] + 1 3.拿一枚面值为 5 的硬币 + 总金额为 115 的最优解法的硬币数 这里我们只需要假设总金额为 115 的最优解法的硬币数有人已经帮我们算好了 即：dp[115] + 1 - 所以，总金额为 120 的最优解法就是上面这三种解法中最优的一种，也就是硬币数最少 的一种，我们下面试着用代码来表示一下： - dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1); - 推导出「状态转移方程」： dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...) 其中 coin 有多少种可能，我们就需要比较多少次，那么我们到底需要比较多少次呢？ 当然是 coins 数组中有几种不同面值的硬币，就是多少次了~ 遍历 coins 数组， 分别去对比即可 - 上面方程中的 dp[119]，dp[118]，dp[115] 我们继续用这种思想去分解， 这就是动态规划了，把这种思想，思考问题的方式理解了，这一类型的题目 问题都不会太大。 /** * @param {number[]} coins * @param {number} amount * @return {number} */ var coinChange = (coins, amount) => { let dp = new Array(amount + 1).fill(Infinity) dp[0] = 0 for(let coin of coins){ for(let i=0;i=0){ dp[i] = Math.min(dp[i],dp[i-coin]+1) } } } return dp[amount] == 'Infinity' ? -1 : dp[amount] } 寻找最长公共子串 定义二维数组dp[i][j]，其中i用于遍历字符串s1的下标，j用于遍历s2的下标，于是dp[i][j]就用于记录当s1和s2分别遍历到i和j下标时，以s1[i]和s2[j]为结尾的最大公共子串长度，而要求最终的最大公共子串，需要用一个max_length变量随时记录当前的最大公共子串长度，并用res变量获取当前的最大公共子串。 算法设计： 首先考虑参数null或长度为0的情况，直接返回空串 进入双重循环（分别遍历s1和s2串的各个字符）： 如果s1[i] == s2[j] then 考虑边界情况，i==0 或 j==0 的情况下，dp[i][j] = 1 除了边界情况，其余位置都满足 dp[i][j] = dp[i-1][j-1] + 1 每次更新最大长度以及最大长度对应的公共子串 返回最大公共子串 function lcs(word1,word2){ if( !word1 || !word2 || word1.length == 0 || word2.length == 0) { return '' } let max=0; // 记录最大长度 let index=0; // 最大长度时，记录子串的结尾位置 let lcsarr=new Array(word1.length); for(let i=0;i扩大空间 行和列都多加了一个并且都是0，这是为了当第一个字符相等时 lcsarr1=lcsarr0+1 成立 function lcs(word1,word2){ if( !word1 || !word2 || word1.length == 0 || word2.length == 0) { return '' } let max=0; // 记录最大长度 let index=0; // 最大长度时，记录子串的结尾位置 let lcsarr=new Array(word1.length+1); for(let i=0;i动态规划基础问题整理 「动态规划」问题没有套路，请大家根据情况掌握自己需要的部分，多做一些问题或许是有用的。 第 1 部分：「动态规划」基本问题 递归 + 记忆化：记忆化递归（记忆化搜索），这是「自上而下」的思路； 掌握「自底向上」递推求解问题的方法； 理解「重复子问题」、「最优子结构」、「无后效性」； 掌握「状态定义」、「状态转移方程」 题目序号 题解 知识点 代码 509. 斐波那契数（简单） 递归做一定要加缓存。 70. 爬楼梯（简单） CSDN 和斐波拉契数是同一道问题。 第 2 部分：最优子结构 题目序号 题解 知识点 代码 279. 完全平方数（中等） 322. 零钱兑换（中等） 动态规划、使用「完全背包」问题思路、图的广度优先遍历 343. 整数拆分（中等） “贪心选择”性质的简单证明、记忆化搜索、动态规划 （Python、Java） 第 3 部分：无后效性 题目序号 题解 知识点 代码 198. 打家劫舍（简单） 二维状态消除后效性 62. 不同路径（中等） 63. 不同路径 II（中等） 第 4 部分：经典问题（1） 题目序号 题解 知识点 代码 53. 最大子序和 动态规划、分治法、CSDN 1、经典动态规划问题；2、分治 300. 最长上升子序列 动态规划 、贪心算法 + 二分 5. 最长回文子串 Manacher 算法 + 动态规划 （Java、C++、Python） 使用动态规划的方法得到子串的回文性质 72. 编辑距离 动态规划（Java）、CDSN 120. 三角形最小路径和（中等） 10. 正则表达式匹配（困难） 第 5 部分：经典问题（2）背包问题 题目序号 题解 知识点 代码 416. 分割等和子集 动态规划（0-1 背包问题） 很重要的动态规划模型，必须掌握 518. 零钱兑换 II 动态规划（套用完全背包问题模型） 322. 零钱兑换（中等） 动态规划、使用「完全背包」问题思路、图的广度优先遍历 377. 组合总和 Ⅳ 动态规划 494. 目标和 0-1 背包问题 474. 一和零 动态规划（转换为 0-1 背包问题） 第 6 部分：经典问题（3）股票问题 题目序号 题解 知识点 代码 121. 买卖股票的最佳时机（简单） 暴力枚举 + 动态规划 + 差分思想、CSDN 122. 买卖股票的最佳时机 II（简单） 暴力搜索 + 贪心算法 + 动态规划、CSDN 123. 买卖股票的最佳时机 III（困难） 动态规划、CSDN 1、从后向前写可以把状态压缩到一维；2、分解成两个 121 题。 188. 买卖股票的最佳时机 IV（困难） 动态规划 309. 最佳买卖股票时机含冷冻期（中等） 动态规划 714. 买卖股票的最佳时机含手续费（中等） 动态规划 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 01:02:13 "},"Algorithms/Javascript/回溯算法.html":{"url":"Algorithms/Javascript/回溯算法.html","title":"回溯算法.md","keywords":"","body":"算法 回溯算法 https://leetcode-cn.com/problems/number-of-islands/ https://leetcode-cn.com/problems/n-queens/ https://leetcode-cn.com/problems/permutations/ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-08 22:01:07 "},"Algorithms/Javascript/大数据.html":{"url":"Algorithms/Javascript/大数据.html","title":"大数据处理.md","keywords":"","body":"面试-大数据 题目- 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url? 假如每个url大小为10bytes，那么可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。 Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,...,a999，每个小文件约300M); Step2:遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,...,b999); 巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0vsb0,a1vsb1,...,a999vsb999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。 Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 2.有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。 Step1：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,...,f4999)中，这样每个文件大概是200k左右，如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M; Step2：对每个小文件，统计每个文件中出现的词以及相应的频率(可以采用trie树/hash_map等)，并取出出现频率最大的100个词(可以用含100个结点的最小堆)，并把100词及相应的频率存入文件，这样又得到了5000个文件; Step3：把这5000个文件进行归并(类似与归并排序); 3.现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。 Step1：从这一天的日志数据中把访问百度的IP取出来，逐个写入到一个大文件中; Step2：注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件; Step3：找出每个小文中出现频率最大的IP(可以采用hash_map进行频率统计，然后再找出频率最大的几个)及相应的频率; Step4：在这1000个最大的IP中，找出那个频率最大的IP，即为所求。 4.一亿个数据选取其中最大1000条？ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-09 17:48:51 "},"Algorithms/Java/":{"url":"Algorithms/Java/","title":"Java实现","keywords":"","body":"Java实现 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-14 13:49:11 "},"Algorithms/知识点/树.html":{"url":"Algorithms/知识点/树.html","title":"知识点","keywords":"","body":"二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定 义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值， 在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。 几个概念 深度优先遍历 中序遍历 先序遍历 后序遍历 广度优先遍历（层次遍历） 第一步构建一个BinarySearchTree类function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; } 第二步(实现一些方法) insert(key)：向树中插入一个新的键。 inOrderTraverse：通过中序遍历方式遍历所有节点。 preOrderTraverse：通过先序遍历方式遍历所有节点。 postOrderTraverse：通过后序遍历方式遍历所有节点。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。 remove(key)：从树中移除某个键。insert function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key inOrderTraverse和中序遍历 function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key 先序遍历 function BinarySearchTree(arr) { ... // 先序遍历 this.preOrderTraverse = function (callBack) { preOrderTraverseNode(root, callBack); }; var preOrderTraverseNode = function(node,callBack) { if(!!node) { callBack(node.key); preOrderTraverseNode(node.left, callBack); preOrderTraverseNode(node.right, callBack); } } } function printNode(val) { console.log(val); } ... 后序遍历 function BinarySearchTree(arr) { ... // 后序遍历 this.postOrderTraverse = function (callBack) { postOrderTraverseNode(root, callBack); }; var postOrderTraverseNode = function(node,callBack) { if(!!node) { postOrderTraverseNode(node.left, callBack); postOrderTraverseNode(node.right, callBack); callBack(node.key); } } } function printNode(val) { console.log(val); } ... 广度优先（层次遍历） function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key 最小值和最大值 function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key 最难的删除值 function BinarySearchTree(arr) { let root = null; // 根元素 // 一个Node类来表示树中的每个节点 let Node = function (key) { this.key = key; this.left = null; this.right = null; }; // 向树中插入一个节点 this.insert = function(key) { // 1.创建用来表示新节点的Node类实例 var newNode = new Node(key); if (root == null) { root = newNode; } else { insertNode(root,newNode); } }; // 一个私有的辅助函数,将节点加在非根节点的其他位置 var insertNode = function(parentNode,newNode) { if (newNode.key node.key) { node.right = removeNode(node.right, key); return node; } else { // 找到node // 第一种情况node是一个叶节点 if (node.right == null && node.left == null) { node = null return node; } // 第二种情况node只有一个叶节点 if (node.left == null) { node = node.right return node } else if(node.right == null){ node = node.left return node } // 第三种node有两个子节点 var minNode = findMinNode(node) node.key = minNode.key node.right = removeNode(node.right, minNode.key); return node } }; var findMinNode = function (node) { while(node.left && node.key !== null) { node = node.left; } return node } } function printNode(val) { console.log(val); } var tree = new BinarySearchTree(); tree.insert(1); tree.insert(2); tree.insert(3); tree.insert(6); tree.insert(5); tree.insert(3); tree.insert(7); tree.insert(8); tree.insert(9); tree.wideTraversal(printNode) tree.remove(9) tree.wideTraversal(printNode) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 17:17:20 "},"UseInJob/Js.html":{"url":"UseInJob/Js.html","title":"Js ✘","keywords":"","body":"/* * 移动端rem适配，px:rem = 100:1 * 该适配兼容UC竖屏转横屏出现的BUG * 自定义设计稿的宽度：designWidth * 最大宽度:maxWidth * 这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(1000, 1000); babel-plugin-proposal-optional-chaining 遍历一个深层的树状结构数据时，总要去判断该中间节点的数据是否存在，之后再去取值或者对应的操作， 最常见的场景就是在对接后端的api了，假设现在有这么一个api返回obj let person = { name: 'a', owner: { token: '54163sdf', permission: { usecar: true } } }, let usecar = person.owner.permission.usecar() 我们需要取到person下面的owner下面的permission权限中用车权限usecar，上面的代码是我们大部分时候的做法，问题来了，我们怎么能够保证对象的中间节点数据都存在的呢，保不齐就是一个error. 常规办法 大部分时候我们的做法是判断取值或者引入带三方库像lodash等 if (person && person.owner && person.owner.permission) { let usecar = person.owner.permission.usecar, } _.get(person, 'owner.permission.usecar'); 应运而生 可选链(Optionalchaining)，在此背景下，目前已经进入了草案stage2阶段，相信很快就会大规模使用了，它使我们能检查一个对象上面的某属性是否为null或者undefined，如果是在则返回undefined，而不会报错。 // 使用示例 let usecar = person?.owner?.permission?.usecar ?? true; 有没有很酷，再也不用为了解决容错而写过多重复代码了，简单说下工作原理, 操作符检查 ?. 会检查操作符左边的值是否为 null 或 undefined。如果是，这个表达式就终止然后返回 undefined。否则，这个表达式继续执行检查通过! 另外配合stage2中的另一新特性 Nullish coalescing operator（??运算符），我们可以很方便的处理类似取值默认值的情况。 语法 // Optional Chaining 的语法有三种使用场景： obj?.prop // optional static property access obj?.[expr] // optional dynamic property access func?.(...args) // optional function or method call 至于为什么语法不是 obj?prop， 这种简洁一点的表达方式，在 FAQ 中有提到这个例子： obj?[expr].filter(fun):0 引擎难以判断 obj?[expr] 是 Optional Chaning，亦或这是一个普通的三元运算语句. 详细对于该提议（Optional Chaining）的分析，推荐阅读下面这篇文章： 可选链草案分析 使用问题 因为现在还是提案，浏览器还没有很好的支持，现在想在项目中使用是不可能的，不过总有大牛默默的帮我们铺平了道路，对应的babel插件已经存在， babel-plugin-proposal-optional-chaining, 下面我们简单看看该插件转义后的代码时啥样的? const babel = require('@babel/core'); const code = 'const obj = {}; const baz = obj?.foo?.foo1'; const output = babel.transformSync(code, { plugins: [\"@babel/plugin-proposal-optional-chaining\"], }); console.log(output.code); 下面是编译后的代码： var _obj$foo; const obj = {}; const baz = obj === null || obj === void 0 ? void 0 : (_obj$foo = obj.foo) === null || _obj$foo === void 0 ? void 0 : _obj$foo.foo1; 这样看上去是不是可以更好的理解该特性了，注意: 该bebel插件并不支持Nullish coalescing operator（?? 运算符）。 rem 一、根据不同的设备宽度在根元素上设置不同的字体大小 (function(win) { var doc = win.document; var docEl = doc.documentElement; var tid; function refreshRem() { var width = docEl.getBoundingClientRect().width; if (width > 540) { // 最大宽度 width = 540; } var rem = width / 6.4; // 6.4 = 640 / 100; ( 640px的设计图 除了 100px ) docEl.style.fontSize = rem + 'px'; } win.addEventListener('resize', function() { clearTimeout(tid); tid = setTimeout(refreshRem, 300); }, false); win.addEventListener('pageshow', function(e) { if (e.persisted) { clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); refreshRem(); })(window); 简化版 (function() { function remAdapt() { var winWth = window.innerWidth, maxWth = 472, pageWth = winWth>maxWth?maxWth:winWth; var fontSize = pageWth/maxWth*16; fontSize = fontSize>12?fontSize:12; document.documentElement.style.fontSize = Math.round(fontSize)+'px'; } document.addEventListener('DOMContentLoaded', remAdapt) window.addEventListener('resize', remAdapt); })(); 二、根据 devicePixelRatio 设定 initial-scale 来放大 viewport，使页面按照物理像素渲染，提升清晰度 /** * MobileWeb 通用功能助手，包含常用的 UA 判断、页面适配、search 参数转 键值对。 * 该 JS 应在 head 中尽可能早的引入，减少重绘。 * * fixScreen 方法根据两种情况适配，该方法自动执行。 * 1. 定宽： 对应 meta 标签写法 -- * 该方法会提取 width 值，主动添加 scale 相关属性值。 * 注意： 如果 meta 标签中指定了 initial-scale， 该方法将不做处理（即不执行）。 * 2. REM: 不用写 meta 标签，该方法根据 dpr 自动生成，并在 html 标签中加上 data-dpr 和 font-size 两个属性值。 * 该方法约束：IOS 系统最大 dpr = 3，其它系统 dpr = 1，页面每 dpr 最大宽度（即页面宽度/dpr） = 750，REM 换算比值为 16。 * 对应 css 开发，任何弹性尺寸均使用 rem 单位，rem 默认宽度为 视觉稿宽度 / 16; * scss 中 $ppr(pixel per rem) 变量写法 -- $ppr: 750px/16/1rem; * 元素尺寸写法 -- html { font-size: $ppr*1rem; } body { width: 750px/$ppr; }。 */ window.mobileUtil = (function(win, doc) { var UA = navigator.userAgent, isAndroid = /android|adr/gi.test(UA), isIos = /iphone|ipod|ipad/gi.test(UA) && !isAndroid, // 据说某些国产机的UA会同时包含 android iphone 字符 isMobile = isAndroid || isIos; // 粗略的判断 return { isAndroid: isAndroid, isIos: isIos, isMobile: isMobile, isNewsApp: /NewsApp\\/[\\d\\.]+/gi.test(UA), isWeixin: /MicroMessenger/gi.test(UA), isQQ: /QQ\\/\\d/gi.test(UA), isYixin: /YiXin/gi.test(UA), isWeibo: /Weibo/gi.test(UA), isTXWeibo: /T(?:X|encent)MicroBlog/gi.test(UA), tapEvent: isMobile ? 'tap' : 'click', /** * 缩放页面 */ fixScreen: function() { var metaEl = doc.querySelector('meta[name=\"viewport\"]'), metaCtt = metaEl ? metaEl.content : '', matchScale = metaCtt.match(/initial\\-scale=([\\d\\.]+)/), matchWidth = metaCtt.match(/width=([^,\\s]+)/); if ( !metaEl ) { // REM var docEl = doc.documentElement, maxwidth = docEl.dataset.mw || 750, // 每 dpr 最大页面宽度 dpr = isIos ? Math.min(win.devicePixelRatio, 3) : 1, scale = 1 / dpr, tid; docEl.removeAttribute('data-mw'); docEl.dataset.dpr = dpr; metaEl = doc.createElement('meta'); metaEl.name = 'viewport'; metaEl.content = fillScale(scale); docEl.firstElementChild.appendChild(metaEl); var refreshRem = function() { var width = docEl.getBoundingClientRect().width; if (width / dpr > maxwidth) { width = maxwidth * dpr; } var rem = width / 16; docEl.style.fontSize = rem + 'px'; }; win.addEventListener('resize', function() { clearTimeout(tid); tid = setTimeout(refreshRem, 300); }, false); win.addEventListener('pageshow', function(e) { if (e.persisted) { clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); refreshRem(); } else if ( isMobile && !matchScale && ( matchWidth && matchWidth[1] != 'device-width' ) ) { // 定宽 var width = parseInt(matchWidth[1]), iw = win.innerWidth || width, ow = win.outerWidth || iw, sw = win.screen.width || iw, saw = win.screen.availWidth || iw, ih = win.innerHeight || width, oh = win.outerHeight || ih, ish = win.screen.height || ih, sah = win.screen.availHeight || ih, w = Math.min(iw,ow,sw,saw,ih,oh,ish,sah), scale = w / width; if ( scale 三、可以使用淘宝的flexible.js https://github.com/amfe/lib-flexible 参考链接：http://www.jianshu.com/p/eb05c775d3c6 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-02 22:04:27 "},"UseInJob/axios.html":{"url":"UseInJob/axios.html","title":"axios ✘","keywords":"","body":"新建一个request文件夹 /** axios封装 请求拦截、响应拦截、错误统一处理 */ import axios from 'axios'; import router from '../router'; import store from '../store/index'; import { Toast } from 'vant'; /** 提示函数 禁止点击蒙层、显示一秒后关闭 */ const tip = msg => { Toast({ message: msg, duration: 1000, forbidClick: true }); } /** 跳转登录页 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */ const toLogin = () => { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); } /** 请求失败后的错误统一处理 @param {Number} status 请求失败的状态码 */ const errorHandle = (status, other) => { // 状态码判断 switch (status) { // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip('登录过期，请重新登录'); localStorage.removeItem('token'); store.commit('loginSuccess', null); setTimeout(() => { toLogin(); }, 1000); break; // 404请求不存在 case 404: tip('请求的资源不存在'); break; default: console.log(other); }} // 创建axios实例 var instance = axios.create({ timeout: 1000 12}); // 设置post请求头 instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; /* 请求拦截器 每次请求前，如果存在token则在请求头中携带token */ instance.interceptors.request.use( config => { // 登录流程控制中，根据本地是否存在token判断用户的登录情况 // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码 // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。 const token = store.state.token; token && (config.headers.Authorization = token); return config; }, error => Promise.error(error)) // 响应拦截器 instance.interceptors.response.use( // 请求成功 res => res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 error => { const { response } = error; if (response) { // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); } else { // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) { store.commit('changeNetwork', false); } else { return Promise.reject(error); } } }); export default instance; ## 新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。 index.js代码 /** api接口的统一出口 */ // 文章模块接口 import article from '@/api/article'; // 其他模块的接口…… // 导出接口 export default { article, // …… } base.js: /** 接口域名的管理 */ const base = { sq: 'https://xxxx111111.com/api/v1', bd: 'http://xxxxx22222.com/api' } export default base; 通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。 注意： axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8 ,这是axios默认的请求头content-type类型。但是实际我们后端要求的 'Content-Type': 'application/x-www-form-urlencoded' 为多见，这就与我们不符合。所以很多同学会在这里犯错误，导致请求数据获取不到。明明自己的请求地址和参数都对了却得不到数据。 我们现在来说说post请求常见的数据格式（content-type） Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端 Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端 Content-Type: multi > 如果是上传图片需要修改请求头, 扩展一个参数, config axios.post(URL, params, {headers: {'Content-Type': 'multipart/form-data'}}).then(res => { if (res.data.code === 0) { this.$router.go(-1) } }).catch(error => { alert('更新用户数据失败' + error) }) 最后就是接口模块的说明，例如上面的article.js: /** article模块接口列表 */ import base from './base'; // 导入接口域名列表 import axios from '@/utils/http'; // 导入http中创建的axios实例 import qs from 'qs'; // 根据需求是否导入qs模块引入 qs ，这个库是 axios 里面包含的，不需要再下载了。 const article = { // 新闻列表 articleList () { return axios.get(${base.sq}/topics); }, // 新闻详情,演示 articleDetail (id, params) { return axios.get(${base.sq}/topic/${id}, { params: params }); }, // post提交 login (params) { return axios.post(${base.sq}/accesstoken, qs.stringify(params)); } // 其他接口………… } export default article; 1. 通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对post请求时提交的数据进行一个qs序列化的处理等。 2. 请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，axios文档说的很清楚，这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。 3. restful风格的接口，也可以通过这种方式灵活的设置api接口地址。最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中： import Vue from 'vue' import App from './App' import router from './router' // 导入路由文件 import store from './store' // 导入vuex文件 import api from './api' // 导入api接口 Vue.prototype.$api = api; // 将api挂载到vue的原型上 然后我们可以在页面中这样调用接口，eg： methods: { onLoad(id) { this.$api.article.articleDetail(id, { api: 123 }).then(res=> { // 执行某些操作 }) }} 再提一下断网的处理，这里只做一个简单的示例： 我没网了 刷新 import { mapState } from 'vuex'; export default { name: 'App', computed: { ...mapState(['network']) }, methods: { // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的 onRefresh () { this.$router.replace('/refresh') } } } 这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其beforeRouteEnter钩子中再返回当前页面。 好像少了一个环节,refresh返回原页面后并没有刷新vuex里面network的状态 会导致network组件还在吧 // refresh.vue beforeRouteEnter (to, from, next) { next(vm => { vm.$router.replace(from.fullPath) })} ``` 这是一种全局通用的断网提示，当然了，也可以根据自己的项目需求操作。具体操作就仁者见仁智者见智了。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-26 22:52:42 "},"UseInJob/util.html":{"url":"UseInJob/util.html","title":"util ✘","keywords":"","body":"类型转换 function type(obj) { return Object.prototype.toString.call(obj).replace(/\\[object\\s|\\]/g, \"\"); } function isArray(list) { return type(list) === \"Array\"; } function isObject(obj) { return type(obj) === \"Object\"; } function isString(str) { return type(str) === \"String\"; } function isNotEmptyObj(obj) { return isObject(obj) && JSON.stringify(obj) != \"{}\"; } function objForEach(obj, fn) { isNotEmptyObj(obj) && Object.keys(obj).forEach(fn); } function aryForEach(ary, fn) { ary.length && ary.forEach(fn); } function setAttr(node, key, value) { switch (key) { case \"style\": node.style.cssText = value; break; case \"value\": var tagName = node.tagName || \"\"; tagName = tagName.toLowerCase(); if (tagName === \"input\" || tagName === \"textarea\") { node.value = value; } else { // if it is not a input or textarea, use `setAttribute` to set node.setAttribute(key, value); } break; default: node.setAttribute(key, value); break; } } function toArray(data) { if (!data) { return []; } const ary = []; aryForEach(data, item => { ary.push(item); }); return ary; } export { isArray, isObject, isString, isNotEmptyObj, objForEach, aryForEach, setAttr, toArray }; Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-08-14 15:29:47 "},"UseInJob/切换主题.html":{"url":"UseInJob/切换主题.html","title":"切换主题 ✘","keywords":"","body":"vue+less项目中利用纯css控制方法： 1.在你项目的common样式表里（应该有通用样式表吧？要不reset样式表？）写一句话： body { --themeColor: #0ff; } 这句话的作用是设置你的默认主题色。--themeColor是自定义的名字，大家随意。 2.js调用setProperty进行颜色值的控制，我觉得核心就是这句话： document.body.style.setProperty('--themeColor', this.$store.state.home.themeColor) 因为项目中在系统设置有个需求是用颜色选择器选择颜色点击确定后立刻更改主题色，所以我将颜色值改变写在了vuex中，通过dispatch进行更改颜色。这个大家可以根据自己的实际需求来做，有的可能就是指定几个颜色值进行切换，那就不需要像我这样用vuex来操作。 3.既然js已经控制了，那我们还需要在css中表达，在组件的style中需要控制的标签进行变化： .confirm { line-height: 40px; background-color: var(--themeColor); } 精华在于var()，这个var()是什么意思呢？这个函数用于插入自定义的属性值，如果这个属性值在很多地方被使用。这说的不就是我们切换主题色的需求吗？用他就对了！！！ 写到这里，需求就被完成了，亲测有效哦。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 14:21:44 "},"UseInJob/vue相关坑点.html":{"url":"UseInJob/vue相关坑点.html","title":"vue相关坑点 ✘","keywords":"","body":"vue项目中遇到的问题 使用 vue-router，页面加载完成后，$route 的值不正确 原因： 在 mounted 中，router 的初始化还没有完成，所以取到的是一个初始默认值。 解决方法： 用 onReady mounted(){ this.$router.onReady(() => { if (this.$route.matched.length === 0) { this.$router.push(\"/index\"); } }); } Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-28 00:32:31 "},"UseInJob/vue插件.html":{"url":"UseInJob/vue插件.html","title":"vue插件 ✘","keywords":"","body":"使用原理 插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令/过滤器/过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 概括出来就是 1、通过Vue.use(MyPlugin)使用，本质上是调用MyPlugin.install(Vue) 2、使用插件必须在new Vue()启动应用之前完成，实例化之前就要配置好。 3、如果使用Vue.use多次注册相同插件，那只会注册成功一次。 源码解读 Vue.use源码如下 Vue.use = function (plugin) { // 忽略已注册插件 if (plugin.installed) { return } // 集合转数组，并去除第一个参数 var args = toArray(arguments, 1); // 把this（即Vue）添加到数组的第一个参数中 args.unshift(this); // 调用install方法 if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args); } else if (typeof plugin === 'function') { plugin.apply(null, args); } // 注册成功 plugin.installed = true; return this; }; Vue.use接受一个对象参数plugin，首先判断是否已注册，如果多次注册相同插件那么只会注册成功一次，在注册成功后设置plugin.installed = true。 然后执行toArray(arguments, 1)方法，arguments是一个表示所有参数的类数组对象，需要转换成数组之后才能使用数组的方法。 function toArray (list, start) { start = start || 0; var i = list.length - start; var ret = new Array(i); // 循环去除 前start元素 while (i--) { ret[i] = list[i + start]; } return ret } 上面进行了一次转换，假设list是[1, 2, 3, 4]，start是1，首先创建一个包含3个元素的数组，依次执行ret[2] = list[ 2 + 1]、ret[1] = list[ 1 + 1]、ret[0] = list[ 0 + 1]，实际上就是去除arguments的第一个参数然后把剩余的类数组赋值给新的数组，其实就是去除plugin参数，因为调用plugin.install的时候不需要这个参数。 还可以通过如下几种方式实现类数组转换成数组，但是使用slice会阻止某些JavaScript引擎中的优化（参考自MDN）。 // ES5 var args = Array.prototype.slice.call(arguments); var args = [].slice.call(arguments); // ES6 const args = Array.from(arguments); const args = [...arguments]; 转换成数组之后调用args.unshift(this)，把Vue对象添加到args的第一个参数中，这样就可以在调用plugin.install方法的时候把Vue对象传递过去。 实例：实现一个插件 要求创建一个告诉Vue组件处理自定义rules规则选项的插件，这个rules需要一个对象，该对象指定组件中的数据的验证规则。 示例： const vm = new Vue({ data: { foo: 10 }, rules: { foo: { validate: value => value > 1, message: 'foo must be greater than one' } } }) vm.foo = 0 // 输出 foo must be greater than one 第一步先不考虑插件，在已有的VueAPI中是没有rules这个公共方法的，如果要简单实现的话可以通过钩子函数来，即在created里面验证逻辑。 const vm = new Vue({ data: { foo: 10 }, rules: { foo: { validate: value => value > 1, message: 'foo must be greater than one' } }, created: function () { // 验证逻辑 const rules = this.$options.rules if (rules) { Object.keys(rules).forEach(key => { // 取得所有规则 const { validate, message } = rules[key] // 监听，键是变量，值是函数 this.$watch(key, newValue => { // 验证规则 const valid = validate(newValue) if (!valid) { console.log(message) } }) }) } } }) 可以通过this.$options.rules获取到自定义的rules对象，然后对所有规则遍历，使用自定义的validate(newValue)验证规则。 第二步实现这个rules插件，为了在Vue中直接使用，可以通过Vue.mixin注入到Vue组件中，这样所有的Vue实例都可以使用。 按照插件的开发流程，应该有一个公开方法install，在install里面使用全局的mixin方法添加一些组件选项，mixin方法包含一个created钩子函数，在钩子函数中验证this.$options.rules。 实现代码如下： import Vue from 'vue' // 定义插件 const RulesPlugin = { // 插件应该有一个公开方法install // 第一个参数是Vue 构造器 // 第二个参数是一个可选的选项对象 install (Vue) { // 注入组件 Vue.mixin({ // 钩子函数 created: function () { // 验证逻辑 const rules = this.$options.rules if (rules) { Object.keys(rules).forEach(key => { // 取得所有规则 const { validate, message } = rules[key] // 监听，键是变量，值是函数 this.$watch(key, newValue => { // 验证规则 const valid = validate(newValue) if (!valid) { console.log(message) } }) }) } } }) } } // 调用插件，实际上就是调用插件的install方法 // 即RulesPlugin.install(Vue) Vue.use(RulesPlugin) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-28 00:31:58 "},"UseInJob/vue自定义指令相关.html":{"url":"UseInJob/vue自定义指令相关.html","title":"vue自定义指令相关 ✘","keywords":"","body":"场景 1.为组件添加loading效果 2.按钮级别权限控制 v-permission 3.代码埋点,根据操作类型定义指令 4.input 输入框自动获取焦点  1. vue指令实现权限控制  2. vue指令实现上传excel  3. v-track：&#x1F579;一个基于Vue指令实现的埋点插件~ 原理 vue指令本质 指令本质上是装饰器，是vue对HTML元素的扩展，给HTML元素增加自定义功能，语义化HTML标签。vue编译DOM时，会执行与指令关联的JS代码，即找到指令对象，执行指令对象的相关方法。 自定义指令生命周期 自定义指令有五个生命周期（也叫钩子函数），分别是bind、inserted、update、componentUpdated、unbind 钩子函数作用介绍 bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。 inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。 update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated：被绑定元素所在模板完成一次更新周期时调用。 unbind：只调用一次，指令与元素解绑时调用。 实现过程 源码 // 版本2.6.10 export default { create: updateDirectives, update: updateDirectives, destroy: function unbindDirectives (vnode: VNodeWithData) { updateDirectives(vnode, emptyNode) } } function updateDirectives (oldVnode: VNodeWithData, vnode: VNodeWithData) { if (oldVnode.data.directives || vnode.data.directives) { _update(oldVnode, vnode) } } function _update (oldVnode, vnode) { const isCreate = oldVnode === emptyNode // 判断虚拟节点是否是一个新创建的节点 const isDestroy = vnode === emptyNode // 当新的虚拟节点不存在，在旧虚拟节点存在时，为true const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context) // 旧指令集合 const newDirs = normalizeDirectives(vnode.data.directives, vnode.context) // 新指令集合 const dirsWithInsert = [] // 保存需要触发inserted指令钩子的列表 const dirsWithPostpatch = [] // 保存需要触发componentUpdated指令钩子的列表 let key, oldDir, dir for (key in newDirs) { oldDir = oldDirs[key] dir = newDirs[key] if (!oldDir) { // 判断oldDir是否存在，如果不存在，则首次绑定到元素中 // 调用bind callHook(dir, 'bind', vnode, oldVnode) // 判断指令是否有inserted方法，有则添加到dirsWithInsert，保证执行完指令的bind方法后执行inserted方法 if (dir.def && dir.def.inserted) { dirsWithInsert.push(dir) } } else { // oldDir存在，则更新指令 dir.oldValue = oldDir.value dir.oldArg = oldDir.arg callHook(dir, 'update', vnode, oldVnode) // 判断指令是否有componentUpdated方法，有则添加到dirsWithPostpatch， // 保证指令所在的vnode及自vnode更新完后（执行完指令的update方法后），执行componentUpdated方法 if (dir.def && dir.def.componentUpdated) { dirsWithPostpatch.push(dir) } } } if (dirsWithInsert.length) { const callInsert = () => { for (let i = 0; i { for (let i = 0; i , vm: Component ): { [key: string]: VNodeDirective } { const res = Object.create(null) if (!dirs) { return res } let i, dir for (i = 0; i 1. vue指令实现权限控制 思路： 登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到sessionStorage中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过token获取用户对应的 role，自定义指令，获取路由meta属性里btnPermissions( 注： meta.btnPermissions是存放按钮权限的数组，在路由表里配置 )，然后判断role是否在btnPermissions数组里，若不在即删除该按钮DOM。 按钮权限也可以用v-if判断，但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions,然后再做判断，感觉有点麻烦，而自定义指令，只需在权限按钮加入该指令即可。 路由配置： path: '/permission', component: Layout, name: '权限测试', meta: { btnPermissions: ['admin','supper','normal'] }, //页面需要的权限 children: [ { path: 'supper', component: _import('system/supper'), name: '权限测试页', meta: { btnPermissions: ['admin','supper'] } //页面需要的权限 }, { path: 'normal', component: _import('system/normal'), name: '权限测试页', meta: { btnPermissions: ['admin'] } //页面需要的权限 } ] 注：如果按钮的权限是由后台配置并返回的此处可不设置，从后台获取权限即可 自定义指令： import Vue from 'vue' /**权限指令**/ 　　const has = Vue.directive('has', { 　　// 当被绑定的元素插入到 DOM 中时…… 　　inserted: function (el, binding, vnode) { 　　let btnPermissions = ''; 　　// 获取指令按钮权限 　　let characteristic = binding.value; 　　if (characteristic) btnPermissions = characteristic; 　　// 获取路由按钮权限 　　btnPermissions = vnode.context.$route.meta.btnPermissions.split(','); 　　if (!Vue.prototype.$_has(btnPermissions)) { 　　el.parentNode.removeChild(el); 　　} 　　} 　　}); // 权限检查方法 Vue.prototype.$_has = function (value) { let isExist = false; let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\"); if (btnPermissionsStr == undefined || btnPermissionsStr == null) { return false; } let res = value.filter((x) => { 　　return btnPermissionsStr.include(x) }) if (res.length > 0) isExist = truereturn isExist; }; export {has} 然后在main.js文件引入文件 import has from './public/js/btnPermissions.js'; 页面中按钮只需加v-has即可 编辑 权限前后端都可进行控制，但是尽可能的在前端就进行拦截验证。借用一句经典名言：永远不相信用户输入！ 2. vue指令上传excel 前几天因为业务需求，所维护的而后台中出现了大量关于上传下载Excel的操作。因为我们的后台是基于Vue，并且是在 vue-element-admin 的基础上结合实际需求开发而来。vue-element-admin 中也有一些相关操作 Excel 的示例，都十分清晰明了，很快就能上手。而我们当然首要参考了 vue-element-admin 的操作方式，如上传 Excel： Drop excel file here or Browse import XLSX from 'xlsx' /// 在上传 Excel 中，vue-element-admin 的做法是，点击上传按钮时触发事先放在组件内的 input 的 click ,在通过监听 input 的 change 事件，获取读取到的 Excel 文档。事实上，对文件的处理也只能这样了，读取到 file 后通过 xlsx 工具库，对 file 进行 JSON 化处理再发给后端。（不要问我为什么这些事情要前端来做，问就是我乐意）。 刚刚说到这样做没得啥子问题，但是在实际项目中，尤其是后台管理系统，。几乎很多页面几乎都是表格、查询、批量操作等。最开始的时候，我就是直接把 input + 按钮 放在业务页面，但是随着项目慢慢变大，这样就显得有些臃肿了。不仅增加了代码量，也不利于维护。于是我把这个功能封装成了一个组将，就像 vue-element-admin 就类似那样。但是后来随着项目越来越来，越来越多的页面需要 Excel 操作，我对这种频繁引入此组件的方式也开始不厌其法。这个时候其实就有两种选择了：将组件注册为全局组件，或者使用自定义指令达到相同的效果。正如标题写的那样，我选择了后者。 因为 Excel 这个需求，体现上无非就是：点击了某个按钮，弹出文件选择，用户选择 Excel 后直接读取。因此，直接参与在业务中的只有按钮，至于用户在选择 Excel 后，我需要把这部操作封装一下，因为逐步操作和业务没有直接关系。因此，我需要实现一个针对选择 Excel 按钮的自定义指令： // 注册全局自定义快速读取 excel `v-read-excel` Vue.directive('read-excel', { inserted: (el, { value }) => { const id = Date.now() const input = document.createElement('input') el['read-excel-id'] = id input.id = id input.type = 'file' input.accept = '.xlsx, .xls' input.onchange = ({ target: { files: [excel] }}) => { if(!excel) return const XLSX = require('xlsx') const reader = new FileReader() reader.onload = async({ target: { result }}) => { const workbook = XLSX.read(result, { type: 'array' }) value && value(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]])) } reader.readAsArrayBuffer(excel) } input.style.display = 'none' document.body.appendChild(input) el.addEventListener('click', () => document.getElementById(id).click()) }, unbind: el => document.getElementById(el['read-excel-id']).remove() }) 使用起来无需引入组件，更无需 input ，只需要这样： 上传Excel export default { name: 'PageUploadExcel', data() { return { list: [] } }, methods: { upload(list) { this.list = list } } } 原理很简单：在被绑定按钮插入文档后，给这个按钮配套一个 input 放在 body 里，点击按钮就会触发 input ... 在被绑定按钮被移除文档同时也删除掉自己所对应的 input。 这就是关于上传 Excel 的自定义指令封装操作。 至于下载，也是参考 vue-element-admin 的做法，不过也是为了使用简便，就直接把方法挂在 Vue 原型上了： Vue.prototype.$excel = function(list, name) { !list.length ? list = [{ '暂无数据': '' }] : '' import('@/utils/Export2Excel').then(excel => { excel.export_json_to_excel({ header: Object.keys(list[0]), data: list.map(listItem => Object.keys(list[0]).map(j => listItem[j])), filename: name || '下载Excel', bookType: 'xlsx' }) }) } 这个用起来更简单： 下载Excel export default { name: 'PageDownloadExcel', data() { return { list: [ { '姓名': '张三', '年龄': 18, '爱好': '旅游' }, { '姓名': '李四', '年龄': 19, '爱好': '游泳' }, { '姓名': '王五', '年龄': 20, '爱好': '吃鸡' } ] } }, methods: { download() { this.$excel(this.list, '数据表格') } } } 可能你也注意到了，我在这里使用的数据是： [ { '姓名': '张三', '年龄': 18, '爱好': '旅游' }, { '姓名': '李四', '年龄': 19, '爱好': '游泳' }, { '姓名': '王五', '年龄': 20, '爱好': '吃鸡' } ] 是的，key - value 都是直接用来展示的汉字。这样做，除了方便外，也可以实现后端实时控制导出的字段，我司目前使用的就是这种方式。当然，这个要看具体的业务需求了。 3. v-track：&#x1F579;一个基于Vue指令实现的埋点插件~ Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-27 23:59:48 "},"Database/InterView/查询学生成绩相关.html":{"url":"Database/InterView/查询学生成绩相关.html","title":"查询学生成绩相关 ✘","keywords":"","body":"如图有这样一张成绩表： 首先要理解group by 含义：“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。 先来看这样一条sql语句：select subject,max(score) from grade GROUP BY subject 这样正确的得出了每一科的最高分以及科目的名称。那是不是再在后面加个name就可以得出对应的学生的名字呢？我们可以试试：select subject,max(score),name from grade GROUP BY subject 一看有结果以为成功了，但是对比数据后发现是错的，学生姓名和分数没对应上。如果你认为是成功的是因为对group by理解的不够，我也不知道这样查询为什么能出来结果，我使用的mysql数据库，如果是oracle的话就会报错。 注意：因为在select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。 所以这样是错误的。 group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中，常见的聚合函数如下表： 函数 作用 支持性 sum(列名) 求和 max(列名) 最大值 min(列名) 最小值 avg(列名) 平均值 first(列名) 第一条记录 仅Access支持 last(列名) 最后一条记录 仅Access支持 count(列名) 统计记录数 注意和count(*)的区别 我们还是分析要求，通过要求来写sql语句。 这里提供几种方法： 我们已经通过group by分组来获得每一科的最高分以及科目名称，把它作为第一句sql，，然后再查询一下score表，找到学科和分数都相同的记录:（子sql语句作为主sql语句的一部分） 注：a. 表示a表中所有的字段，b.表示b表中所有的字段 select b.* from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 结果如下： 对比发现数据是对的。 拓展问法：用一句SQL查出所有课程成绩最高和最低的学生及其分数。 首先，通过分组获得每个学科的最高分以及最低分： select subject,max(score),MIN(score) from grade GROUP BY subject 结果如下： 那我们如何把最高分对应的学生名字和最低分对应的名字放入呢，而且要求的数据展示是最高分一行，最低分一行。所以这样行不通。 通过上面的第一个问题得出的思路： select b.* from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 这样既然能得到每个学科的最高分，学生名字，学科名，那同样把max（score）改成min（score）不就可以获得最低分，学生名字，学科名字了吗？现在重点是如何把两条sql语句查询出来的结果整合到一起。 select b.* from (select subject,min(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 此时想到了sql的关键字 : UNION的定义 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 所以得出的sql是这样的： select b.* from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score UNION select b.* from (select subject,min(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 得出的结果是： 这样就ok了。如果还想添加一些东西。例如添加一列说明这个分数是最低分或者最高分。 select b.*,\"最高分\" from (select subject,max(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score UNION select b.*,\"最低分\" from (select subject,min(score) m from grade GROUP BY subject) t,grade b where t.subject=b.subject and t.m=b.score 原文链接：https://blog.csdn.net/u010827070/article/details/79712303 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-08 17:09:48 "},"Database/InterView/优化相关.html":{"url":"Database/InterView/优化相关.html","title":"优化相关 ✘","keywords":"","body":"1.索引优化 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 问：select * from t where b = ? order by a如何索引优化？ MySQL索引通常是被用于提高WHERE条件的数据行匹配或者执行联结操作时匹配其它表的数据行的搜索速度。 MySQL也能利用索引来快速地执行ORDER BY和GROUP BY语句的排序和分组操作。 通过索引优化来实现MySQL的ORDER BY语句优化： ORDER BY的索引优化。如果一个SQL语句形如： SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort]; 在[sort]这个栏位上建立索引就可以实现利用索引进行order by 优化。 WHERE + ORDER BY的索引优化，形如： SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort]; 建立一个联合索引(columnX,sort)来实现order by 优化。 注意：如果columnX对应多个值，如下面语句就无法利用索引来实现order by的优化 SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort]; WHERE+ 多个字段ORDER BY SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10; 建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。 MySQL Order By不能使用索引来优化排序的情况 对不同的索引键做 ORDER BY ：(key1,key2分别建立索引) SELECT * FROM t1 ORDER BY key1, key2; 在非连续的索引键部分上做 ORDER BY：(key_part1,key_part2建立联合索引;key2建立索引) SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2; 同时使用了 ASC 和 DESC：(key_part1,key_part2建立联合索引) SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC; 用于搜索记录的索引键和做 ORDER BY 的不是同一个：(key1,key2分别建立索引) SELECT * FROM t1 WHERE key2=constant ORDER BY key1; 如果在WHERE和ORDER BY的栏位上应用表达式(函数)时，则无法利用索引来实现order by的优化 SELECT * FROM t1 ORDER BY YEAR(logindate) LIMIT 0,10; 特别提示: 1>mysql一次查询只能使用一个索引。如果要对多个字段使用索引，建立复合索引。 2>在ORDER BY操作中，MySQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5.in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 6.下面的查询也将导致全表扫描： select id from t where name like '李%' 若要提高效率，可以考虑全文检索。 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)='abc' name以abc开头的id，应改为: select id from t where name like 'abc%' 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12.不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 13.很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19.任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21.避免频繁创建和删除临时表，以减少系统表资源的消耗。 22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。 29.尽量避免大事务操作，提高系统并发能力。 30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-08 17:46:17 "},"项目规范/前端/eslint+prettier+editorconfig+lint-staged.html":{"url":"项目规范/前端/eslint+prettier+editorconfig+lint-staged.html","title":"eslint+prettier+editorconfig+lint-staged ✘","keywords":"","body":"eslint、prettier、editorconfig、stylelint、lint-staged、husky、commitlint eslint和prettier以及editorconfig 使用场景 ESLint 静态分析您的代码，以帮助您检测格式问题并查找代码不一致之处。 Prettier 格式化代码类似于ESLint，但不会检查代码质量。它只是用作代码格式化程序。尽管它本身就支持JavaScript，而且还支持JSX，Flow，TypeScript，HTML，JSON，CSS和许多其他语言。 EditorConfig 在一组开发人员中使用的所有IDE和编辑器中定义了标准的代码格式样式指南。 所有与编辑器相关的配置（行尾、缩进样式、缩进大小…）都应该由EditorConfig处理 所有与代码格式相关的事情都应该由Prettier处理 其余部分（代码质量）应由ESLint处理 自动修复能力 ESLint和Prettier都提供了一种自动修复功能，无论何时发现错误，它们都可以对代码进行更改。可以在您的IDE或编辑器中集成此强大功能，以便在保存文件或粘贴一些代码时更正和格式化代码。另一方面，EditorConfig将直接覆盖编辑器的配置。 为什么要这三个？ ESLint已经进行了代码自动格式化，那么为什么要使用Prettier？而当我们在使用它时，Prettier已经无需编辑器即可格式化我们的代码。那么，为什么还要用EditorConfig？ 首先（linters）检查代码风格/错误的小工具有两大规则： 格式规则：防止代码不一致且丑陋的规则（例如：max-len，no-mixed-spaces-and-tabs，关键字间距，逗号样式…） 代码质量规则：防止无用或出错的代码的规则（例如，未使用的var，no-exbind-bind，no-implicit-globals，prefer-promise-reject-errors…） ESLint可以同时应用这两种规则，并可以自动修复代码。漂亮，而另一方面，仅检查格式错误代码中，但它更好地完成这个工作比ESLint。 集成vscode 安装好Eslint插件 安装Prettier - Code formatter插件 安装editorConfig for vscode 修改vscode的settings.json文件 command + shift + p输入settings.json修改settings.json文件 \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true }, \"eslint.format.enable\": true, // 为了避免和 eslint 冲突，编辑器默认的代码检查规则关闭（如果开启了） \"editor.formatOnSave\": false, \"javascript.format.enable\": false, 进行配置（js文件） 1.安装 eslint + prettier yarn add eslint prettier -D 2.安装 eslint-config-prettier yarn add eslint-config-prettier -D 【作用】 让所有可能会与 prettier 规则存在冲突的 eslint rule，失效，并使用 prettier 的规则进行代码检查。 相当于，用 prettier 的规则，覆盖掉 eslint:recommended 的部分规则。 后面 prettier 格式化，也会根据这个规则来。因此，不会再有冲突。 【使用】 .eslintrc.js { \"extends\": [\"eslint:recommended\", \"prettier\"] } 3.安装 eslint-plugin-prettier yarn add eslint-plugin-prettier -D 【作用】 将 prettier 的能力集成到 eslint 中。按照 prettier 的规则检查代码规范性，并进行修复。 【使用】 .eslintrc.js { \"rules\":{ \"prettier/prettier\":\"error\" // 不符合 prettier 规则的代码，要进行错误提示（红线） }, \"plugins\": [\"prettier\"] } 或 { \"extends\": [\"eslint:recommended\",\"plugin:prettier/recommended\"] } 【看一下效果】 npx eslint --fix main.js 至此，eslint 会拥有和 prettier 一样的修复能力。 像 prettier 一样，格式化所有不符合规范的代码。 4.使用编辑器，自动格式化代码 （1）使用自己编辑器的快捷键，格式化代码 以 vscode 为例：shift + option + f 默认格式化规则选择 prettier，即可完成代码格式化。 （2）保存代码，自动格式化 同样以 vscode 为例，打开你的 settings.json，添加下面这句话： \"editor.formatOnSave\": true 【注】 至此，js、json、less等文件，均可实现自动格式化。 文件格式化规则，遵从我们在 .eslintrc.js 里的配置。也就是，使用我们的 prettier 插件默认规则去格式化。 【附】 如果你使用的是 webstorm，或许可以参考这个 https://www.jianshu.com/p/2f3cad152192 5.规则定制化 保存任意 js 文件，观察当前规则是否符合期望。如果不符合，根目录下创建 .prettierrc，进行定制化配置。 如 .prettierrc 如下： { \"singleQuote\": true } 再次保存代码，prettier 将会把 js 文件中的双引号，全部格式化为单引号。 至此，对 js 文件的规范定义与自动格式化配置，全部完成。 【注】 这里的 .prettierrc，具有格式化规则的最高优先级。 四、让 eslint 认识 js 以外的更多语法【以 typescript 为例】 1.安装 （1）使用 ts，自然要安装 typescript （2）为了让 eslint 认识 ts 语法，要安装相应的 parser （3）为了指定 ts 代码的规范，要安装相应的 plugin yarn add typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin -D 2.配置 { \"parser\":\"@typescript-eslint/parser\", \"extends\":[\"plugin:@typescript-eslint/recommended\", \"eslint:recommended\", \"prettier\"], \"env\":{ \"es6\":true, \"node\":true }, \"rules\":{ \"prettier/prettier\":\"error\" }, \"plugins\": [\"prettier\"] } 【注】extends 的含义 告诉 eslint，根据指定的规范，去检查指定类型的文件。 如上例： 根据 @typescript-eslint/recommended 规范，检查 ts 代码。 根据 eslint:recommended + prettier 规范，去检查 js 代码。 当某一类型的文件，被制定了不止1个规范，存在某些规范冲突时，后面的会覆盖掉前面的。 在本例中，prettier 制定的规范，会覆盖掉 eslint:recommended 的某些规范。 eslint 会按照覆盖后的规则，去检查 js 文件。 3.使用 npx eslint --fix main.ts 【如果能够正常格式化】 done。 【如果出现问题】 这里，eslint 会使用 prettier 插件，根据 prettier 的规则格式化代码。 但同时，eslint 会根据 @typescript-eslint/recommended 的规则，检查代码规范性。 当 @typescript-eslint/recommended 的规则和 prettier 的规则出现不一致，就会造成，格式化后的代码，报 eslint 错误的问题。 4.解决冲突（如果存在冲突） 使用相应的 prettier 插件，消除冲突。 也就是说，prettier 的规则和 @typescript-eslint/recommended 存在冲突，那就使用 prettier/@typescript-eslint 插件。 和前面，使用 eslint-config-prettier 消除 eslint:recommended 与 prettier 的规则冲突，同理。 { \"parser\":\"@typescript-eslint/parser\", \"extends\":[ \"plugin:@typescript-eslint/recommended\", \"eslint:recommended\", \"prettier\", \"prettier/@typescript-eslint\" ], \"env\":{ \"es6\":true, \"node\":true }, \"rules\":{ \"prettier/prettier\":\"error\" }, \"plugins\": [\"prettier\"] } 【注意】 这里，不要通过手动写 rules，去消除出现的冲突。 因为，已经发现的冲突，可能只是部分冲突，手写 rule 不能完整解决冲突问题，会存在遗漏。 5.自定义规则 当 prettier 插件的默认规则，与团队习惯不符合时，进行规则自定义。 （1）校验规则定义（.eslintrc.js） { \"parser\":\"@typescript-eslint/parser\", \"extends\":[ \"plugin:@typescript-eslint/recommended\", \"eslint:recommended\", \"prettier\", \"prettier/@typescript-eslint\" ], \"env\":{ \"es6\":true, \"node\":true }, \"rules\":{ \"prettier/prettier\":\"error\", // 比如，自定义缩进约束为4格（注意：这个规则会对所有文件生效，不只是ts） \"@typescript-eslint/indent\": [\"error\", 4] }, \"plugins\": [\"prettier\"] } （2）格式化规则定义（.prettierrc） { \"tabWidth\": 4 // 与 eslint 的自定义规则保持一致 } 五、Prettier 和 EditorConfig 有些规则，editorconfig 和 .prettierrc 同时可以定义。 因此，我们要避免冗余、重复的定义。 这些规则如下： end_of_line indent_style indent_size/tab_width max_line_length 我们将这些规则的定义，均放在 .editorconfig 中。 配置好 .editorconfig 后，保存代码，即使没有配置 .prettierrc，prettier 也会按照 .editorconfig 的定义来格式化代码。 六、规范检查增强（husky + lint-staged） 在 git commit 之前，先强制执行prettier格式化（防止某些成员开发期间不开启编辑器格式化）、再检查代码规范，如果检查不通过、阻止提交。 1.新建 .eslintignore + .prettierignore .eslintignore、.prettierignore，参考如下： .DS_Store node_modules dist .gitignore .eslintignore .prettierignore LICENSE README.md yarn.lock # local env files .env.local .env.*.local # Log files npm-debug.log* yarn-debug.log* yarn-error.log* # Editor directories and files .idea .vscode *.suo *.ntvs* *.njsproj *.sln *.sw? 2.安装 yarn add husky lint-staged -D 3.使用（如果使用脚手架可以灵活改变） package.json添加： \"scripts\": { \"lint\": \"eslint .\", \"prettier\": \"prettier --write .\" }, \"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" } }, \"lint-staged\": { \"*\": [ \"npm run prettier\", \"npm run lint\", \"git add .\" ] } vue cli中 { \"gitHooks\": { \"pre-commit\": \"lint-staged\" }, \"lint-staged\": { \"*.{js,vue}\": [ \"vue-cli-service lint\", \"git add\" ] } } git commit 之前，会自动使用 prettier 格式化 ignore 之外的代码。格式化后，自动检查所有文件，是否全部符合 eslint 规范。 存在不符合规范的代码，git commit 将被终止。 【注】 因为 prettier 只是会帮我们格式化代码，并不能够修复所有 eslint 错误，比如定义未使用的变量，prettier 不会自动帮我们删除，要手动删除。 因此，prettier 后再 eslint，是有必要的。 最后rule规则大全以及高级用法 // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 在块级作用域外访问块内定义的变量是否报错提示 \"block-scoped-var\": 0, // if while function 后面的{必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", { \"allowSingleLine\": true }], // 双峰驼命名格式 \"camelcase\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [2, \"never\"], // 控制逗号前后的空格 \"comma-spacing\": [2, { \"before\": false, \"after\": true }], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], // 圈复杂度 \"complexity\": [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2,\"never\"], // 强制方法必须返回值，TypeScript强类型，不配置 \"consistent-return\": 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // if else while for do后面的代码块是否需要{ }包围，参数： // multi 只有块中有多行语句时才需要{ }包围 // multi-line 只有块中有多行语句时才需要{ }包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要{ }包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, \"multi\", \"consistent\"] 保持前后语句的{ }一致 // default: [2, \"all\"] 全都需要{ }包围 \"curly\": [2, \"all\"], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, {\"allowKeywords\": false}] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, {\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"}] \"dot-notation\": [2, {\"allowKeywords\": true}], // 文件末尾强制换行 \"eol-last\": 2, // 使用 === 替代 == \"eqeqeq\": [2, \"allow-null\"], // 方法表达式是否需要命名 \"func-names\": 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f(){} e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() {} e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", { \"allowArrowFunctions\": true }] \"func-style\": 0, \"no-alert\": 0,//禁止使用alert confirm prompt \"no-array-constructor\": 2,//禁止使用数组构造器 \"no-bitwise\": 0,//禁止使用按位运算符 \"no-caller\": 1,//禁止使用arguments.caller或arguments.callee \"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名 \"no-class-assign\": 2,//禁止给类赋值 \"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句 \"no-console\": 2,//禁止使用console \"no-const-assign\": 2,//禁止修改const声明的变量 \"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1) \"no-continue\": 0,//禁止使用continue \"no-control-regex\": 2,//禁止在正则表达式中使用控制字符 \"no-debugger\": 2,//禁止使用debugger \"no-delete-var\": 2,//不能对var声明的变量使用delete操作符 \"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/ \"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 {a:1,a:1} \"no-dupe-args\": 2,//函数参数不能重复 \"no-duplicate-case\": 2,//switch中的case标签不能重复 \"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句 \"no-empty\": 2,//块语句中的内容不能为空 \"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空 \"no-empty-label\": 2,//禁止使用空label \"no-eq-null\": 2,//禁止对null使用==或!=运算符 \"no-eval\": 1,//禁止使用eval \"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值 \"no-extend-native\": 2,//禁止扩展native对象 \"no-extra-bind\": 2,//禁止不必要的函数绑定 \"no-extra-boolean-cast\": 2,//禁止不必要的bool转换 \"no-extra-parens\": 2,//禁止非必要的括号 \"no-extra-semi\": 2,//禁止多余的冒号 \"no-fallthrough\": 1,//禁止switch穿透 \"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3. \"no-func-assign\": 2,//禁止重复的函数声明 \"no-implicit-coercion\": 1,//禁止隐式转换 \"no-implied-eval\": 2,//禁止使用隐式eval \"no-inline-comments\": 0,//禁止行内备注 \"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数） \"no-invalid-regexp\": 2,//禁止无效的正则表达式 \"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量 \"no-irregular-whitespace\": 2,//不能有不规则的空格 \"no-iterator\": 2,//禁止使用__iterator__ 属性 \"no-label-var\": 2,//label名不能与var声明的变量名相同 \"no-labels\": 2,//禁止标签声明 \"no-lone-blocks\": 2,//禁止不必要的嵌套块 \"no-lonely-if\": 2,//禁止else语句内只有if语句 \"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） \"no-mixed-requires\": [0, false],//声明时不能混用声明类型 \"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格 \"linebreak-style\": [0, \"windows\"],//换行风格 \"no-multi-spaces\": 1,//不能用多余的空格 \"no-multi-str\": 2,//字符串不能用\\换行 \"no-multiple-empty-lines\": [1, {\"max\": 2}],//空行最多不能超过2行 \"no-native-reassign\": 2,//不能重写native对象 \"no-negated-in-lhs\": 2,//in 操作符的左边不能有! \"no-nested-ternary\": 0,//禁止使用嵌套的三目运算 \"no-new\": 1,//禁止在使用new构造一个实例后不赋值 \"no-new-func\": 1,//禁止使用new Function \"no-new-object\": 2,//禁止使用new Object() \"no-new-require\": 2,//禁止使用new require \"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number \"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON() \"no-octal\": 2,//禁止使用八进制数字 \"no-octal-escape\": 2,//禁止使用八进制转义序列 \"no-param-reassign\": 2,//禁止给参数重新赋值 \"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接 \"no-plusplus\": 0,//禁止使用++，-- \"no-process-env\": 0,//禁止使用process.env \"no-process-exit\": 0,//禁止使用process.exit() \"no-proto\": 2,//禁止使用__proto__属性 \"no-redeclare\": 2,//禁止重复声明变量 \"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ \"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错 \"no-return-assign\": 1,//return 语句中不能有赋值表达式 \"no-script-url\": 0,//禁止使用javascript:void(0) \"no-self-compare\": 2,//不能比较自身 \"no-sequences\": 0,//禁止使用逗号运算符 \"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 \"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 \"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格 \"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2] \"no-sync\": 0,//nodejs 禁止同步方法 \"no-ternary\": 0,//禁止使用三目运算符 \"no-trailing-spaces\": 1,//一行结束后面不要有空格 \"no-this-before-super\": 0,//在调用super()之前不能使用this或super \"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\"; \"no-undef\": 1,//不能有未定义的变量 \"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined \"no-undefined\": 2,//不能使用undefined \"no-unexpected-multiline\": 2,//避免多行表达式 \"no-underscore-dangle\": 1,//标识符不能以_开头或结尾 \"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; \"no-unreachable\": 2,//不能有无法执行的代码 \"no-unused-expressions\": 2,//禁止无用的表达式 \"no-unused-vars\": [2, {\"vars\": \"all\", \"args\": \"after-used\"}],//不能有声明后未被使用的变量或参数 \"no-use-before-define\": 2,//未定义前不能使用 \"no-useless-call\": 2,//禁止不必要的call和apply \"no-void\": 2,//禁用void操作符 \"no-var\": 0,//禁用var，用let和const代替 \"no-warning-comments\": [1, { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" }],//不能有警告备注 \"no-with\": 2,//禁用with \"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格 \"arrow-parens\": 0,//箭头函数用小括号括起来 \"arrow-spacing\": 0,//=>的前/后括号 \"accessor-pairs\": 0,//在对象中使用getter/setter \"block-scoped-var\": 0,//块语句中使用var \"brace-style\": [1, \"1tbs\"],//大括号风格 \"callback-return\": 1,//避免多次调用回调什么的 \"camelcase\": 2,//强制驼峰法命名 \"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号 \"comma-spacing\": 0,//逗号前后的空格 \"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾 \"complexity\": [0, 11],//循环复杂度 \"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的 \"consistent-return\": 0,//return 后面是否允许省略 \"consistent-this\": [2, \"that\"],//this别名 \"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super \"curly\": [2, \"all\"],//必须使用 if(){} 中的{} \"default-case\": 2,//switch语句最后必须有default \"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾 \"dot-notation\": [0, { \"allowKeywords\": true }],//避免不必要的方括号 \"eol-last\": 0,//文件以单一的换行符结束 \"eqeqeq\": 2,//必须使用全等 \"func-names\": 0,//函数表达式必须有名字 \"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式 \"generator-star-spacing\": 0,//生成器函数*的前后空格 \"guard-for-in\": 0,//for in循环要用if语句过滤 \"handle-callback-err\": 0,//nodejs 处理错误 \"id-length\": 0,//变量名长度 \"indent\": [2, 4],//缩进风格 \"init-declarations\": 0,//声明时必须赋初值 \"key-spacing\": [0, { \"beforeColon\": false, \"afterColon\": true }],//对象字面量中冒号的前后空格 \"lines-around-comment\": 0,//行前/行后备注 \"max-depth\": [0, 4],//嵌套块深度 \"max-len\": [0, 80, 4],//字符串最大长度 \"max-nested-callbacks\": [0, 2],//回调嵌套深度 \"max-params\": [0, 3],//函数最多只能有3个参数 \"max-statements\": [0, 10],//函数内最多有几个声明 \"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 \"new-parens\": 2,//new时必须加小括号 \"newline-after-var\": 2,//变量声明后是否需要空一行 \"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格 \"object-shorthand\": 0,//强制对象字面量缩写语法 \"one-var\": 1,//连续声明 \"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的 \"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首 \"padded-blocks\": 0,//块语句内行首行尾是否要空行 \"prefer-const\": 0,//首选const \"prefer-spread\": 0,//首选展开运算 \"prefer-reflect\": 0,//首选Reflect的方法 \"quotes\": [1, \"single\"],//引号类型 `` \"\" '' \"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号 \"radix\": 2,//parseInt必须指定第二个参数 \"id-match\": 0,//命名检测 \"require-yield\": 0,//生成器函数必须有yield \"semi\": [2, \"always\"],//语句强制分号结尾 \"semi-spacing\": [0, {\"before\": false, \"after\": true}],//分号前后空格 \"sort-vars\": 0,//变量声明时排序 \"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格 \"space-before-blocks\": [0, \"always\"],//不以新行开始的块{前面要不要有空格 \"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格 \"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格 \"space-infix-ops\": 0,//中缀操作符周围要不要有空格 \"space-return-throw-case\": 2,//return throw case后面要不要加空格 \"space-unary-ops\": [0, { \"words\": true, \"nonwords\": false }],//一元运算符的前/后要不要加空格 \"spaced-comment\": 0,//注释风格不要有空格什么的 \"strict\": 2,//使用严格模式 \"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN() \"valid-jsdoc\": 0,//jsdoc规则 \"valid-typeof\": 2,//必须使用合法的typeof的值 \"vars-on-top\": 2,//var必须放在作用域顶部 \"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格 \"wrap-regex\": 0,//正则表达式字面量用小括号包起来 \"yoda\": [2, \"never\"]//禁止尤达条件 } } eslint层叠配置。例如，假如你有以下结构： your-project ├── .eslintrc ├── lib │ └── source.js └─┬ tests ├── .eslintrc └── test.js 层叠配置使用离要检测的文件最近的 .eslintrc文件作为最高优先级，然后才是父目录里的配置文件， Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-02 22:03:00 "},"项目规范/前端/相关命令.html":{"url":"项目规范/前端/相关命令.html","title":"相关命令 ✘","keywords":"","body":"常用命令  1. node版本升级 1. node版本升级 node有一个模块叫n（这名字可够短的。。。），是专门用来管理node.js的版本的。 首先安装n模块： sudo npm install -g n 第二步：升级node.js到最新稳定版 n stable n后面也可以跟随版本号比如： n v0.10.26 或 n 0.10.26 几个npm的常用命令 npm list #列出已安装模块 npm show express #显示模块详情 npm update #升级当前目录下的项目的所有模块 npm update express #升级当前目录下的项目的指定模块 npm update -g express #升级全局安装的express模块 npm uninstall express #删除指定的模块 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 13:14:09 "},"项目规范/前端/vue-cli中规范.html":{"url":"项目规范/前端/vue-cli中规范.html","title":"vue-cli中规范 ✘","keywords":"","body":"前言 使用eslint+prettier好处： 避免运行时因格式问题报错 方便团队合作，代码风格统一0. 建立项目 利用Vue-cli3建立Vue项目时，一定要选上Linter/Formatter，然后选择 ESLint + Prettier 1. 安装vscode插件 首先在vscode中安装如下插件： eslint vetur prettier editorconfig2. 配置 .eslintrc.js(根目录下找) 注：代码缩进不是4个空格报错。 .prettierrc 在文件根目录下创建.prettierrc对prettier格式化进行自定义规则设置，以下为我添加的规则 { /* 单引号包含字符串 */ \"singleQuote\": true, /* 不添加末尾分号 */ \"semi\": false, /* 在对象属性添加空格 */ \"bracketSpacing\": true, /* 优化html闭合标签不换行的问题 */ \"htmlWhitespaceSensitivity\": \"ignore\", /* 只有一个参数的箭头函数的参数是否带圆括号（默认avoid） */ \"arrowParens\": \"avoid\" } .editorconfig 在文件根目录下创建.editorconfig，内容如下： root = true [*] charset = utf-8 # 缩进风格为空格 indent_style = space # 缩进大小为4 indent_size = 4 ## 表示以Unix风格的换行符结尾 # end_of_line = lf # insert_final_newline = true # # 设为true表示会除去换行行首的任意空白字符。 # trim_trailing_whitespace = true [setting.json]（com + shift +P）参考(http://book.93lin.cn/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83/%E5%89%8D%E7%AB%AF/eslint+prettier+editorconfig+lint-staged.html) Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 13:16:24 "},"项目规范/git常见命令.html":{"url":"项目规范/git常见命令.html","title":"git常见命令 ✘","keywords":"","body":"1.1 克隆Git代码 $ git clone http://xxxx.git --branch master 为自己的写新项目添加git版本控制，进入项目目录执行以下命令： git init . 2 分支相关 2.1 查看所有分支 $ git branch -a 2.2 切换分支 git checkout 分支名 git checkout feature/xx-1.7.0 2.3 查看当前所属分支 $ git branch -vv * feature/tq-xxxx-1.7.0 d477378d [origin/feature/tq-xxx-1.7.0] 【涂作权】 更新配置 master 331276ed [origin/master] 【涂作权】 解决命令行下执行脚本出错的问题 2.4 创建本地分支feature/tq-xxx-1.7.1 $ git branch feature/tq-xxx-1.7.1 $ git branch -a * feature/tq-xxx-1.7.0 feature/tq-xxx-1.7.1 master ... 2.5 切换到本地分支：feature/tq-xxx-1.7.1 git checkout feature/tq-xxx-1.7.1 2.6 远程分支就是本地分支push到服务器上。比如master就是一个最典型的远程分支（默认） git push origin feature/tq-xxx-1.7.1 2.7 删除本地分支 git branch -d feature/tq-xxx-1.7.1 2.8 删除远程分支 git push origin --delete feature/tq-xxx-1.7.1 2.9 更新代码 git pull origin feature/tq-xxx-1.7.1 2.10 批量删除远程分支 git branch -r | grep 'origin/AUTO' | xargs git branch -r -d xargs表示作为参数 3 git tag打标签（tag） 3.1 查看所有标签 git tag 默认标签是打在最新提交的commit上的 3.2 本地打新标签 git tag or git tag 16098ee1cbbc8a1884e19c6681735e1792f9b577 // 在某个commit上打tag // git log 查看commit版本号 例如：打v1.1.0标签 git tag v1.1.0 3.3 附注标签 git tag -a -m 例如, 打v1.1.0标签 git tag -a v1.1.0 -m 'v1.1.0 release' 3.4 本地推送到远程 git push origin // 推送一个标签到远程 or git push origin --tags // 推送全部未推送的本地标签 3.5. 本地删除标签 git tag -d 3.6 并远程删除标签 git push origin :refs/tags/ // 本地tag删除了，在执行该句，删除远程tag 3.7 git如何获取指定tag代码 A: 先git clone的方式获取代码 B: 切换到某个tag : git checkout tag_name C: 当前处于一个“detached HEAD” 状态 ,每一个 tag 就是代码仓库中的一个快照，如果你想编辑此tag 下的代码,上面的方法就不适用了.你需要把 tag 快照对应的代码拉取到一个分支上。 例如想编辑 v1.0的tag 代码，那么可以选择如下操作 git checkout -b new_branch v1.0 git checkout -b [分支名称] [tag标签名称] 4 git日志查看： 4.1 git log 如果日志特别多的话，在git bash中，按向下键来查看更多，按q键退出查看日志。 4.2 git show 查看最近一次commit内容，也可以后面加commit号，单独查看此次版本的日志 4.3 git log -p -p参数输出的信息会更多，用来显示提交的改动记录，相当于多次使用git show [commit_id]的结果。 git archive -o $PWD/version-$(git rev-parse HEAD)-latest.tar.gz $(git rev-parse HEAD) $(git diff --name-only HEAD HEAD~1) 5 git常使用的命令 1、git init —在当前目录新建一个代码库。 2、 git config user.name=””git config user.email=””—设置代码提交时候的信息。 3、 git clone 需要clone 远程地址 ––从服务器端克隆项目到本地 4、 git status —查看文件修改状态。 5、 git diff 文件路径 ––查看该文件与上次提交修改代码的差别。 6、 git diff –-cached 文件路径 ––查看本地缓冲和上次提交的差别。 7、 git checkout –b 分支名称 ––新建一个临时分支。 8、 git checkout 分支名称 ––切换分支。 9、 git branch —查看所有的分支。 10、 git branch –D temp —强制删除一个分支 11、 git pull —将服务端代码更新到本地。 12、 git add 文件路径 —提交文件到暂冲区。 13、 git add –A —提交所有的需要add 的文件到缓冲区。 14、 git commit –m ‘提交说明’—将缓冲区的文件提交到本地库中。提交说明尽量将提交内容简单明了的表达清楚。 15、 git push origin master —将已经提交到本地的仓库的代码push到远程服务器。 16、 git log —显示提交的日志。 17、 git show [commit 的Id] — 显示某次提交的元数据和内容变化。 18、 git show [commit Id] –-stat —-显示提交的文件名称 19、 git checkout —恢复暂存区的所有文件。 20、 git reset [file/commit ID] – 重置暂存区的指定文件。用来撤销git commit 21、 git reset –hard [commit 的Id] —将本地版本退回到提交之前的版本。这个操作会将自己新写的代码全部撤销没了。 22、 git cherry-pick temp —-合并临时分支到当前分支。 23、 git commit –amend —修改最近一次提交说明的内容同时可以合并提交。对已经Push 的无效。 24、git rm git commit -m “delete file” 分两步执行，可以删除远程仓库对应的文件 提交步骤 首先你先通过git init git clone 基本环境准备好后，你写完自己的代码想要提交到远程服务器。 git status 查看改动的文件有哪些 分别git diff 改动文件路径 看看有没有空格之类。检查格式，改动具体代码 确认无误后 git add 需要提交的文件路径 也可以加入改动的都是需要提交可以git add . git pull git commit -m “提交备注” 切记commit 之前 先git pull git push origin master 6 、其它 比对工具 kdiff3 Copyright © lin 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-09-16 15:13:51 "}}